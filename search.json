[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Python OR-tools Notes",
    "section": "",
    "text": "Preface"
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Introduction",
    "section": "",
    "text": "This book covers the usage of Google OR-Tools to solve optimization problems in Python. There are several major chapters in this book:\nIn Chapter 2, we explain the steps needed to setup OR-Tools in a Python environment.\nIn Chapter 3, we use an example to illustrate the modeling capability of OR-Tools to solve linear programming problems.\nIn Chapter 4, we go through the modeling techniques made available in OR-Tools."
  },
  {
    "objectID": "env-setup.html#install-homebrew",
    "href": "env-setup.html#install-homebrew",
    "title": "2  Environment Setup",
    "section": "2.1 Install Homebrew",
    "text": "2.1 Install Homebrew\nThe first tool we need is Homebrew, ‘the Missing Package Manager for macOS (or Linux)’, and it can be accessed at https://brew.sh/. To install Homebrew, just copy the command below and run it in the Terminal.\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\nWe can then use the brew --version command to check the installed version. On my system, it shows the info below.\n ~/ brew --version\nHomebrew 3.6.20\nHomebrew/homebrew-core (git revision 5f1582e4d55; last commit 2023-02-05)\nHomebrew/homebrew-cask (git revision fa3b8a669d; last commit 2023-02-05)"
  },
  {
    "objectID": "env-setup.html#install-anaconda",
    "href": "env-setup.html#install-anaconda",
    "title": "2  Environment Setup",
    "section": "2.2 Install Anaconda",
    "text": "2.2 Install Anaconda\nSince there are several Python versions available for our use and we may end up having multiple Python versions installed on our machine, it is important to use a consistent environment to work on our project in. Anaconda is a package and environment manager for Python and it provides easy-to-use tools to facilitate our data science needs. To install Anaconda, run the below command in the Terminal.\n ~/ brew install anaconda\nAfter the installation is done, we can use conda --version to verify whether it is available on our machine or not.\n ~/ conda --version\nconda 23.1.0"
  },
  {
    "objectID": "env-setup.html#create-a-conda-environment",
    "href": "env-setup.html#create-a-conda-environment",
    "title": "2  Environment Setup",
    "section": "2.3 Create a Conda Environment",
    "text": "2.3 Create a Conda Environment\nNow we will create a Conda environment named ‘ortools’. Execute the below command in the Terminal, which effectively creates the required environment with Python version 3.10.\n ~/ conda create -n ortools python=3.10\nRetrieving notices: ...working... done\nCollecting package metadata (current_repodata.json): done\nSolving environment: done\n\n## Package Plan ##\n\n  environment location: /opt/homebrew/anaconda3/envs/test\n\n  added / updated specs:\n    - python=3.10\n\n\nThe following packages will be downloaded:\n\n    package                    |            build\n    ---------------------------|-----------------\n    setuptools-67.4.0          |     pyhd8ed1ab_0         567 KB  conda-forge\n    ------------------------------------------------------------\n                                           Total:         567 KB\n\nThe following NEW packages will be INSTALLED:\n\n  bzip2              conda-forge/osx-arm64::bzip2-1.0.8-h3422bc3_4\n  ca-certificates    conda-forge/osx-arm64::ca-certificates-2022.12.7-h4653dfc_0\n  libffi             conda-forge/osx-arm64::libffi-3.4.2-h3422bc3_5\n  libsqlite          conda-forge/osx-arm64::libsqlite-3.40.0-h76d750c_0\n  libzlib            conda-forge/osx-arm64::libzlib-1.2.13-h03a7124_4\n  ncurses            conda-forge/osx-arm64::ncurses-6.3-h07bb92c_1\n  openssl            conda-forge/osx-arm64::openssl-3.0.8-h03a7124_0\n  pip                conda-forge/noarch::pip-23.0.1-pyhd8ed1ab_0\n  python             conda-forge/osx-arm64::python-3.10.9-h3ba56d0_0_cpython\n  readline           conda-forge/osx-arm64::readline-8.1.2-h46ed386_0\n  setuptools         conda-forge/noarch::setuptools-67.4.0-pyhd8ed1ab_0\n  tk                 conda-forge/osx-arm64::tk-8.6.12-he1e0b03_0\n  tzdata             conda-forge/noarch::tzdata-2022g-h191b570_0\n  wheel              conda-forge/noarch::wheel-0.38.4-pyhd8ed1ab_0\n  xz                 conda-forge/osx-arm64::xz-5.2.6-h57fd34a_0\n\n\nProceed ([y]/n)?\nType ‘y’ to proceed and Conda will create the environment for us. We can use cnoda env list to show all the created environments on our machine:\n ~/ conda env list\n# conda environments:\n#\nbase                     /opt/homebrew/anaconda3\nortools                   /opt/homebrew/anaconda3/envs/ortools\nNote that we need to manually activate an environemnt in order to use it: conda activate ortools. On my machine, the activated environment ortools will appear in the beginning of my prompt.\n ~/ conda activate ortools\n(ortools)  ~/"
  },
  {
    "objectID": "env-setup.html#install-google-or-tools",
    "href": "env-setup.html#install-google-or-tools",
    "title": "2  Environment Setup",
    "section": "2.4 Install Google OR-Tools",
    "text": "2.4 Install Google OR-Tools\nAs of this writing, the latest version of Google OR-Tools is 9.5.2237, and we can install it in our newly created environment using the command pip install ortools==9.5.2237. We can use conda list to verify whether it is available in our environment.\n(ortools)  ~/ conda list\n# packages in environment at /opt/homebrew/anaconda3/envs/ortools:\n#\n# Name                    Version                   Build  Channel\nabsl-py                   1.4.0                    pypi_0    pypi\nbzip2                     1.0.8                h3422bc3_4    conda-forge\nca-certificates           2022.12.7            h4653dfc_0    conda-forge\nlibffi                    3.4.2                h3422bc3_5    conda-forge\nlibsqlite                 3.40.0               h76d750c_0    conda-forge\nlibzlib                   1.2.13               h03a7124_4    conda-forge\nncurses                   6.3                  h07bb92c_1    conda-forge\nnumpy                     1.24.2                   pypi_0    pypi\nopenssl                   3.0.8                h03a7124_0    conda-forge\nortools                   9.5.2237                 pypi_0    pypi\npip                       23.0.1             pyhd8ed1ab_0    conda-forge\nprotobuf                  4.22.0                   pypi_0    pypi\npython                    3.10.9          h3ba56d0_0_cpython    conda-forge\nreadline                  8.1.2                h46ed386_0    conda-forge\nsetuptools                67.4.0             pyhd8ed1ab_0    conda-forge\ntk                        8.6.12               he1e0b03_0    conda-forge\ntzdata                    2022g                h191b570_0    conda-forge\nwheel                     0.38.4             pyhd8ed1ab_0    conda-forge\nxz                        5.2.6                h57fd34a_0    conda-forge\nNow we have Python and Google OR-Tools ready, we can start our next journey."
  },
  {
    "objectID": "linear-programming.html#modeling-capabilities",
    "href": "linear-programming.html#modeling-capabilities",
    "title": "3  Linear Programming",
    "section": "3.1 Modeling Capabilities",
    "text": "3.1 Modeling Capabilities\nThere are three components in a mathematical model, namely, decision varaibles, constraints and objective, for which we will go over in the following sections.\n\n3.1.1 Solver\nIn Google OR-Tools, a Solver instance must be created first so that variables, constraints and objective can be added to it. The Solver class is defined in the ortools.linear_solver.pywraplp module and it requires a solver id to instantiate an object. In the code snippet below, the required module is imported first and a solver object is created with GLOP, Google’s own optimization engine for solving linear programming problems. It is good practice to verify whether the desired solver is indeed created successfully or not.\n\nfrom ortools.linear_solver import pywraplp\n\nsolver = pywraplp.Solver.CreateSolver(\"GLOP\")\n\nif solver:\n    print(\"solver creation success!\")\nelse:\n    print(\"solver creation failure!\")\n\nsolver creation success!\n\n\n\n\n3.1.2 Decision Variables\nThe Solver class defines a number of ways to create decision variables:\n\nVar(lb, ub, integer, name)\nNumVar(lb, ub, name)\nIntVar(lb, ub, name)\nBoolVar(name)\n\n\nFunction Var()\n\nThe Var() method is the most flexible way to define variables, as it can be used to create numerical, integral and boolean variables. In the following code, a numerical variable named ‘var1’ is created with bound (0.0, 1.0). Note that the parameter integer is set to False in the call to function Var().\n\nvar1 = solver.Var(lb=0, ub=1.0, integer=False, name=\"var1\")\n\nWe could create an integer variable using the same function:\n\nvar2 = solver.Var(lb=0, ub=1.0, integer=True, name=\"var2\")\n\n\nFunction NumVar()\n\nvar1 could be creatd alternatively using the specialized function NumVar():\n\nvar1 = solver.NumVar(lb=0, ub=1.0, name=\"var1\")\n\n\nFunction IntVar()\n\nSimilarly, var2 could be created alternatively using the specialized function IntVar():\n\nvar2 = solver.IntVar(lb=0, ub=1.0, name=\"var2\")\n\n\nFunction BoolVar()\n\nA boolean variable could be created using the BoolVar() function:\n\nvar3 = solver.BoolVar(name=\"var3\")\n\n\n\n3.1.3 Constraints\nConstraints limit the solution space of an optimization problem, and there are two ways to define constraints in Google OR-Tools. In the first approach, we could use the Add() function to create a constraint and automatically add it to the model at the same time, as the below code snippet illustrates.\n\ncons1 = solver.Add(constraint=var1 + var2 <= 1, name=\"cons1\")\n\ntype(cons1)\n\nortools.linear_solver.pywraplp.Constraint\n\n\nNote that the Add() function returns an object of the Constraint class defined in the pywraplp module, as shown in the code output. It is a good practice to retain the reference of the newly created constraint, as we might want to query its information later on.\nThe second approach works in a slightly different way. It starts with an empty constraint, with potential lower bound and upper bounds provided, and add components of the constraint gradually. The code snippet below shows an example of adding a second constraint to the model. In this approach, we must retain the reference to the constraint, as it is needed to add decision variables to the constraint in following steps.\n\ncons2 = solver.Constraint(-solver.infinity(), 10.0, \"cons2\")\ncons2.SetCoefficient(var1, 2)\ncons2.SetCoefficient(var2, 3)\ncons2.SetCoefficient(var3, 4)\ntype(cons2)\n\nortools.linear_solver.pywraplp.Constraint\n\n\n\n\n3.1.4 Objective\nSimilar to constraints, there are two ways to define the objective in Google OR-Tools. In the first approach, we directly add an objective to the model by using the Maximize() or Minimize() function. Below is an example:\n\nsolver.Minimize(var1 + var2 + var3)\n\nNote that the function itself does not return a reference to the newly created objective function, but we could use a dedicated function to retrive it:\n\nobj = solver.Objective()\nprint(obj)\n\n<ortools.linear_solver.pywraplp.Objective; proxy of <Swig Object of type 'operations_research::MPObjective *' at 0x10815d9b0> >\n\n\nIn the second approach, we build the objective incrementally, just as in the second approach of creating constraints. Specifically, we start with an empty objective function, and gradually add components to it. In the end, we specify the optimization sense - whether we want to maximize or minimnize the objective.\n\nobj = solver.Objective()\nobj.SetCoefficient(var1, 1.0)\nobj.SetCoefficient(var2, 1.0)\nobj.SetCoefficient(var3, 1.0)\nobj.SetMinimization()\nprint(obj)\n\n<ortools.linear_solver.pywraplp.Objective; proxy of <Swig Object of type 'operations_research::MPObjective *' at 0x10815dc20> >\n\n\n\n\n3.1.5 Objective and Constraint Expressions\nWhen we build constraints or objective functions, sometimes they comprise of complex expressions that we would like to build incrementally, possibly within loops. For example, we might have a mathematical expression of the form \\(expr = 2x_1 + 3x_2 + 4x_3 + x_4\\), which could be part of the objective function or any constraints. In this case, we can either use the aforementioned SetCoefficient() function to add each element of the expression to the constraint or objective, or we could build an expression first and add it once in the end. The code snippet below shows an example.\n\ninfinity = solver.Infinity()\nx1 = solver.NumVar(0, infinity, name=\"x1\")\nx2 = solver.NumVar(0, infinity, name=\"x2\")\nx3 = solver.NumVar(0, infinity, name=\"x3\")\nx4 = solver.NumVar(0, infinity, name=\"x4\")\n\nexpr = []\nexpr.append(2 * x1)\nexpr.append(3 * x2)\nexpr.append(4 * x3)\nexpr.append(x4)\n\nconstr = solver.Add(solver.Sum(expr) <= 10)\nprint(constr)\n\nsolver.Minimize(solver.Sum(expr))\n\n<ortools.linear_solver.pywraplp.Constraint; proxy of <Swig Object of type 'operations_research::MPConstraint *' at 0x10815c5d0> >\n\n\nOf course, it is not obvious here that the retitive calls to the append() method are any more convenient than the SetCoefficient() method. Let’s say that we have a slightly more complex expression of the form \\(\\sum_{0 \\le i < 4}w_i \\cdot x_i\\), now we could build the expression using a loop:\n\nw = [2, 3, 4, 1]\nx = [x1, x2, x3, x4]\nexpr = []\nfor i in range(4):\n    expr.append(w[i] * x[i])\n\nconstr = solver.Add(solver.Sum(expr) <= 10)\n\n\n\n3.1.6 Query the Model\nAfter we build the model, we can query it using some helper functions. For example, to get the total number of constraints, we use the NumVariables() function. In a similar fashion, we can retrieve the total number of constraints with the NumConstraints() function.\n\nnum_vars = solver.NumVariables()\nprint(f\"there are a total of {num_vars} variables in the model\")\n\nnum_constr = solver.NumConstraints()\nprint(f\"there are a total of {num_constr} constraints in the model\")\n\nthere are a total of 9 variables in the model\nthere are a total of 4 constraints in the model"
  },
  {
    "objectID": "linear-programming.html#applications",
    "href": "linear-programming.html#applications",
    "title": "3  Linear Programming",
    "section": "3.2 Applications",
    "text": "3.2 Applications\nIn this section, we use some examples to showcase the modeling capability of Google OR-Tools.\n\n3.2.1 Trivial Problem\nWe now consider an simple linear programming problem with two decision variables \\(x\\) and \\(y\\). The formal mathematical model is defined as below:\n\\[\\begin{align}\n\\text{max.} \\quad & x + 2y \\\\\n\\text{s.t.} \\quad & x + y \\le 10 \\\\\n& x >= 1 \\\\\n& y >= 1\n\\end{align}\\]\nFigure 3.1 shows the three defining constraints represented in blue lines and the feasible space depicted by the orange shaded area. The objective function is indicated by the red dashed lines. It can be seen from the figure that the point in green circle gives the maximal objective value of 19.\n\n\n\n\n\nFigure 3.1: A simple LP example\n\n\n\n\nLet’s now use Google OR-Tools to model and solve this problem. The code snippet below shows the complete program.\n\n# import Google OR-Tools library\nfrom ortools.linear_solver import pywraplp\n\n# create a solver\nsolver = pywraplp.Solver.CreateSolver(\"GLOP\")\n\n# create decision variables\nx = solver.NumVar(1.0, solver.Infinity(), \"x\")\ny = solver.NumVar(1.0, solver.Infinity(), \"y\")\n\n# create constraints\nconstr = solver.Add(x + y <= 10)\n\n# create objective\nsolver.Maximize(x + 2 * y)\n\n# solve the problem\nstatus = solver.Solve()\n\nif status == pywraplp.Solver.OPTIMAL or status == pywraplp.Solver.FEASIBLE:\n    print(f\"obj = {solver.Objective().Value()}\")\n    print(f\"x = {x.solution_value()}, reduced cost = {x.reduced_cost()}\")\n    print(f\"y = {y.solution_value()}, reduced cost = {y.reduced_cost()}\")\n    print(f\"constr dual value = {constr.dual_value()}\")\n\nobj = 19.0\nx = 1.0, reduced cost = -1.0\ny = 9.0, reduced cost = 0.0\ncons dual value = 2.0\n\n\nWe can see from the output that the optimal solution is \\(x = 1.0\\) and \\(y = 9.0\\), and the optimal objective is 19.0. This can also be validated from Figure 3.1 that the optimal solution is exactly the green point that sits at the intersection of the three lines \\(x = 1\\), \\(x + y = 10\\) and \\(x + 2y = 19\\).\nFigure 3.1 also shows that the point (1, 1) should give us the minimal value of the objective function. To validate this, we can actually change the optimization sense of the objective function from maximization to minimization using the function SetOptimizationDirection(), as shown in the code below:\n\nsolver.Objective().SetOptimizationDirection(maximize=False)\n\nsolver.Solve()\n\nprint(f\"obj = {solver.Objective().Value()}\")\nprint(f\"x = {x.solution_value()}, reduced cost = {x.reduced_cost()}\")\nprint(f\"y = {y.solution_value()}, reduced cost = {y.reduced_cost()}\")\nprint(f\"constr dual value = {constr.dual_value()}\")\n\nobj = 3.0\nx = 1.0, reduced cost = 1.0\ny = 1.0, reduced cost = 2.0\ncons dual value = 0.0\n\n\n\n\n3.2.2 Transportation Problem\nThe transportation problem involves moving goods from its sources \\(\\mathcal{S}\\) to destinations \\(\\mathcal{D}\\). Each source \\(s \\in \\mathcal{S}\\) has a total amount of goods \\(p_s\\) it could supply, and each destination \\(s \\in \\mathcal{D}\\) has a certain amount of demands \\(m_d\\). There is a transportation cost, denoted by \\(c_{sd}\\), to move one unit of goods from a source to a destination. The problem is to find the best set of goods to move from each source to each destination such that all the destination demands are met with the lowest transportation costs.\nTo model this transportation problem, we define the decision variable \\(x_{sd}\\) to be the amount of goods moving from source \\(s\\) to destinaiton \\(d\\). Then we could state the problem mathematically as below.\n\\[\\begin{align}\n\\text{min.} &\\quad \\sum_{s \\in \\mathcal{S}} \\sum_{d \\in \\mathcal{D}} c_{sd} x_{sd} \\label{tp-obj} \\\\\n\\text{s.t.} & \\quad \\sum_{d \\in \\mathcal{D}} x_{sd} = p_s, \\ \\forall s \\in \\mathcal{S} \\label{tp-cons1} \\\\\n& \\sum_{s \\in \\mathcal{S}} x_{sd} = m_d, \\ \\forall d \\in \\mathcal{D} \\label{tp-cons2} \\\\\n& x_{sd} \\geq 0, \\ \\forall s \\in \\mathcal{S}, d \\in \\mathcal{D} \\label{tp-cons3}\n\\end{align}\\]\nThe objective function \\(\\eqref{tp-obj}\\) aims to minimize the total transportation costs going from all sources to all destinations. Constraints \\(\\eqref{tp-cons1}\\) make sure that the sum of goods leaving a source node \\(s\\) must equal to its available supply \\(p_s\\). Constraints \\(\\eqref{tp-cons2}\\) require that the sum of goods gonig to a destination node \\(d\\) must equal to its demand \\(m_d\\). Constraints \\(\\eqref{tp-cons3}\\) state that the flow variables from sources to destination can only be nonnegative values.\nTable 3.1 shows an instance of the transportation problem in which there are four sources and five destinations. Entries in the last row give the corresponding demand from each destination, and the last column list the available supply at each source. The entries in the middle of the table show the transportation cost associated with moving from a specific source to a specific destination. For example, it costs $18 to move one unit of good from source S2 to D3.\n\n\n\n\nTable 3.1: A transportation problem\n\n\n\nD1\nD2\nD3\nD4\nD5\nSupply\n\n\n\n\nS1\n8\n5\n13\n12\n12\n58\n\n\nS2\n8\n7\n18\n6\n5\n55\n\n\nS3\n11\n12\n5\n11\n18\n64\n\n\nS4\n19\n13\n5\n10\n18\n71\n\n\nDemand\n44\n28\n36\n52\n88\n248\n\n\n\n\n\n\nWe show here two modeling flavors of using OR-Tools to solve this problem. In the first approach, decision variables are created using the NumVar() function, cnostraints are defined using the Add() function and the objective function is added using the Minimize() function. Note that both constraints and the objective function are generated with the help of of Sum() function that creates an expression.\n\nfrom ortools.linear_solver import pywraplp\n\n# gather data\nnum_sources = 4\nnum_destinations = 5\nsupplies = [58, 55, 64, 71]\ndemands = [44, 28, 36, 52, 88]\ncosts = [[8, 5, 13, 12, 12], \n        [8, 7, 18, 6, 5], \n        [11, 12, 5, 11, 18], \n        [19, 13, 5, 10, 18]]\n\n# create solver\nsolver = pywraplp.Solver.CreateSolver(\"GLOP\")\n\n# create decision variables\nvar_flow = []\nfor src_idx in range(num_sources):\n    vars = [\n        solver.NumVar(0, solver.Infinity(), \n                    name=f\"var_{src_idx}, {dest_idx}\")\n        for dest_idx in range(num_destinations)\n    ]\n    var_flow.append(vars)\n\n# create constraints\nfor src_idx in range(num_sources):\n    expr = [var_flow[src_idx][dest_idx] \n            for dest_idx in range(num_destinations)]\n    solver.Add(solver.Sum(expr) == supplies[src_idx])\n\nfor dest_idx in range(num_destinations):\n    expr = [var_flow[src_idx][dest_idx] \n            for src_idx in range(num_sources)]\n    solver.Add(solver.Sum(expr) == demands[dest_idx])\n\n# create objective function\nobj_expr = []\nfor src_idx in range(num_sources):\n    for dest_idx in range(num_destinations):\n        obj_expr.append(var_flow[src_idx][dest_idx] * costs[src_idx][dest_idx])\nsolver.Minimize(solver.Sum(obj_expr))\n\nstatus = solver.Solve()\n\nopt_flow = []\nif status == pywraplp.Solver.OPTIMAL:\n    print(f\"optimal obj = {solver.Objective().Value()}\")\n    for src_idx in range(num_sources):\n        opt_vals = [var_flow[src_idx][dest_idx].solution_value()\n                    for dest_idx in range(num_destinations)]\n        opt_flow.append(opt_vals)\n\noptimal obj = 2013.0\n\n\nThe optimal solution is shown in Table 3.2.\n\n\n\n\nTable 3.2: The optimal solution\n\n\n\nD1\nD2\nD3\nD4\nD5\nSupply\n\n\n\n\nS1\n0\n28\n0\n0\n30\n58\n\n\nS2\n0\n0\n0\n0\n55\n55\n\n\nS3\n44\n0\n20\n0\n0\n64\n\n\nS4\n0\n0\n16\n52\n3\n71\n\n\nDemand\n44\n28\n36\n52\n88\n248\n\n\n\n\n\n\nIn the second approach shown in the code snippet below, decision variables are created with the Var(integer=False) method instead of the NumVar() method. In addition, both constraints and the objective function are created using the SetCoefficient() method. In the case of constraints, a lower bound and upper bound are used to generated an empty constraint, and variables are then added to the constraint one by one with their corresponding coefficient. In the case of the objective function, an empty objective is first initialized and variables are then added to it sequentially. Note that the optimization sense is set using the SetMinimization() function.\n\nfrom ortools.linear_solver import pywraplp\n\n# gather data\nnum_sources = 4\nnum_destinations = 5\nsupplies = [58, 55, 64, 71]\ndemands = [44, 28, 36, 52, 88]\ncosts = [[8, 5, 13, 12, 12], \n        [8, 7, 18, 6, 5], \n        [11, 12, 5, 11, 18],\n        [19, 13, 5, 10, 18]]\n\n# create solver\nsolver = pywraplp.Solver.CreateSolver(\"GLOP\")\n\n# create decision variables\nvar_flow = []\nfor src_idx in range(num_sources):\n    vars = [\n        solver.Var(\n            0, solver.Infinity(), integer=False, \n            name=f\"var_{src_idx}, {dest_idx}\"\n        )\n        for dest_idx in range(num_destinations)\n    ]\n    var_flow.append(vars)\n\n# create constraints\nfor src_idx in range(num_sources):\n    constr = solver.Constraint(supplies[src_idx], supplies[src_idx])\n    for dest_idx in range(num_destinations):\n        constr.SetCoefficient(var_flow[src_idx][dest_idx], 1.0)\n\nfor dest_idx in range(num_destinations):\n    constr = solver.Constraint(demands[dest_idx], demands[dest_idx])\n    for src_idx in range(num_sources):\n        constr.SetCoefficient(var_flow[src_idx][dest_idx], 1.0)\n\n# create objective function\nobj = solver.Objective()\nfor src_idx in range(num_sources):\n    for dest_idx in range(num_destinations):\n        obj.SetCoefficient(var_flow[src_idx][dest_idx], costs[src_idx][dest_idx])\nobj.SetMinimization()\n\nstatus = solver.Solve()\n\nopt_flow = []\nif status == pywraplp.Solver.OPTIMAL:\n    print(f\"optimal obj = {solver.Objective().Value()}\")\n    for src_idx in range(num_sources):\n        opt_vals = [var_flow[src_idx][dest_idx].solution_value()\n                    for dest_idx in range(num_destinations)]\n        opt_flow.append(opt_vals)\n\noptimal obj = 2013.0\n\n\nTo validate the results, Table 3.3 shows the optimal solution produced by the second modeling approach, which is the same as in the previous approach.\n\n\n\n\nTable 3.3: The optimal solution\n\n\n\nD1\nD2\nD3\nD4\nD5\nSupply\n\n\n\n\nS1\n0\n28\n0\n0\n30\n58\n\n\nS2\n0\n0\n0\n0\n55\n55\n\n\nS3\n44\n0\n20\n0\n0\n64\n\n\nS4\n0\n0\n16\n52\n3\n71\n\n\nDemand\n44\n28\n36\n52\n88\n248\n\n\n\n\n\n\n\n\n3.2.3 Resource Allocation Problem\nThe resource allocation problems involves distributing scarce resources among alternative activities. The resources could be machines in a manufacturing facility, money available to spend, or CPU runtime. The activities could be anything that brings profit at the cost of consuming resources. The objective of this problem is therefore to allocate the available resources to activities such that the total profit is maximized.\nHere, we give a general resource allocation model devoid of any practical meanings. To this end, we define a few input parameters to this problem:\n\n\\(\\mathcal{A}\\): the set of candidate activities\n\\(\\mathcal{R}\\): the set of avaiable resources\n\\(p_a\\): the profit of performing one unit of activity \\(a \\in \\mathcal{A}\\)\n\\(c_{ar}\\): the amount of resource \\(r \\in \\mathcal{R}\\) required by one unit of activity \\(a \\in \\mathcal{A}\\)\n\\(b_r\\): the total amount of available quantities for resource \\(r \\in \\mathcal{R}\\)\n\nThe decision variable \\(x_a\\) represents the amount of activity \\(a \\in \\mathcal{A}\\) we select to perform, and the mathematical mode is defined below:\n\\[\\begin{align}\n\\text{max.} &\\quad \\sum_{a \\in \\mathcal{A}} p_a x_a \\label{ra-obj} \\\\\n\\text{s.t.} & \\quad \\sum_{a \\in \\mathcal{A}} c_{ar} \\leq b_r, \\ \\forall r \\in \\mathcal{R} \\label{ra-cons1} \\\\\n& x_a \\geq 0, \\ a \\in \\mathcal{A}\n\\end{align}\\]\nTable 3.4 shows an instance of the resource allocation problem, in which there are three type of resources and five candidate activities. The last row gives the profit of performing each unit of an activity, while the last column shows the available amount of resources. The remaining entries in the table refer to the resource consumption for each activity. For example, selecting one unit of activity 1 (A1) requires 90, 64 and 55 units of resources R1, R2 and R3, respectively.\n\n\n\n\nTable 3.4: A resource allocation problem\n\n\n\nA1\nA2\nA3\nA4\nA5\nAvailable\n\n\n\n\nR1\n90\n57\n51\n97\n67\n2001\n\n\nR2\n64\n58\n97\n56\n93\n2616\n\n\nR3\n55\n87\n77\n52\n51\n1691\n\n\nProfit\n1223\n1238\n1517\n1616\n1027\n\n\n\n\n\n\n\nIn the code snippet below, we use Google OR-Tools to solve this problem instance. Again, we start with initializing a solver object, follwed by creation of five decision variables, one for each activity. Both the constraints and objective function are created using the first modeling approach demonstrated previously. The optimal solution is outputed in the end.\n\nfrom ortools.linear_solver import pywraplp\n\n# gather instance data\nnum_resources = 3\nnum_activities = 5\nprofits = [1223, 1238, 1517, 1616, 1027]\navailable_resources = [2001, 2616, 1691]\ncosts = [[90, 57, 51, 97, 67],\n        [64, 58, 97, 56, 93],\n        [55, 87, 77, 52, 51]]\n\n# initialize a solver object\nsolver = pywraplp.Solver.CreateSolver(\"GLOP\")\n\ninfinity = solver.Infinity()\n# create decision variables\nvar_x = [solver.NumVar(0, infinity, name=f\"x_P{a}\") \n        for a in range(num_activities)]\n\n# create objective function\nsolver.Maximize(solver.Sum([profits[a] * var_x[a] \n                            for a in range(num_activities)]))\n\n# create constraints\nfor r_idx in range(num_resources):\n    cons = solver.Add(\n            solver.Sum([costs[r_idx][a_idx] * var_x[a_idx] \n                        for a_idx in range(num_activities)]) \n                      <= available_resources[r_idx])\n    \nstatus = solver.Solve()\nif status != pywraplp.Solver.OPTIMAL:\n    print(\"solver failure!\")\n\nprint(\"solve complete!\")\nopt_obj = solver.Objective().Value()\nprint(f\"optimal obj = {opt_obj:.2f}\")\n\nopt_sol = [var_x[a_idx].solution_value() \n           for a_idx in range(num_activities)]\nfor a_idx in range(num_activities):\n    print(f\"opt_x[{a_idx + 1}] = {opt_sol[a_idx]:.2f}\")\n\nsolve complete!\noptimal obj = 41645.23\nopt_x[1] = 0.00\nopt_x[2] = 0.00\nopt_x[3] = 12.45\nopt_x[4] = 14.08\nopt_x[5] = 0.00\n\n\n\n\n3.2.4 Workforce Planning Problem\nIn the workforce planning problem,\n\n\n3.2.5 Sudoku Problem\nIn the Sudoku problem,"
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "6  Summary",
    "section": "",
    "text": "In summary, this book has no content whatsoever."
  }
]