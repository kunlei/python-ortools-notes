[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Python OR-tools Notes",
    "section": "",
    "text": "Preface"
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Introduction",
    "section": "",
    "text": "This book covers the usage of Google OR-Tools to solve optimization problems in Python. There are several major chapters in this book:\nIn Chapter 2, we explain the steps needed to setup OR-Tools in a Python environment.\nIn Chapter 3, we use an example to illustrate the modeling capability of OR-Tools to solve linear programming problems.\nIn Chapter 4, we go through the modeling techniques made available in OR-Tools."
  },
  {
    "objectID": "env-setup.html#install-homebrew",
    "href": "env-setup.html#install-homebrew",
    "title": "2  Environment Setup",
    "section": "2.1 Install Homebrew",
    "text": "2.1 Install Homebrew\nThe first tool we need is Homebrew, ‘the Missing Package Manager for macOS (or Linux)’, and it can be accessed at https://brew.sh/. To install Homebrew, just copy the command below and run it in the Terminal.\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\nWe can then use the brew --version command to check the installed version. On my system, it shows the info below.\n ~/ brew --version\nHomebrew 3.6.20\nHomebrew/homebrew-core (git revision 5f1582e4d55; last commit 2023-02-05)\nHomebrew/homebrew-cask (git revision fa3b8a669d; last commit 2023-02-05)"
  },
  {
    "objectID": "env-setup.html#install-anaconda",
    "href": "env-setup.html#install-anaconda",
    "title": "2  Environment Setup",
    "section": "2.2 Install Anaconda",
    "text": "2.2 Install Anaconda\nSince there are several Python versions available for our use and we may end up having multiple Python versions installed on our machine, it is important to use a consistent environment to work on our project in. Anaconda is a package and environment manager for Python and it provides easy-to-use tools to facilitate our data science needs. To install Anaconda, run the below command in the Terminal.\n ~/ brew install anaconda\nAfter the installation is done, we can use conda --version to verify whether it is available on our machine or not.\n ~/ conda --version\nconda 23.1.0"
  },
  {
    "objectID": "env-setup.html#create-a-conda-environment",
    "href": "env-setup.html#create-a-conda-environment",
    "title": "2  Environment Setup",
    "section": "2.3 Create a Conda Environment",
    "text": "2.3 Create a Conda Environment\nNow we will create a Conda environment named ‘ortools’. Execute the below command in the Terminal, which effectively creates the required environment with Python version 3.10.\n ~/ conda create -n ortools python=3.10\nRetrieving notices: ...working... done\nCollecting package metadata (current_repodata.json): done\nSolving environment: done\n\n## Package Plan ##\n\n  environment location: /opt/homebrew/anaconda3/envs/test\n\n  added / updated specs:\n    - python=3.10\n\n\nThe following packages will be downloaded:\n\n    package                    |            build\n    ---------------------------|-----------------\n    setuptools-67.4.0          |     pyhd8ed1ab_0         567 KB  conda-forge\n    ------------------------------------------------------------\n                                           Total:         567 KB\n\nThe following NEW packages will be INSTALLED:\n\n  bzip2              conda-forge/osx-arm64::bzip2-1.0.8-h3422bc3_4\n  ca-certificates    conda-forge/osx-arm64::ca-certificates-2022.12.7-h4653dfc_0\n  libffi             conda-forge/osx-arm64::libffi-3.4.2-h3422bc3_5\n  libsqlite          conda-forge/osx-arm64::libsqlite-3.40.0-h76d750c_0\n  libzlib            conda-forge/osx-arm64::libzlib-1.2.13-h03a7124_4\n  ncurses            conda-forge/osx-arm64::ncurses-6.3-h07bb92c_1\n  openssl            conda-forge/osx-arm64::openssl-3.0.8-h03a7124_0\n  pip                conda-forge/noarch::pip-23.0.1-pyhd8ed1ab_0\n  python             conda-forge/osx-arm64::python-3.10.9-h3ba56d0_0_cpython\n  readline           conda-forge/osx-arm64::readline-8.1.2-h46ed386_0\n  setuptools         conda-forge/noarch::setuptools-67.4.0-pyhd8ed1ab_0\n  tk                 conda-forge/osx-arm64::tk-8.6.12-he1e0b03_0\n  tzdata             conda-forge/noarch::tzdata-2022g-h191b570_0\n  wheel              conda-forge/noarch::wheel-0.38.4-pyhd8ed1ab_0\n  xz                 conda-forge/osx-arm64::xz-5.2.6-h57fd34a_0\n\n\nProceed ([y]/n)?\nType ‘y’ to proceed and Conda will create the environment for us. We can use cnoda env list to show all the created environments on our machine:\n ~/ conda env list\n# conda environments:\n#\nbase                     /opt/homebrew/anaconda3\nortools                   /opt/homebrew/anaconda3/envs/ortools\nNote that we need to manually activate an environemnt in order to use it: conda activate ortools. On my machine, the activated environment ortools will appear in the beginning of my prompt.\n ~/ conda activate ortools\n(ortools)  ~/"
  },
  {
    "objectID": "env-setup.html#install-google-or-tools",
    "href": "env-setup.html#install-google-or-tools",
    "title": "2  Environment Setup",
    "section": "2.4 Install Google OR-Tools",
    "text": "2.4 Install Google OR-Tools\nAs of this writing, the latest version of Google OR-Tools is 9.5.2237, and we can install it in our newly created environment using the command pip install ortools==9.5.2237. We can use conda list to verify whether it is available in our environment.\n(ortools)  ~/ conda list\n# packages in environment at /opt/homebrew/anaconda3/envs/ortools:\n#\n# Name                    Version                   Build  Channel\nabsl-py                   1.4.0                    pypi_0    pypi\nbzip2                     1.0.8                h3422bc3_4    conda-forge\nca-certificates           2022.12.7            h4653dfc_0    conda-forge\nlibffi                    3.4.2                h3422bc3_5    conda-forge\nlibsqlite                 3.40.0               h76d750c_0    conda-forge\nlibzlib                   1.2.13               h03a7124_4    conda-forge\nncurses                   6.3                  h07bb92c_1    conda-forge\nnumpy                     1.24.2                   pypi_0    pypi\nopenssl                   3.0.8                h03a7124_0    conda-forge\nortools                   9.5.2237                 pypi_0    pypi\npip                       23.0.1             pyhd8ed1ab_0    conda-forge\nprotobuf                  4.22.0                   pypi_0    pypi\npython                    3.10.9          h3ba56d0_0_cpython    conda-forge\nreadline                  8.1.2                h46ed386_0    conda-forge\nsetuptools                67.4.0             pyhd8ed1ab_0    conda-forge\ntk                        8.6.12               he1e0b03_0    conda-forge\ntzdata                    2022g                h191b570_0    conda-forge\nwheel                     0.38.4             pyhd8ed1ab_0    conda-forge\nxz                        5.2.6                h57fd34a_0    conda-forge\nNow we have Python and Google OR-Tools ready, we can start our next journey."
  },
  {
    "objectID": "linear-programming.html#modeling-capabilities",
    "href": "linear-programming.html#modeling-capabilities",
    "title": "3  Linear Programming",
    "section": "3.1 Modeling Capabilities",
    "text": "3.1 Modeling Capabilities\nThere are three components in a mathematical model, namely, decision varaibles, constraints and objective, for which we will go over in the following sections.\n\n3.1.1 Solver\nIn Google OR-Tools, a Solver instance must be created first so that variables, constraints and objective can be added to it. The Solver class is defined in the ortools.linear_solver.pywraplp module and it requires a solver id to instantiate an object. In the code snippet below, the required module is imported first and a solver object is created with GLOP, Google’s own optimization engine for solving linear programming problems. It is good practice to verify whether the desired solver is indeed created successfully or not.\n\nfrom ortools.linear_solver import pywraplp\n\nsolver = pywraplp.Solver.CreateSolver(\"GLOP\")\n\nif solver:\n    print(\"solver creation success!\")\nelse:\n    print(\"solver creation failure!\")\n\nsolver creation success!\n\n\n\n\n3.1.2 Decision Variables\nThe Solver class defines a number of ways to create decision variables:\n\nVar(lb, ub, integer, name)\nNumVar(lb, ub, name)\nIntVar(lb, ub, name)\nBoolVar(name)\n\n\nFunction Var()\n\nThe Var() method is the most flexible way to define variables, as it can be used to create numerical, integral and boolean variables. In the following code, a numerical variable named ‘var1’ is created with bound (0.0, 1.0). Note that the parameter integer is set to False in the call to function Var().\n\nvar1 = solver.Var(lb=0, ub=1.0, integer=False, name=\"var1\")\n\nWe could create an integer variable using the same function:\n\nvar2 = solver.Var(lb=0, ub=1.0, integer=True, name=\"var2\")\n\n\nFunction NumVar()\n\nvar1 could be creatd alternatively using the specialized function NumVar():\n\nvar1 = solver.NumVar(lb=0, ub=1.0, name='var1')\n\n\nFunction IntVar()\n\nSimilarly, var2 could be created alternatively using the specialized function IntVar():\n\nvar2 = solver.IntVar(lb=0, ub=1.0, name='var2')\n\n\nFunction BoolVar()\n\nA boolean variable could be created using the BoolVar() function:\n\nvar3 = solver.BoolVar(name='var3')\n\n\n\n3.1.3 Constraints\nConstraints limit the solution space of an optimization problem, and there are two ways to define constraints in Google OR-Tools. In the first approach, we could use the Add() function to create a constraint and automatically add it to the model at the same time, as the below code snippet illustrates.\n\ncons1 = solver.Add(constraint=var1 + var2 <= 1, name=\"cons1\")\n\ntype(cons1)\n\nortools.linear_solver.pywraplp.Constraint\n\n\nNote that the Add() function returns an object of the Constraint class defined in the pywraplp module, as shown in the code output. It is a good practice to retain the reference of the newly created constraint, as we might want to query its information later on.\nThe second approach works in a slightly different way. It starts with an empty constraint, with potential lower bound and upper bounds provided, and add components of the constraint gradually. The code snippet below shows an example of adding a second constraint to the model. In this approach, we must retain the reference to the constraint, as it is needed to add decision variables to the constraint in following steps.\n\ncons2 = solver.Constraint(-solver.infinity(), 10.0, \"cons2\")\ncons2.SetCoefficient(var1, 2)\ncons2.SetCoefficient(var2, 3)\ncons2.SetCoefficient(var3, 4)\ntype(cons2)\n\nortools.linear_solver.pywraplp.Constraint\n\n\n\n\n3.1.4 Objective\nSimilar to constraints, there are two ways to define the objective in Google OR-Tools. In the first approach, we directly add an objective to the model by using the Maximize() or Minimize() function. Below is an example:\n\nsolver.Minimize(var1 + var2 + var3)\n\nNote that the function itself does not return a reference to the newly created objective function, but we could use a dedicated function to retrive it:\n\nobj = solver.Objective()\nprint(obj)\n\n<ortools.linear_solver.pywraplp.Objective; proxy of <Swig Object of type 'operations_research::MPObjective *' at 0x10815d9b0> >\n\n\nIn the second approach, we build the objective incrementally, just as in the second approach of creating constraints. Specifically, we start with an empty objective function, and gradually add components to it. In the end, we specify the optimization sense - whether we want to maximize or minimnize the objective.\n\nobj = solver.Objective()\nobj.SetCoefficient(var1, 1.0)\nobj.SetCoefficient(var2, 1.0)\nobj.SetCoefficient(var3, 1.0)\nobj.SetMinimization()\nprint(obj)\n\n<ortools.linear_solver.pywraplp.Objective; proxy of <Swig Object of type 'operations_research::MPObjective *' at 0x10815dc20> >\n\n\n\n\n3.1.5 Objective and Constraint Expressions\nWhen we build constraints or objective functions, sometimes they comprise of complex expressions that we would like to build incrementally, possibly within loops. For example, we might have a mathematical expression of the form \\(expr = 2x_1 + 3x_2 + 4x_3 + x_4\\), which could be part of the objective function or any constraints. In this case, we can either use the aforementioned SetCoefficient() function to add each element of the expression to the constraint or objective, or we could build an expression first and add it once in the end. The code snippet below shows an example.\n\ninfinity = solver.Infinity()\nx1 = solver.NumVar(0, infinity, name=\"x1\")\nx2 = solver.NumVar(0, infinity, name=\"x2\")\nx3 = solver.NumVar(0, infinity, name=\"x3\")\nx4 = solver.NumVar(0, infinity, name=\"x4\")\n\nexpr = []\nexpr.append(2 * x1)\nexpr.append(3 * x2)\nexpr.append(4 * x3)\nexpr.append(x4)\n\ncons = solver.Add(solver.Sum(expr) <= 10)\nprint(cons)\n\nsolver.Minimize(solver.Sum(expr))\n\n<ortools.linear_solver.pywraplp.Constraint; proxy of <Swig Object of type 'operations_research::MPConstraint *' at 0x10815c5d0> >\n\n\nOf course, it is not obvious here that the retitive calls to the append() method are any more convenient than the SetCoefficient() method. Let’s say that we have a slightly more complex expression of the form \\(\\sum_{0 \\le i < 4}w_i \\cdot x_i\\), now we could build the expression using a loop:\n\nw = [2, 3, 4, 1]\nx = [x1, x2, x3, x4]\nexpr = []\nfor i in range(4):\n    expr.append(w[i] * x[i])\n\ncons = solver.Add(solver.Sum(expr) <= 10)\n\n\n\n3.1.6 Query the Model\nAfter we build the model, we can query it using some helper functions. For example, to get the total number of constraints, we use the NumVariables() function. In a similar fashion, we can retrieve the total number of constraints with the NumConstraints() function.\n\nnum_vars = solver.NumVariables()\nprint(f\"there are a total of {num_vars} variables in the model\")\n\nnum_cons = solver.NumConstraints()\nprint(f\"there are a total of {num_cons} constraints in the model\")\n\nthere are a total of 9 variables in the model\nthere are a total of 4 constraints in the model"
  },
  {
    "objectID": "linear-programming.html#applications",
    "href": "linear-programming.html#applications",
    "title": "3  Linear Programming",
    "section": "3.2 Applications",
    "text": "3.2 Applications\nIn this section, we use some examples to showcase the modeling capability of Google OR-Tools.\n\n3.2.1 An Artificial Example\nWe now consider an simple linear programming problem with two decision variables \\(x\\) and \\(y\\). The formal mathematical model is defined as below:\n\\[\\begin{align}\n\\text{max.} \\quad & x + 2y \\\\\n\\text{s.t.} \\quad & x + y \\le 10 \\\\\n& x >= 1 \\\\\n& y >= 1\n\\end{align}\\]\nFigure 3.1 shows the three defining constraints represented in blue lines and the feasible space depicted by the orange shaded area. The objective function is indicated by the red dashed lines. It can be seen from the figure that the point in green circle gives the maximal objective value of 19.\n\n\n\n\n\nFigure 3.1: A simple LP example\n\n\n\n\nLet’s now use Google OR-Tools to model and solve this trivial problem.\n\n\n3.2.2 The Stigler Diet Problem"
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "6  Summary",
    "section": "",
    "text": "In summary, this book has no content whatsoever."
  }
]