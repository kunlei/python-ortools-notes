[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Python OR-tools Notes",
    "section": "",
    "text": "Preface"
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Introduction",
    "section": "",
    "text": "This book covers the usage of Google OR-Tools to solve optimization problems in Python. There are several major chapters in this book:\nIn Chapter 2, we explain the steps needed to setup OR-Tools in a Python environment.\nIn Chapter 3, we use an example to illustrate the modeling capability of OR-Tools to solve linear programming problems.\nIn Chapter 4, we go through the modeling techniques made available in OR-Tools."
  },
  {
    "objectID": "env-setup.html#install-homebrew",
    "href": "env-setup.html#install-homebrew",
    "title": "2  Environment Setup",
    "section": "2.1 Install Homebrew",
    "text": "2.1 Install Homebrew\nThe first tool we need is Homebrew, ‘the Missing Package Manager for macOS (or Linux)’, and it can be accessed at https://brew.sh/. To install Homebrew, just copy the command below and run it in the Terminal.\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\nWe can then use the brew --version command to check the installed version. On my system, it shows the info below.\n ~/ brew --version\nHomebrew 3.6.20\nHomebrew/homebrew-core (git revision 5f1582e4d55; last commit 2023-02-05)\nHomebrew/homebrew-cask (git revision fa3b8a669d; last commit 2023-02-05)"
  },
  {
    "objectID": "env-setup.html#install-anaconda",
    "href": "env-setup.html#install-anaconda",
    "title": "2  Environment Setup",
    "section": "2.2 Install Anaconda",
    "text": "2.2 Install Anaconda\nSince there are several Python versions available for our use and we may end up having multiple Python versions installed on our machine, it is important to use a consistent environment to work on our project in. Anaconda is a package and environment manager for Python and it provides easy-to-use tools to facilitate our data science needs. To install Anaconda, run the below command in the Terminal.\n ~/ brew install anaconda\nAfter the installation is done, we can use conda --version to verify whether it is available on our machine or not.\n ~/ conda --version\nconda 23.1.0"
  },
  {
    "objectID": "env-setup.html#create-a-conda-environment",
    "href": "env-setup.html#create-a-conda-environment",
    "title": "2  Environment Setup",
    "section": "2.3 Create a Conda Environment",
    "text": "2.3 Create a Conda Environment\nNow we will create a Conda environment named ‘ortools’. Execute the below command in the Terminal, which effectively creates the required environment with Python version 3.10.\n ~/ conda create -n ortools python=3.10\nRetrieving notices: ...working... done\nCollecting package metadata (current_repodata.json): done\nSolving environment: done\n\n## Package Plan ##\n\n  environment location: /opt/homebrew/anaconda3/envs/test\n\n  added / updated specs:\n    - python=3.10\n\n\nThe following packages will be downloaded:\n\n    package                    |            build\n    ---------------------------|-----------------\n    setuptools-67.4.0          |     pyhd8ed1ab_0         567 KB  conda-forge\n    ------------------------------------------------------------\n                                           Total:         567 KB\n\nThe following NEW packages will be INSTALLED:\n\n  bzip2              conda-forge/osx-arm64::bzip2-1.0.8-h3422bc3_4\n  ca-certificates    conda-forge/osx-arm64::ca-certificates-2022.12.7-h4653dfc_0\n  libffi             conda-forge/osx-arm64::libffi-3.4.2-h3422bc3_5\n  libsqlite          conda-forge/osx-arm64::libsqlite-3.40.0-h76d750c_0\n  libzlib            conda-forge/osx-arm64::libzlib-1.2.13-h03a7124_4\n  ncurses            conda-forge/osx-arm64::ncurses-6.3-h07bb92c_1\n  openssl            conda-forge/osx-arm64::openssl-3.0.8-h03a7124_0\n  pip                conda-forge/noarch::pip-23.0.1-pyhd8ed1ab_0\n  python             conda-forge/osx-arm64::python-3.10.9-h3ba56d0_0_cpython\n  readline           conda-forge/osx-arm64::readline-8.1.2-h46ed386_0\n  setuptools         conda-forge/noarch::setuptools-67.4.0-pyhd8ed1ab_0\n  tk                 conda-forge/osx-arm64::tk-8.6.12-he1e0b03_0\n  tzdata             conda-forge/noarch::tzdata-2022g-h191b570_0\n  wheel              conda-forge/noarch::wheel-0.38.4-pyhd8ed1ab_0\n  xz                 conda-forge/osx-arm64::xz-5.2.6-h57fd34a_0\n\n\nProceed ([y]/n)?\nType ‘y’ to proceed and Conda will create the environment for us. We can use cnoda env list to show all the created environments on our machine:\n ~/ conda env list\n# conda environments:\n#\nbase                     /opt/homebrew/anaconda3\nortools                   /opt/homebrew/anaconda3/envs/ortools\nNote that we need to manually activate an environemnt in order to use it: conda activate ortools. On my machine, the activated environment ortools will appear in the beginning of my prompt.\n ~/ conda activate ortools\n(ortools)  ~/"
  },
  {
    "objectID": "env-setup.html#install-google-or-tools",
    "href": "env-setup.html#install-google-or-tools",
    "title": "2  Environment Setup",
    "section": "2.4 Install Google OR-Tools",
    "text": "2.4 Install Google OR-Tools\nAs of this writing, the latest version of Google OR-Tools is 9.5.2237, and we can install it in our newly created environment using the command pip install ortools==9.5.2237. We can use conda list to verify whether it is available in our environment.\n(ortools)  ~/ conda list\n# packages in environment at /opt/homebrew/anaconda3/envs/ortools:\n#\n# Name                    Version                   Build  Channel\nabsl-py                   1.4.0                    pypi_0    pypi\nbzip2                     1.0.8                h3422bc3_4    conda-forge\nca-certificates           2022.12.7            h4653dfc_0    conda-forge\nlibffi                    3.4.2                h3422bc3_5    conda-forge\nlibsqlite                 3.40.0               h76d750c_0    conda-forge\nlibzlib                   1.2.13               h03a7124_4    conda-forge\nncurses                   6.3                  h07bb92c_1    conda-forge\nnumpy                     1.24.2                   pypi_0    pypi\nopenssl                   3.0.8                h03a7124_0    conda-forge\nortools                   9.5.2237                 pypi_0    pypi\npip                       23.0.1             pyhd8ed1ab_0    conda-forge\nprotobuf                  4.22.0                   pypi_0    pypi\npython                    3.10.9          h3ba56d0_0_cpython    conda-forge\nreadline                  8.1.2                h46ed386_0    conda-forge\nsetuptools                67.4.0             pyhd8ed1ab_0    conda-forge\ntk                        8.6.12               he1e0b03_0    conda-forge\ntzdata                    2022g                h191b570_0    conda-forge\nwheel                     0.38.4             pyhd8ed1ab_0    conda-forge\nxz                        5.2.6                h57fd34a_0    conda-forge\nNow we have Python and Google OR-Tools ready, we can start our next journey."
  },
  {
    "objectID": "linear-programming.html#modeling-capabilities",
    "href": "linear-programming.html#modeling-capabilities",
    "title": "3  Linear Programming",
    "section": "3.1 Modeling Capabilities",
    "text": "3.1 Modeling Capabilities\nThere are three components in a mathematical model, namely, decision varaibles, constraints and objective, for which we will go over in the following sections.\n\n3.1.1 Solver\nIn Google OR-Tools, a Solver instance must be created first so that variables, constraints and objective can be added to it. The Solver class is defined in the ortools.linear_solver.pywraplp module and it requires a solver id to instantiate an object. In the code snippet below, the required module is imported first and a solver object is created with GLOP, Google’s own optimization engine for solving linear programming problems. It is good practice to verify whether the desired solver is indeed created successfully or not.\n\nfrom ortools.linear_solver import pywraplp\n\nsolver = pywraplp.Solver.CreateSolver(\"GLOP\")\n\nif solver:\n    print(\"solver creation success!\")\nelse:\n    print(\"solver creation failure!\")\n\nsolver creation success!\n\n\n\n\n3.1.2 Decision Variables\nThe Solver class defines a number of ways to create decision variables:\n\nVar(lb, ub, integer, name)\nNumVar(lb, ub, name)\nIntVar(lb, ub, name)\nBoolVar(name)\n\n\nFunction Var()\n\nThe Var() method is the most flexible way to define variables, as it can be used to create numerical, integral and boolean variables. In the following code, a numerical variable named ‘var1’ is created with bound (0.0, 1.0). Note that the parameter integer is set to False in the call to function Var().\n\nvar1 = solver.Var(lb=0, ub=1.0, integer=False, name=\"var1\")\n\nWe could create an integer variable using the same function:\n\nvar2 = solver.Var(lb=0, ub=1.0, integer=True, name=\"var2\")\n\n\nFunction NumVar()\n\nvar1 could be creatd alternatively using the specialized function NumVar():\n\nvar1 = solver.NumVar(lb=0, ub=1.0, name=\"var1\")\n\n\nFunction IntVar()\n\nSimilarly, var2 could be created alternatively using the specialized function IntVar():\n\nvar2 = solver.IntVar(lb=0, ub=1.0, name=\"var2\")\n\n\nFunction BoolVar()\n\nA boolean variable could be created using the BoolVar() function:\n\nvar3 = solver.BoolVar(name=\"var3\")\n\n\n\n3.1.3 Constraints\nConstraints limit the solution space of an optimization problem, and there are two ways to define constraints in Google OR-Tools. In the first approach, we could use the Add() function to create a constraint and automatically add it to the model at the same time, as the below code snippet illustrates.\n\ncons1 = solver.Add(constraint=var1 + var2 <= 1, name=\"cons1\")\n\ntype(cons1)\n\nortools.linear_solver.pywraplp.Constraint\n\n\nNote that the Add() function returns an object of the Constraint class defined in the pywraplp module, as shown in the code output. It is a good practice to retain the reference of the newly created constraint, as we might want to query its information later on.\nThe second approach works in a slightly different way. It starts with an empty constraint, with potential lower bound and upper bounds provided, and add components of the constraint gradually. The code snippet below shows an example of adding a second constraint to the model. In this approach, we must retain the reference to the constraint, as it is needed to add decision variables to the constraint in following steps.\n\ncons2 = solver.Constraint(-solver.infinity(), 10.0, \"cons2\")\ncons2.SetCoefficient(var1, 2)\ncons2.SetCoefficient(var2, 3)\ncons2.SetCoefficient(var3, 4)\ntype(cons2)\n\nortools.linear_solver.pywraplp.Constraint\n\n\n\n\n3.1.4 Objective\nSimilar to constraints, there are two ways to define the objective in Google OR-Tools. In the first approach, we directly add an objective to the model by using the Maximize() or Minimize() function. Below is an example:\n\nsolver.Minimize(var1 + var2 + var3)\n\nNote that the function itself does not return a reference to the newly created objective function, but we could use a dedicated function to retrive it:\n\nobj = solver.Objective()\nprint(obj)\n\n<ortools.linear_solver.pywraplp.Objective; proxy of <Swig Object of type 'operations_research::MPObjective *' at 0x10f1e92c0> >\n\n\nIn the second approach, we build the objective incrementally, just as in the second approach of creating constraints. Specifically, we start with an empty objective function, and gradually add components to it. In the end, we specify the optimization sense - whether we want to maximize or minimnize the objective.\n\nobj = solver.Objective()\nobj.SetCoefficient(var1, 1.0)\nobj.SetCoefficient(var2, 1.0)\nobj.SetCoefficient(var3, 1.0)\nobj.SetMinimization()\nprint(obj)\n\n<ortools.linear_solver.pywraplp.Objective; proxy of <Swig Object of type 'operations_research::MPObjective *' at 0x10fc86670> >\n\n\n\n\n3.1.5 Objective and Constraint Expressions\nWhen we build constraints or objective functions, sometimes they comprise of complex expressions that we would like to build incrementally, possibly within loops. For example, we might have a mathematical expression of the form \\(expr = 2x_1 + 3x_2 + 4x_3 + x_4\\), which could be part of the objective function or any constraints. In this case, we can either use the aforementioned SetCoefficient() function to add each element of the expression to the constraint or objective, or we could build an expression first and add it once in the end. The code snippet below shows an example.\n\ninfinity = solver.Infinity()\nx1 = solver.NumVar(0, infinity, name=\"x1\")\nx2 = solver.NumVar(0, infinity, name=\"x2\")\nx3 = solver.NumVar(0, infinity, name=\"x3\")\nx4 = solver.NumVar(0, infinity, name=\"x4\")\n\nexpr = []\nexpr.append(2 * x1)\nexpr.append(3 * x2)\nexpr.append(4 * x3)\nexpr.append(x4)\n\nconstr = solver.Add(solver.Sum(expr) <= 10)\nprint(constr)\n\nsolver.Minimize(solver.Sum(expr))\n\n<ortools.linear_solver.pywraplp.Constraint; proxy of <Swig Object of type 'operations_research::MPConstraint *' at 0x10fcb3060> >\n\n\nOf course, it is not obvious here that the retitive calls to the append() method are any more convenient than the SetCoefficient() method. Let’s say that we have a slightly more complex expression of the form \\(\\sum_{0 \\le i < 4}w_i \\cdot x_i\\), now we could build the expression using a loop:\n\nw = [2, 3, 4, 1]\nx = [x1, x2, x3, x4]\nexpr = []\nfor i in range(4):\n    expr.append(w[i] * x[i])\n\nconstr = solver.Add(solver.Sum(expr) <= 10)\n\n\n\n3.1.6 Query the Model\nAfter we build the model, we can query it using some helper functions. For example, to get the total number of constraints, we use the NumVariables() function. In a similar fashion, we can retrieve the total number of constraints with the NumConstraints() function.\n\nnum_vars = solver.NumVariables()\nprint(f\"there are a total of {num_vars} variables in the model\")\n\nnum_constr = solver.NumConstraints()\nprint(f\"there are a total of {num_constr} constraints in the model\")\n\nthere are a total of 9 variables in the model\nthere are a total of 4 constraints in the model"
  },
  {
    "objectID": "linear-programming.html#applications",
    "href": "linear-programming.html#applications",
    "title": "3  Linear Programming",
    "section": "3.2 Applications",
    "text": "3.2 Applications\nIn this section, we use some examples to showcase the modeling capability of Google OR-Tools.\n\n3.2.1 Trivial Problem\nWe now consider an simple linear programming problem with two decision variables \\(x\\) and \\(y\\). The formal mathematical model is defined as below:\n\\[\\begin{align}\n\\text{max.} \\quad & x + 2y \\\\\n\\text{s.t.} \\quad & x + y \\le 10 \\\\\n& x >= 1 \\\\\n& y >= 1\n\\end{align}\\]\nFigure 3.1 shows the three defining constraints represented in blue lines and the feasible space depicted by the orange shaded area. The objective function is indicated by the red dashed lines. It can be seen from the figure that the point in green circle gives the maximal objective value of 19.\n\n\n\n\n\nFigure 3.1: A simple LP example\n\n\n\n\nLet’s now use Google OR-Tools to model and solve this problem. The code snippet below shows the complete program.\n\n# import Google OR-Tools library\nfrom ortools.linear_solver import pywraplp\n\n# create a solver\nsolver = pywraplp.Solver.CreateSolver(\"GLOP\")\n\n# create decision variables\nx = solver.NumVar(1.0, solver.Infinity(), \"x\")\ny = solver.NumVar(1.0, solver.Infinity(), \"y\")\n\n# create constraints\nconstr = solver.Add(x + y <= 10)\n\n# create objective\nsolver.Maximize(x + 2 * y)\n\n# solve the problem\nstatus = solver.Solve()\n\nif status == pywraplp.Solver.OPTIMAL or status == pywraplp.Solver.FEASIBLE:\n    print(f\"obj = {solver.Objective().Value()}\")\n    print(f\"x = {x.solution_value()}, reduced cost = {x.reduced_cost()}\")\n    print(f\"y = {y.solution_value()}, reduced cost = {y.reduced_cost()}\")\n    print(f\"constr dual value = {constr.dual_value()}\")\n\nobj = 19.0\nx = 1.0, reduced cost = -1.0\ny = 9.0, reduced cost = 0.0\nconstr dual value = 2.0\n\n\nWe can see from the output that the optimal solution is \\(x = 1.0\\) and \\(y = 9.0\\), and the optimal objective is 19.0. This can also be validated from Figure 3.1 that the optimal solution is exactly the green point that sits at the intersection of the three lines \\(x = 1\\), \\(x + y = 10\\) and \\(x + 2y = 19\\).\nFigure 3.1 also shows that the point (1, 1) should give us the minimal value of the objective function. To validate this, we can actually change the optimization sense of the objective function from maximization to minimization using the function SetOptimizationDirection(), as shown in the code below:\n\nsolver.Objective().SetOptimizationDirection(maximize=False)\n\nsolver.Solve()\n\nprint(f\"obj = {solver.Objective().Value()}\")\nprint(f\"x = {x.solution_value()}, reduced cost = {x.reduced_cost()}\")\nprint(f\"y = {y.solution_value()}, reduced cost = {y.reduced_cost()}\")\nprint(f\"constr dual value = {constr.dual_value()}\")\n\nobj = 3.0\nx = 1.0, reduced cost = 1.0\ny = 1.0, reduced cost = 2.0\nconstr dual value = 0.0\n\n\n\n\n3.2.2 Transportation Problem\nThe transportation problem involves moving goods from its sources \\(\\mathcal{S}\\) to destinations \\(\\mathcal{D}\\). Each source \\(s \\in \\mathcal{S}\\) has a total amount of goods \\(p_s\\) it could supply, and each destination \\(s \\in \\mathcal{D}\\) has a certain amount of demands \\(m_d\\). There is a transportation cost, denoted by \\(c_{sd}\\), to move one unit of goods from a source to a destination. The problem is to find the best set of goods to move from each source to each destination such that all the destination demands are met with the lowest transportation costs.\nTo model this transportation problem, we define the decision variable \\(x_{sd}\\) to be the amount of goods moving from source \\(s\\) to destinaiton \\(d\\). Then we could state the problem mathematically as below.\n\\[\\begin{align}\n\\text{min.} &\\quad \\sum_{s \\in \\mathcal{S}} \\sum_{d \\in \\mathcal{D}} c_{sd} x_{sd} \\label{tp-obj} \\\\\n\\text{s.t.} & \\quad \\sum_{d \\in \\mathcal{D}} x_{sd} = p_s, \\ \\forall s \\in \\mathcal{S} \\label{tp-cons1} \\\\\n& \\sum_{s \\in \\mathcal{S}} x_{sd} = m_d, \\ \\forall d \\in \\mathcal{D} \\label{tp-cons2} \\\\\n& x_{sd} \\geq 0, \\ \\forall s \\in \\mathcal{S}, d \\in \\mathcal{D} \\label{tp-cons3}\n\\end{align}\\]\nThe objective function \\(\\eqref{tp-obj}\\) aims to minimize the total transportation costs going from all sources to all destinations. Constraints \\(\\eqref{tp-cons1}\\) make sure that the sum of goods leaving a source node \\(s\\) must equal to its available supply \\(p_s\\). Constraints \\(\\eqref{tp-cons2}\\) require that the sum of goods gonig to a destination node \\(d\\) must equal to its demand \\(m_d\\). Constraints \\(\\eqref{tp-cons3}\\) state that the flow variables from sources to destination can only be nonnegative values.\nTable 3.1 shows an instance of the transportation problem in which there are four sources and five destinations. Entries in the last row give the corresponding demand from each destination, and the last column list the available supply at each source. The entries in the middle of the table show the transportation cost associated with moving from a specific source to a specific destination. For example, it costs $18 to move one unit of good from source S2 to D3.\n\n\n\n\nTable 3.1: A transportation problem\n\n\n\nD1\nD2\nD3\nD4\nD5\nSupply\n\n\n\n\nS1\n8\n5\n13\n12\n12\n58\n\n\nS2\n8\n7\n18\n6\n5\n55\n\n\nS3\n11\n12\n5\n11\n18\n64\n\n\nS4\n19\n13\n5\n10\n18\n71\n\n\nDemand\n44\n28\n36\n52\n88\n248\n\n\n\n\n\n\nWe show here two modeling flavors of using OR-Tools to solve this problem. In the first approach, decision variables are created using the NumVar() function, cnostraints are defined using the Add() function and the objective function is added using the Minimize() function. Note that both constraints and the objective function are generated with the help of of Sum() function that creates an expression.\n\nfrom ortools.linear_solver import pywraplp\n\n# gather data\nnum_sources = 4\nnum_destinations = 5\nsupplies = [58, 55, 64, 71]\ndemands = [44, 28, 36, 52, 88]\ncosts = [[8, 5, 13, 12, 12], \n        [8, 7, 18, 6, 5], \n        [11, 12, 5, 11, 18], \n        [19, 13, 5, 10, 18]]\n\n# create solver\nsolver = pywraplp.Solver.CreateSolver(\"GLOP\")\n\n# create decision variables\nvar_flow = []\nfor src_idx in range(num_sources):\n    vars = [\n        solver.NumVar(0, solver.Infinity(), \n                    name=f\"var_{src_idx}, {dest_idx}\")\n        for dest_idx in range(num_destinations)\n    ]\n    var_flow.append(vars)\n\n# create constraints\nfor src_idx in range(num_sources):\n    expr = [var_flow[src_idx][dest_idx] \n            for dest_idx in range(num_destinations)]\n    solver.Add(solver.Sum(expr) == supplies[src_idx])\n\nfor dest_idx in range(num_destinations):\n    expr = [var_flow[src_idx][dest_idx] \n            for src_idx in range(num_sources)]\n    solver.Add(solver.Sum(expr) == demands[dest_idx])\n\n# create objective function\nobj_expr = []\nfor src_idx in range(num_sources):\n    for dest_idx in range(num_destinations):\n        obj_expr.append(var_flow[src_idx][dest_idx] * costs[src_idx][dest_idx])\nsolver.Minimize(solver.Sum(obj_expr))\n\nstatus = solver.Solve()\n\nopt_flow = []\nif status == pywraplp.Solver.OPTIMAL:\n    print(f\"optimal obj = {solver.Objective().Value()}\")\n    for src_idx in range(num_sources):\n        opt_vals = [var_flow[src_idx][dest_idx].solution_value()\n                    for dest_idx in range(num_destinations)]\n        opt_flow.append(opt_vals)\n\noptimal obj = 2013.0\n\n\nThe optimal solution is shown in Table 3.2.\n\n\n\n\nTable 3.2: The optimal solution\n\n\n\nD1\nD2\nD3\nD4\nD5\nSupply\n\n\n\n\nS1\n0\n28\n0\n0\n30\n58\n\n\nS2\n0\n0\n0\n0\n55\n55\n\n\nS3\n44\n0\n20\n0\n0\n64\n\n\nS4\n0\n0\n16\n52\n3\n71\n\n\nDemand\n44\n28\n36\n52\n88\n248\n\n\n\n\n\n\nIn the second approach shown in the code snippet below, decision variables are created with the Var(integer=False) method instead of the NumVar() method. In addition, both constraints and the objective function are created using the SetCoefficient() method. In the case of constraints, a lower bound and upper bound are used to generated an empty constraint, and variables are then added to the constraint one by one with their corresponding coefficient. In the case of the objective function, an empty objective is first initialized and variables are then added to it sequentially. Note that the optimization sense is set using the SetMinimization() function.\n\nfrom ortools.linear_solver import pywraplp\n\n# gather data\nnum_sources = 4\nnum_destinations = 5\nsupplies = [58, 55, 64, 71]\ndemands = [44, 28, 36, 52, 88]\ncosts = [[8, 5, 13, 12, 12], \n        [8, 7, 18, 6, 5], \n        [11, 12, 5, 11, 18],\n        [19, 13, 5, 10, 18]]\n\n# create solver\nsolver = pywraplp.Solver.CreateSolver(\"GLOP\")\n\n# create decision variables\nvar_flow = []\nfor src_idx in range(num_sources):\n    vars = [\n        solver.Var(\n            0, solver.Infinity(), integer=False, \n            name=f\"var_{src_idx}, {dest_idx}\"\n        )\n        for dest_idx in range(num_destinations)\n    ]\n    var_flow.append(vars)\n\n# create constraints\nfor src_idx in range(num_sources):\n    constr = solver.Constraint(supplies[src_idx], supplies[src_idx])\n    for dest_idx in range(num_destinations):\n        constr.SetCoefficient(var_flow[src_idx][dest_idx], 1.0)\n\nfor dest_idx in range(num_destinations):\n    constr = solver.Constraint(demands[dest_idx], demands[dest_idx])\n    for src_idx in range(num_sources):\n        constr.SetCoefficient(var_flow[src_idx][dest_idx], 1.0)\n\n# create objective function\nobj = solver.Objective()\nfor src_idx in range(num_sources):\n    for dest_idx in range(num_destinations):\n        obj.SetCoefficient(var_flow[src_idx][dest_idx], costs[src_idx][dest_idx])\nobj.SetMinimization()\n\nstatus = solver.Solve()\n\nopt_flow = []\nif status == pywraplp.Solver.OPTIMAL:\n    print(f\"optimal obj = {solver.Objective().Value()}\")\n    for src_idx in range(num_sources):\n        opt_vals = [var_flow[src_idx][dest_idx].solution_value()\n                    for dest_idx in range(num_destinations)]\n        opt_flow.append(opt_vals)\n\noptimal obj = 2013.0\n\n\nTo validate the results, Table 3.3 shows the optimal solution produced by the second modeling approach, which is the same as in the previous approach.\n\n\n\n\nTable 3.3: The optimal solution\n\n\n\nD1\nD2\nD3\nD4\nD5\nSupply\n\n\n\n\nS1\n0\n28\n0\n0\n30\n58\n\n\nS2\n0\n0\n0\n0\n55\n55\n\n\nS3\n44\n0\n20\n0\n0\n64\n\n\nS4\n0\n0\n16\n52\n3\n71\n\n\nDemand\n44\n28\n36\n52\n88\n248\n\n\n\n\n\n\n\n\n3.2.3 Resource Allocation Problem\nThe resource allocation problems involves distributing scarce resources among alternative activities. The resources could be machines in a manufacturing facility, money available to spend, or CPU runtime. The activities could be anything that brings profit at the cost of consuming resources. The objective of this problem is therefore to allocate the available resources to activities such that the total profit is maximized.\nHere, we give a general resource allocation model devoid of any practical meanings. To this end, we define a few input parameters to this problem:\n\n\\(\\mathcal{A}\\): the set of candidate activities\n\\(\\mathcal{R}\\): the set of avaiable resources\n\\(p_a\\): the profit of performing one unit of activity \\(a \\in \\mathcal{A}\\)\n\\(c_{ar}\\): the amount of resource \\(r \\in \\mathcal{R}\\) required by one unit of activity \\(a \\in \\mathcal{A}\\)\n\\(b_r\\): the total amount of available quantities for resource \\(r \\in \\mathcal{R}\\)\n\nThe decision variable \\(x_a\\) represents the amount of activity \\(a \\in \\mathcal{A}\\) we select to perform, and the mathematical mode is defined below:\n\\[\\begin{align}\n\\text{max.} &\\quad \\sum_{a \\in \\mathcal{A}} p_a x_a \\label{ra-obj} \\\\\n\\text{s.t.} & \\quad \\sum_{a \\in \\mathcal{A}} c_{ar} \\leq b_r, \\ \\forall r \\in \\mathcal{R} \\label{ra-cons1} \\\\\n& x_a \\geq 0, \\ a \\in \\mathcal{A}\n\\end{align}\\]\nTable 3.4 shows an instance of the resource allocation problem, in which there are three type of resources and five candidate activities. The last row gives the profit of performing each unit of an activity, while the last column shows the available amount of resources. The remaining entries in the table refer to the resource consumption for each activity. For example, selecting one unit of activity 1 (A1) requires 90, 64 and 55 units of resources R1, R2 and R3, respectively.\n\n\n\n\nTable 3.4: A resource allocation problem\n\n\n\nA1\nA2\nA3\nA4\nA5\nAvailable\n\n\n\n\nR1\n90\n57\n51\n97\n67\n2001\n\n\nR2\n64\n58\n97\n56\n93\n2616\n\n\nR3\n55\n87\n77\n52\n51\n1691\n\n\nProfit\n1223\n1238\n1517\n1616\n1027\n\n\n\n\n\n\n\nIn the code snippet below, we use Google OR-Tools to solve this problem instance. Again, we start with initializing a solver object, follwed by creation of five decision variables, one for each activity. Both the constraints and objective function are created using the first modeling approach demonstrated previously. The optimal solution is outputed in the end.\n\nfrom ortools.linear_solver import pywraplp\n\n# gather instance data\nnum_resources = 3\nnum_activities = 5\nprofits = [1223, 1238, 1517, 1616, 1027]\navailable_resources = [2001, 2616, 1691]\ncosts = [[90, 57, 51, 97, 67],\n        [64, 58, 97, 56, 93],\n        [55, 87, 77, 52, 51]]\n\n# initialize a solver object\nsolver = pywraplp.Solver.CreateSolver(\"GLOP\")\n\ninfinity = solver.Infinity()\n# create decision variables\nvar_x = [solver.NumVar(0, infinity, name=f\"x_P{a}\") \n        for a in range(num_activities)]\n\n# create objective function\nsolver.Maximize(solver.Sum([profits[a] * var_x[a] \n                            for a in range(num_activities)]))\n\n# create constraints\nfor r_idx in range(num_resources):\n    cons = solver.Add(\n            solver.Sum([costs[r_idx][a_idx] * var_x[a_idx] \n                        for a_idx in range(num_activities)]) \n                      <= available_resources[r_idx])\n    \nstatus = solver.Solve()\nif status != pywraplp.Solver.OPTIMAL:\n    print(\"solver failure!\")\n\nprint(\"solve complete!\")\nopt_obj = solver.Objective().Value()\nprint(f\"optimal obj = {opt_obj:.2f}\")\n\nopt_sol = [var_x[a_idx].solution_value() \n           for a_idx in range(num_activities)]\nfor a_idx in range(num_activities):\n    print(f\"opt_x[{a_idx + 1}] = {opt_sol[a_idx]:.2f}\")\n\nsolve complete!\noptimal obj = 41645.23\nopt_x[1] = 0.00\nopt_x[2] = 0.00\nopt_x[3] = 12.45\nopt_x[4] = 14.08\nopt_x[5] = 0.00\n\n\n\n\n3.2.4 Workforce Planning Problem\nIn the workforce planning problem, there are a number of time periods and each period has a workforce requirement that must be satisfied. In addition, there are a set of available work patterns to assign workers to and each pattern cover one or more time periods. Note that assignment of workers to a particular pattern incurs a certain cost. The problem is then to identify the number of workers assigned to each pattern such that the total cost is minimized.\nTable 3.5 shows a contrived workforce planning problem instance. In this problem, there are a total of 10 time periods and there are four patterns available to assign workers to. The last row gives the work requirement in each time period and the last column shows the cost of assigning a worker to a pattern.\n\n\nTable 3.5: A workforce planning problem instance\n\n\nCoverage\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\nCost\n\n\n\n\nPattern 1\nx\nx\nx\nx\n\n\n\n\n\n\n10\n\n\nPattern 2\n\n\nx\nx\nx\n\n\n\n\n\n30\n\n\nPattern 3\n\n\n\nx\nx\nx\nx\n\n\n\n20\n\n\nPattern 4\n\n\n\n\n\n\nx\nx\nx\nx\n40\n\n\nRequirement\n3\n4\n3\n1\n5\n7\n2\n4\n5\n1\n\n\n\n\n\nTo model this problem, we use \\(\\mathcal{T}\\) and \\(\\mathcal{P}\\) to denote the set of time periods and patterns, respectively. The parameter \\(m_{pt}\\) indicates whether a pattern \\(p \\in \\mathcal{P}\\) covers a certain time period \\(t \\in \\mathcal{T}\\). The work requirement of each time period and the cost of assigning a pattern is represented as \\(r_t\\) and \\(c_p\\), respectively.\nNow we are ready to define the variable \\(x_p\\) as the number of workers that are assigned to pattern \\(p\\), and the mathematical model can be stated as below.\n\\[\\begin{align}\n\\text{min.} & \\quad \\sum_{p \\in \\mathcal{P}} c_p x_p \\\\\n\\text{s.t.} & \\quad \\sum_{p \\in \\mathcal{P}} m_{pt} x_p \\geq r_t, \\ \\forall t \\in \\mathcal{T} \\\\\n&\\quad x_p \\geq 0, \\ \\forall p \\in \\mathcal{P}\n\\end{align}\\]\nThe code snippet below gives the Python code to solve this problem using Google OR-Tools.\n\nfrom ortools.linear_solver import pywraplp\n\n# import instance data\nnum_periods = 10\nnum_patterns = 4\nrequirements = [3, 4, 3, 1, 5, 7, 2, 4, 5, 1]\ncosts = [10, 30, 20, 40]\npatterns = [set([1, 2, 3, 4]),\n            set([3, 4, 5]),\n            set([4, 5, 6, 7]),\n            set([7, 8, 9, 10])]\n\n# create solver object\nsolver = pywraplp.Solver.CreateSolver('GLOP')\n\ninfinity = solver.Infinity()\n# create decision variables\nvar_p = [solver.NumVar(0, infinity, name=f\"x_{p}\")\n         for p in range(num_patterns)]\n\n# create objective function\nsolver.Minimize(\n    solver.Sum([costs[p] * var_p[p] \n                for p in range(num_patterns)])\n)\n\n# create constraints\nfor t in range(num_periods):   \n    solver.Add(\n        solver.Sum([var_p[p] \n                    for p in range(num_patterns) \n                    if (t + 1) in patterns[p]])\n        >= requirements[t])\n\n# solve the problem and retrieve optimal solution\nstatus = solver.Solve()\nif status == pywraplp.Solver.OPTIMAL:\n    print(f\"obj = {solver.Objective().Value()}\")\n    for p in range(num_patterns):\n        print(f\"var_{p + 1} = {var_p[p].solution_value()}\")\n\nobj = 380.0\nvar_1 = 4.0\nvar_2 = 0.0\nvar_3 = 7.0\nvar_4 = 5.0\n\n\n\n\n3.2.5 Sudoku Problem\nIn a Sudoku problem, a grid of 9x9 is given and the task is to fill all the cells with numbers 1-9. At the beginning, some of the cells are already gilled with numbers and the requirements are that the remaining cells must be filled so that each row, each column, and each of the 9 3x3 sub-grids contain all the numbers from 1 to 9 without any repitition. The difficulty level of Sudoku problems depends on the number of cells that are already filled in the grid at the beginning of the game. Problems with fewer initial digits filled are considered more challenging. Figure 3.2 illustrate a sample Sudoku problem.\n\n\n\n\n\nFigure 3.2: A Sudoku problem\n\n\n\n\nTo model this problem, we define set \\(S = (1, 2, 3, 4, 5, 6, 7, 8, 9)\\) and use \\(i, j \\in S\\) to index the row and column respectively. In addition, we use \\(M=\\{(i, j, k) | i, j, k \\in S\\}\\) to represent all the known numbers in the grid.\nTo formulate this problem, we define 9 binary variables for each cell in the 9x9 grid. Each of the 9 variables corresponds to one of the numbers in set \\(S\\). Formally, \\(x_{ijk}\\) represents whether the value \\(k\\) shows up in cell \\((i, j)\\) of the grid. Note that \\(i, j, k \\in S\\). The mathematical formulation can be stated as below.\n\\[\\begin{align}\n\\text{min.} &\\quad 0 \\label{sudoku-obj} \\\\\n\\text{s.t.} &\\quad \\sum_{j \\in S}x_{ijk} = 1, \\ \\forall i, k \\in S \\label{sudoku-cons1} \\\\\n&\\quad \\sum_{i \\in S} x_{ijk} = 1, \\ \\forall j, k \\in S \\label{sudoku-cons2} \\\\\n&\\quad \\sum_{k \\in S} x_{ijk} = 1, \\ \\forall i, j \\in S \\label{sudoku-cons3} \\\\\n&\\quad \\sum_{(i - 1) \\times 3 + 1}^{(i - 1) \\times 3 + 3} \\sum_{(j - 1) \\times 3 + 1}^{(j - 1) \\times 3 + 3} x_{ijk} = 1, \\ \\forall i, j \\in \\{1, 2, 3\\}, k \\in S \\label{sudoku-cons4}\\\\\n&\\quad x_{ijk} = 1, \\ \\forall (i, j, k) \\in M \\label{sudoku-cons5}\\\\\n&\\quad x_{ijk} \\in \\{0, 1\\}, \\ \\forall i, j,k \\in S\n\\end{align}\\]\nSince no feasible soution is more preferable than another, we use a constant value as the objective function, meaning any feasible soution is an optimal solution to this problem. Constraints \\(\\eqref{sudoku-cons1}\\) require that the number \\(k \\in S\\) shows up once and only once in each row of the grid. Similarly, \\(\\eqref{sudoku-cons2}\\) make sure that the number \\(k \\in S\\) shows up once and only once in each column of the grid. For each cell in the grid, only one of the numbers in \\(S\\) can appear, which is guaranteed by constraints \\(\\eqref{sudoku-cons3}\\). Constraints \\(\\eqref{sudoku-cons4}\\) ensure that the numbers in set \\(S\\) show up once and only once in each of the sub-grids. Constraints \\(\\eqref{sudoku-cons5}\\) make sure that the existing numbers in the grid stay the same in the optimal solution.\nWe can then solve the problem using Google OR-Tools and the code snippet is given below.\n\nimport numpy as np\nfrom ortools.linear_solver import pywraplp\n\n# import data\ngrid_size = 9\nsubgrid_size = 3\nM = [[(1, 3, 6)],\n     [(2, 3, 3)],\n     [(3, 1, 5), (3, 7, 3), (3, 8, 7), (3, 9, 9)],\n     [(4, 1, 2), (4, 2, 1), (4, 3, 4), (4, 4, 0)],\n     [(5, 6, 5), (5, 7, 4)],\n     [(6, 1, 3), (6, 2, 5), (6, 3, 8), (6, 7, 9)],\n     [(7, 1, 4), (7, 9, 2)],\n     [(8, 3, 5)],\n     [(9, 1, 8), (9, 2, 2)]]\n\n# create solver\nsolver = pywraplp.Solver.CreateSolver(\"SCIP\")\n\n# # create decision variables\nsudoku_vars = np.empty((grid_size, grid_size, grid_size), dtype=object)\nfor row in range(grid_size):\n     for col in range(grid_size):\n          for num in range(grid_size):\n               sudoku_vars[row][col][num] = solver.Var(0, \n                                   1, \n                                   integer=True, \n                                   name=f\"x_{row, col, num}\")\n\n# create objective\nsolver.Minimize(0)\n\n# create constraints\nfor row in range(grid_size):\n     for num in range(grid_size):\n          solver.Add(\n               solver.Sum([sudoku_vars[row][col][num] \n                              for col in range(grid_size)\n                         ]) == 1\n                    )\n\nfor col in range(grid_size):\n     for num in range(grid_size):\n          solver.Add(\n               solver.Sum([sudoku_vars[row][col][num] \n                              for row in range(grid_size)\n                         ]) == 1\n                    )\n          \nfor row in range(grid_size):\n     for col in range(grid_size):\n          solver.Add(\n               solver.Sum([sudoku_vars[row][col][num] \n                              for num in range(grid_size)\n                         ]) == 1\n                    )\n          \nfor row in range(grid_size):\n     known_values = M[row]\n     for value in known_values:\n          row, col, num = value\n          solver.Add(\n               sudoku_vars[row - 1][col - 1][num - 1] == 1\n          )\n\n# solve the problem\nstatus = solver.Solve()\n\nif status == pywraplp.Solver.OPTIMAL or status == pywraplp.Solver.FEASIBLE:\n     sudoku_sol = np.zeros((grid_size, grid_size), dtype=int)\n     for row in range(grid_size):\n          for col in range(grid_size):\n               for num in range(grid_size):\n                    if sudoku_vars[row][col][num].solution_value() == 1:\n                         sudoku_sol[row][col] = num + 1\n\nFigure 3.3 shows one solution to the example problem.\n\n\n\n\n\nFigure 3.3: One solution to the Sudoku problem"
  },
  {
    "objectID": "integer-programming.html#modeling-capabilities",
    "href": "integer-programming.html#modeling-capabilities",
    "title": "4  Integer Programming",
    "section": "4.1 Modeling Capabilities",
    "text": "4.1 Modeling Capabilities\nWhen modeling integer programs, there are two main tasks that require attention. The first is declaring integer variables, and the second is selecting a solver that is capable of solving integer programs.\n\n4.1.1 Declaring Integer Variables\nAs reviewed in Chapter 3, Google OR-Tools provides two options to create integer variables:\n\nThe Var(lb, ub, integer: bool, name) function\nThe IntVar(lb, ub, name) function\nThe Variable.SetInteger(integer: bool) function\n\nIn the code snippet below, we create three integer variables using all the aforementioned approaches:\n\nfrom ortools.linear_solver import pywraplp\n\nsolver = pywraplp.Solver.CreateSolver('SCIP')\n\n# option 1\nx = solver.Var(lb=0, ub=10, integer=True, name='x')\n\n# option 2\ny = solver.IntVar(lb=10, ub=20, name='y')\n\n# option 3\nz = solver.NumVar(lb=0, ub=5.5, name='z')\nz.SetInteger(integer=True)\n\nWe can verify the types of variables \\(x, y, z\\):\n\nprint(f\"x is integer? {x.integer()}\")\nprint(f\"y is integer? {y.integer()}\")\nprint(f\"z is integer? {z.integer()}\")\n\nx is integer? True\ny is integer? True\nz is integer? True\n\n\n\n\n4.1.2 Selecting an Integer Solver\nThere are several solvers available for solving integer programs, and some options include:\n\nCBC_MIXED_INTEGER_PROGRAMMING or CBC\nBOP_INTEGER_PROGRAMMING or BOP\nSAT_INTEGER_PROGRAMMING or SAT or CP_SAT\nSCIP_MIXED_INTEGER_PROGRAMMING or SCIP\nGUROBI_MIXED_INTEGER_PROGRAMMING or GUROBI or GUROBI_MIP\nCPLEX_MIXED_INTEGER_PROGRAMMING or CPLEX or CPLEX_MIP\nXPRESS_MIXED_INTEGER_PROGRAMMING or XPRESS or XPRESS_MIP\nGLPK_MIXED_INTEGER_PROGRAMMING or GLPK or GLPK_MIP\n\nIt’s important to note that some of these solvers are open-source, while others require a commercial license. The code block above demonstrates how to create an instance of an integer solver. To do so, we simply need to specify the name of the solver in the Solver.CreateSolver() function.\n\nsolver = pywraplp.Solver.CreateSolver('CBC')"
  },
  {
    "objectID": "integer-programming.html#applications",
    "href": "integer-programming.html#applications",
    "title": "4  Integer Programming",
    "section": "4.2 Applications",
    "text": "4.2 Applications\nIn this section, we use Google OR-Tools to solve some of the classical integer programming problems.\n\n4.2.1 Job Shop Scheduling Problem\nIn the job shop scheduling problem (JSSP), there are a set of \\(n\\) jobs \\(\\mathcal{J}\\) and a set of \\(m\\) machines \\(\\mathcal{M}\\), and each job \\(j \\in \\mathcal{J}\\) has a list of operations, given by \\((o_1^j, \\cdots, o_h^j, \\cdots, o_m^j)\\), that must be carried on the machines. The order of operations in the list also indicates the processing order of the job, and \\(o_h^j\\) represents the \\(h\\)-th operation of the job \\(j\\). In addition, the processing time of job \\(j\\) on machine \\(i\\), denoted by \\(p_{ij}\\), is known in advance and is a non-negative integer. At any moment of time, each machine can only process at most one job and no preemption is allowed which means that a job must completes its processing on a machine once it starts on that machine. The objective is to find a processing schedule of the jobs on the machines such that the makespan, the completion time of the last operation of any job, is minimized.\nTo test the modeling of JSSP, we use a benchmarking instance from the OR-Library (Beasley (1990)), shown in the box below. The two numbers in the first line represent the number of jobs and the number of machines, respectively. Each remaining line contains the operations, processing machine and processing time, for each job. Note that the machines are numbered starting from 0.\n\n# Instance ft06 from OR-Library\n# 6 6   \n# 2 1   0   3   1   6   3   7   5   3   4   6\n# 1 8   2   5   4   10  5   10  0   10  3   4\n# 2 5   3   4   5   8   0   9   1   1   4   7\n# 1 5   0   5   2   5   3   3   4   8   5   9\n# 2 9   1   3   4   5   5   4   0   3   3   1\n# 1 3   3   3   5   9   0   10  4   4   2   1\n\nSuppose this instance data is saved in a file named ft06.txt and the code below defines an utility function to read and parse the instance for later use.\n\ndef read_jssp_instance(filename: str):\n    with open(filename) as f:\n        num_jobs, num_machines = [int(x) for x in next(f).split()]\n        operations = []\n        processing_times = {}\n        job_idx = 0\n        for line in f:\n            info = [int(x) for x in line.split()]\n            arr = [info[2 * m] for m in range(num_machines)]\n            times = {info[2 * m]: info[2 * m + 1]\n                    for m in range(num_machines)}\n            operations.append(arr)\n            processing_times[job_idx] = times\n            job_idx += 1\n    return num_jobs, num_machines, operations, processing_times\n\nWe present here three classical formulations of the JSSP from the literature and implement them using Google OR-Tools.\n\nDisjunctive model\n\nThis model is taken from Ku and Beck (2016) and Manne (1960). The decision variables are defined as follows:\n\n\\(x_{ij}\\): the processing starting time of job \\(j\\) on machine \\(i\\)\n\\(z_{ijk}\\): a binary variable that equals 1 if job \\(j\\) precedes job \\(k\\) on machine \\(i\\)\n\nThe disjunctive model can then be stated as below.\n\\[\\begin{align}\n    \\text{min.} &\\quad C_{max} \\label{jsp-dis-obj}\\\\\n    \\text{s.t.} &\\quad x_{ij} \\geq 0, \\ \\forall j \\in \\mathcal{J}, i \\in \\mathcal{M} \\label{jsp-dis-cons1}\\\\\n    &\\quad x_{o_h^j, j} \\geq x_{o_{h-1}^j, j} + p_{o_{h-1}^j, j}, \\ \\forall j \\in \\mathcal{J}, h = 2, \\cdots, m \\label{jsp-dis-cons2}\\\\\n    &\\quad x_{ij} \\geq x_{ik} + p_{ik} - V \\cdot z_{ijk}, \\ \\forall i \\in \\mathcal{M}, j, k \\in \\mathcal{J}, j < k  \\label{jsp-dis-cons3}\\\\\n    &\\quad x_{ik} \\geq x_{ij} + p_{ij} - V \\cdot (1 - z_{ijk}), \\ \\forall i \\in \\mathcal{M}, j, k \\in \\mathcal{J}, j < k  \\label{jsp-dis-cons4}\\\\\n    &\\quad C_{max} \\geq x_{o_m^j, j} + p_{o_m^j, j}, \\ \\forall j \\in \\mathcal{J}  \\label{jsp-dis-cons5}\\\\\n    &\\quad z_{ijk} \\in \\{0, 1\\}, \\ \\forall i \\in \\mathcal{M}, j, k \\in \\mathcal{J} \\label{jsp-dis-cons6}\n\\end{align}\\]\nThe objective \\(\\eqref{jsp-dis-obj}\\) aims to minimize the maximal completion time of any job \\(j \\in \\mathcal{J}\\). Constraints \\(\\eqref{jsp-dis-cons1}\\) require that all the job processing starting time must not be negative values. Constraints \\(\\eqref{jsp-dis-cons2}\\) enforce the sequencing order among operations for every job, which state that the \\(h\\)-th operation of job \\(j\\), \\(o_h^j\\), cannot start unless its preceeding operation \\(o_{h - 1}^j\\) finishes. Constraints \\(\\eqref{jsp-dis-cons3}\\) and \\(\\eqref{jsp-dis-cons4}\\) together make sure that at most one job can be processed on a machine at any time. To be specific, in case of job \\(j\\) preceding job \\(k\\) on machine \\(i\\), \\(z_{ijk}\\) takes the value of 1 and constraints \\(\\eqref{jsp-dis-cons4}\\) ensure that job \\(k\\) won’t start processing on machine \\(i\\) unless job \\(i\\) completes processing; Otherwise, \\(z_{ijk}\\) takes the value of 0 and constraints \\(\\eqref{jsp-dis-cons3}\\) require that job \\(j\\) starts processing after job \\(k\\). Note that both constraints are needed when we require \\(j < k\\); Otherwise, only one of them is needed if we create a constraint for every pair of \\(j\\) and \\(k\\) on a machine. Constraints \\(\\eqref{jsp-dis-cons5}\\) derive \\(C_{max}\\) across all jobs. The last constraints \\(\\eqref{jsp-dis-cons6}\\) state the variable type of \\(z_{ijk}\\).\nThe disjunctive formulation code is presented entirely in the following lines. The data related to the specific case are read between lines 5 to 8, and a solver object is created in line 11. The variable \\(x_{ij}\\) is introduced in lines 16 to 23, followed by the introduction of variable \\(z_{ijk}\\) in lines 25 to 34. The variable \\(C_{max}\\) is defined in lines 36 to 38. The objective of the model is set in line 41, and the constraints are established in lines 44 to 80. The instance is solved, and the optimal solution is obtained from lines 82 to 93.\n\nfrom typing import List, Dict\nfrom ortools.linear_solver import pywraplp\n\n# read and parse the data\nfilename = './data/jssp/ft06.txt'\nnum_jobs, num_machines, \\\noperations, processing_times = \\\n    read_jssp_instance(filename)\n\n# create solver\nsolver = pywraplp.Solver.CreateSolver('SCIP')\n\n# create variables\ninfinity = solver.Infinity()\nvar_time: List[List] = []\nfor machine in range(num_machines):\n    arr = [\n        solver.NumVar(0, \n                    infinity, \n                    name=f'x_{machine, job}') \n        for job in range(num_jobs)\n        ]\n    var_time.append(arr)\n\nvar_prec: Dict = []\nfor machine in range(num_machines):\n    mac_dict = {}\n    for job_j in range(num_jobs - 1):\n        for job_k in range(job_j + 1, num_jobs):\n            mac_dict[(job_j, job_k)] = \\\n            solver.BoolVar(\n                name=f'z_{machine, job_j, job_k}'\n            )\n    var_prec.append(mac_dict)\n\nvar_makespan = solver.NumVar(0, \n                            infinity, \n                            name='C_max')\n\n# create objective\nsolver.Minimize(var_makespan)\n\n# create constraints\nfor job, job_operations in enumerate(operations):\n    for h in range(1, num_machines):\n        curr_machine = job_operations[h]\n        prev_machine = job_operations[h - 1]\n        prev_time = processing_times[job][prev_machine]\n        solver.Add(\n            var_time[curr_machine][job] >= \n                var_time[prev_machine][job] + \n                prev_time\n            )\n\nV = 0\nfor job in processing_times:\n    V += sum(processing_times[job].values())\nfor machine in range(num_machines):\n    for job_j in range(num_jobs - 1):\n        for job_k in range(job_j + 1, num_jobs):\n            solver.Add(\n                var_time[machine][job_j] >= \n                var_time[machine][job_k] +\n                processing_times[job_k][machine] - \n                V * var_prec[machine][(job_j, job_k)]\n            )\n            solver.Add(\n                var_time[machine][job_k] >= \n                var_time[machine][job_j] +\n                processing_times[job_j][machine] - \n                V * (1 - var_prec[machine][(job_j, job_k)])\n            )\n            \nfor job in range(num_jobs):\n    last_oper_machine = operations[job][-1]\n    solver.Add(\n        var_makespan >= \n        var_time[last_oper_machine][job] + \n        processing_times[job][last_oper_machine]\n    )\n\nstatus = solver.Solve()\n\nif status == solver.OPTIMAL:\n    print(f\"min. makespan = {solver.Objective().Value():.2f}\")\n    \n    opt_time = []\n    for machine in range(num_machines):\n        arr = [\n            int(var_time[machine][job].solution_value()) \n            for job in range(num_jobs)\n        ]\n        opt_time.append(arr)\n\nmin. makespan = 55.00\n\n\nThe output of the model indicates that the lowest possible time needed to complete all tasks in this instance is 55. To illustrate the most efficient solution, we have created a function called show_schedule() that displays a Gantt chart of the tasks needed to process all jobs. Figure 4.1 displays the optimal solution for this instance.\n\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\n\ndef show_schedule(num_jobs, operations, processing_times, opt_time):\n    colors = mpl.colormaps[\"Set1\"].colors\n\n    fig, ax = plt.subplots(figsize=[7, 3], dpi=100)\n\n    for idx, job in enumerate(range(num_jobs)):\n        machines = operations[job]\n        job_start_times = [opt_time[machine][job] \n                            for machine in machines]\n        job_processing_times = [processing_times[job][machine] \n                                for machine in operations[job]]\n        \n        if idx >= len(colors):\n            idx = idx % len(colors)\n        color = colors[idx]\n\n        bars = ax.barh(machines, \n                width=job_processing_times, \n                left=job_start_times, \n                label=f'Job {job + 1}', \n                color=color)\n        \n        ax.bar_label(bars, \n                    fmt=f'{job + 1}', \n                    label_type='center')\n        \n    ax.set_yticks(machines)\n    ax.set_xlabel(\"Time\")\n    ax.set_ylabel(\"Machine\")\n    fig.tight_layout()\n    plt.show()\n    \nshow_schedule(num_jobs, operations, processing_times, opt_time)\n\n\n\n\nFigure 4.1: Optimal solution of the ft06 instance using the disjunctive formulation\n\n\n\n\n\nTime-indexed model\n\nThe time-indexed formulation, proposed by Kondili, Pantelides, and Sargent (1988) and Ku and Beck (2016), involves the use of a binary variable \\(x_{ijt}\\) that takes the value of 1 if job \\(j\\) starts at time \\(t\\) on machine \\(i\\). The model can be expressed as follows.\n\\[\\begin{align}\n\\text{min.} &\\quad C_{max} \\label{jsp-time-obj}\\\\\n\\text{s.t.} &\\quad \\sum_{t \\in H} x_{ijt} = 1, \\ \\forall j \\in \\mathcal{J}, i \\in \\mathcal{M} \\label{jsp-time-cons1} \\\\\n&\\quad \\sum_{t \\in H} (t + p_{ij}) \\cdot x_{ijt} \\leq C_{max}, \\ \\forall j \\in \\mathcal{J}, i \\in \\mathcal{M} \\label{jsp-time-cons2} \\\\\n&\\quad \\sum_{j \\in \\mathcal{J}} \\sum_{t' \\in T_{ijt}} x_{ijt'} \\leq 1, \\ \\forall i \\in \\mathcal{M}, t \\in H, T_{ijt} = \\{t - p_{ij} + 1, \\cdots, t\\} \\label{jsp-time-cons3} \\\\\n&\\quad \\sum_{t \\in H} (t + p_{o_{h - 1}^j}, j) \\cdot x_{o_{h - 1}^j, jt} \\leq \\sum_{t \\in H} t \\cdot x_{o_h^j, jt}, \\ \\forall j \\in \\mathcal{J}, h = 2, \\cdots, m \\label{jsp-time-cons4} \\\\\n&\\quad x_{ijt} \\in \\{0, 1\\}, \\ \\forall j \\in \\mathcal{J}, i \\in \\mathcal{M}, t \\in H \\label{jsp-time-cons5}\n\\end{align}\\]\nIn this formulation, the first set of constraints, referred to as \\(\\eqref{jsp-time-cons1}\\), state that each job \\(j\\) must start at one specific time within the scheduling horizon \\(H\\), which is determined as the sum of processing times for all jobs - \\(H = \\sum_{i \\in \\mathcal{I}, j \\in \\mathcal{J}} p_{ij}\\). Constraints \\(\\eqref{jsp-time-cons2}\\) are used to calculate the value of \\(C_{max}\\), while constraints \\(\\eqref{jsp-time-cons3}\\) ensure that only one job can be processed by a machine at any given time. It’s important to note that a job will remain on a machine for its full processing time and cannot be interrupted. Constraints \\(\\eqref{jsp-time-cons4}\\) make sure that the order of processing jobs is followed, and constraints \\(\\eqref{jsp-time-cons5}\\) define the variable types used in the formulation.\nThe following code provides a program that uses the time-indexed formulation to solve the ft06 instance, with the value of \\(H\\) being the sum of all job processing times plus one. The two variables, \\(x_{ijt}\\) and \\(C_{max}\\), are created in lines 18 - 27. The constraints are created in lines 33 - 57. The optimal solution is retrieved in lines 61 - 71. It can be seen from the output that the same optimal objective, 55, is obtained using this formulation.\n\nfrom typing import List, Dict\nfrom ortools.linear_solver import pywraplp\nimport numpy as np\n\n# read and parse the data\nfilename = './data/jssp/ft06.txt'\nnum_jobs, num_machines, \\\noperations, processing_times = \\\n    read_jssp_instance(filename)\n    \n# create solver\nsolver = pywraplp.Solver.CreateSolver('SCIP')\n\n# create variables\nH = 1\nfor job in processing_times:\n    H += sum(processing_times[job].values())\nvar_x = np.empty((num_machines, num_jobs, H), dtype=object)\nfor machine in range(num_machines):\n    for job in range(num_jobs):\n        for t in range(H):\n            var_x[machine][job][t] = solver.BoolVar(name=f'x_{machine, job, t}')\n\ninfinity = solver.Infinity()\nvar_makespan = solver.NumVar(0, \n                            infinity, \n                            name='C_max')\n\n# create objective\nsolver.Minimize(var_makespan)\n\n# create constraints\nfor machine in range(num_machines):\n    for job in range(num_jobs):\n        solver.Add(solver.Sum([var_x[machine][job][t] for t in range(H)]) == 1)\n        \nfor machine in range(num_machines):\n    for job in range(num_jobs):\n        arr = [var_x[machine][job][t] * (t + processing_times[job][machine]) for t in range(H)]\n        solver.Add(solver.Sum(arr) <= var_makespan)\n        \nfor machine in range(num_machines):\n    for t in range(H):\n        arr = [var_x[machine][job][tt]\n                    for job in range(num_jobs)\n                    for tt in range(t - processing_times[job][machine] + 1, t + 1)]\n        solver.Add(solver.Sum(arr) <= 1)\n\nfor job in range(num_jobs):\n    for oper in range(1, num_machines):\n        prev_machine = operations[job][oper - 1]\n        curr_machine = operations[job][oper]\n        expr_prev = [(t + processing_times[job][prev_machine]) * var_x[prev_machine][job][t] \n                    for t in range(H)]\n        expr_curr = [t * var_x[curr_machine][job][t]\n                    for t in range(H)]\n        solver.Add(solver.Sum(expr_prev) <= solver.Sum(expr_curr))\n\nstatus = solver.Solve()\n\nif status == solver.OPTIMAL:\n    print(f\"min. makespan = {solver.Objective().Value():.2f}\")\n    \n    opt_time = []\n    for machine in range(num_machines):\n        arr = []\n        for job in range(num_jobs):\n            for t in range(t):\n                if int(var_x[machine][job][t].solution_value()) == 1:\n                    arr.append(t)\n        opt_time.append(arr)\n\nmin. makespan = 55.00\n\n\nThe optimal solution can be seen in Figure 4.2. Even though both formulations achieve the same optimal objective value, there are some minor discrepancies between the optimal solutions. For instance, in Figure 4.1, there is a gap after job 4 completes processing on machine 3, which is not present in Figure 4.2.\n\nshow_schedule(num_jobs, operations, processing_times, opt_time)\n\n\n\n\nFigure 4.2: Optimal solution of the ft06 instance using the time-indexed formulation\n\n\n\n\n\nRank-based model\n\nThe rank-based model is due to Wagner (1959) and taken from Ku and Beck (2016). There are three decision variables in this formulation:\n\n\\(x_{ijk}\\): a binary variable that equals 1 if job \\(j\\) is scheduled at the \\(k\\)-th position on machine \\(i\\)\n\\(h_{ik}\\): a numerical variable that represents the start time of job at the \\(k\\)-th position of machine \\(i\\).\n\\(C_{max}\\): the makespan to be minimized\n\n\\[\\begin{align}\n\\text{min.} &\\quad C_{max} \\label{jsp-rank-obj} \\\\\n\\text{s.t.} &\\quad \\sum_{j \\in \\mathcal{J}} x_{ijk} = 1, \\ \\forall i \\in \\mathcal{M}, k = 1, \\cdots, n \\label{jsp-rank-cons1}\n\\end{align}\\]\n\n\n\n\nBeasley, John E. 1990. “OR-Library: Distributing Test Problems by Electronic Mail.” Journal of the Operational Research Society 41 (11): 1069–72.\n\n\nKondili, E, CC Pantelides, and R WH Sargent. 1988. “A General Algorithm for Scheduling Batch Operations.” In. Barton, ACT. https://search.informit.org/doi/10.3316/informit.394925233030714.\n\n\nKu, Wen-Yang, and J. Christopher Beck. 2016. “Mixed Integer Programming Models for Job Shop Scheduling: A Computational Analysis.” Computers & Operations Research 73 (September): 165–73. https://doi.org/10.1016/j.cor.2016.04.006.\n\n\nManne, Alan S. 1960. “On the Job-Shop Scheduling Problem.” Operations Research 8 (2): 219–23. https://doi.org/10.1287/opre.8.2.219.\n\n\nWagner, Harvey M. 1959. “An Integer Linear-Programming Model for Machine Scheduling.” Naval Research Logistics Quarterly 6 (2): 131–40. https://doi.org/10.1002/nav.3800060205."
  },
  {
    "objectID": "column-generation.html",
    "href": "column-generation.html",
    "title": "5  Column Generation",
    "section": "",
    "text": "Column generation is a technique used in linear programming to solve problems with a large number of variables. Some classical/typical applications of column generation include:\nTransportation and distribution problems: Column generation can be used to optimize transportation and distribution networks by determining the most efficient routes for goods and services.\nCrew scheduling: Column generation is useful in determining optimal crew scheduling for airlines, railways, and other transportation companies.\nCutting stock problems: In the manufacturing industry, column generation can be used to optimize cutting stock problems by finding the best way to cut raw materials into smaller pieces to minimize waste.\nNetwork design: Column generation can be applied to network design problems, such as determining the optimal location of facilities in a supply chain network.\nVehicle routing: Column generation can be used to optimize vehicle routing problems, such as determining the best routes for delivery trucks or garbage trucks.\nResource allocation: Column generation can also be applied to resource allocation problems, such as scheduling employees or assigning tasks to machines in a production facility.\nOverall, column generation is a powerful technique that can be applied to a wide range of optimization problems."
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "6  Summary",
    "section": "",
    "text": "In summary, this book has no content whatsoever."
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Beasley, John E. 1990. “OR-Library: Distributing Test Problems by\nElectronic Mail.” Journal of the Operational Research\nSociety 41 (11): 1069–72.\n\n\nKondili, E, CC Pantelides, and R WH Sargent. 1988. “A\nGeneral Algorithm for Scheduling\nBatch Operations.” In. Barton, ACT. https://search.informit.org/doi/10.3316/informit.394925233030714.\n\n\nKu, Wen-Yang, and J. Christopher Beck. 2016. “Mixed\nInteger Programming Models for Job Shop\nScheduling: A Computational Analysis.” Computers\n& Operations Research 73 (September): 165–73. https://doi.org/10.1016/j.cor.2016.04.006.\n\n\nManne, Alan S. 1960. “On the Job-Shop\nScheduling Problem.” Operations\nResearch 8 (2): 219–23. https://doi.org/10.1287/opre.8.2.219.\n\n\nWagner, Harvey M. 1959. “An Integer Linear-Programming Model for\nMachine Scheduling.” Naval Research Logistics Quarterly\n6 (2): 131–40. https://doi.org/10.1002/nav.3800060205."
  }
]