[
  {
    "objectID": "index.html#for-the-impatient",
    "href": "index.html#for-the-impatient",
    "title": "Hands-on Optimization with OR-Tools in Python",
    "section": "For the Impatient",
    "text": "For the Impatient\nIf you have experience with other optimization tools and you are just looking for some OR-Tools code examples, the example formulation and implementation below should give you a jump start. The formulation is devoid of any practical meanings.\n\\[\\begin{align}\n    \\text{min.} &\\quad \\sum_{s \\in \\mathcal{S}} \\sum_{d \\in \\mathcal{D}} c_{sd} x_{sd} \\label{tp-obj} \\\\\n    \\text{s.t.} & \\quad \\sum_{d \\in \\mathcal{D}} x_{sd} = p_s, \\ \\forall s \\in \\mathcal{S} \\label{tp-cons1} \\\\\n    & \\sum_{s \\in \\mathcal{S}} x_{sd} = m_d, \\ \\forall d \\in \\mathcal{D} \\label{tp-cons2} \\\\\n    & x_{sd} \\geq 0, \\ \\forall s \\in \\mathcal{S}, d \\in \\mathcal{D} \\label{tp-cons3}\n\\end{align}\\]\nThe implementation in OR-Tools of the above model aims to convey a few information:\n\nA solver object has to be instantiated first in order to create variables, objective and constraints.\nNumerical variables can be created using the solver.NumVar() method.\nObjective is added using the solver.Minimize() (solver.Maximize()) function.\nConstraints are added using the solver.Add() function.\nObjective and constraint expressions can be built by first putting their elements into a list and using the solver.Sum() method to aggregate them.\n\n\nfrom ortools.linear_solver import pywraplp\n\n# gather data\nnum_sources = 4\nnum_destinations = 5\nsupplies = [58, 55, 64, 71]\ndemands = [44, 28, 36, 52, 88]\ncosts = [[8, 5, 13, 12, 12], \n        [8, 7, 18, 6, 5], \n        [11, 12, 5, 11, 18], \n        [19, 13, 5, 10, 18]]\n\n# create solver\nsolver = pywraplp.Solver.CreateSolver(\"GLOP\")\n\n# create decision variables\nvar_flow = []\nfor src_idx in range(num_sources):\n    vars = [\n        solver.NumVar(0, solver.Infinity(), \n                    name=f\"var_{src_idx}, {dest_idx}\")\n        for dest_idx in range(num_destinations)\n    ]\n    var_flow.append(vars)\n\n# create constraints\nfor src_idx in range(num_sources):\n    expr = [var_flow[src_idx][dest_idx] \n            for dest_idx in range(num_destinations)]\n    solver.Add(solver.Sum(expr) == supplies[src_idx])\n\nfor dest_idx in range(num_destinations):\n    expr = [var_flow[src_idx][dest_idx] \n            for src_idx in range(num_sources)]\n    solver.Add(solver.Sum(expr) == demands[dest_idx])\n\n# create objective function\nobj_expr = []\nfor src_idx in range(num_sources):\n    for dest_idx in range(num_destinations):\n        obj_expr.append(var_flow[src_idx][dest_idx] * costs[src_idx][dest_idx])\nsolver.Minimize(solver.Sum(obj_expr))\n\nstatus = solver.Solve()\n\nopt_flow = []\nif status == pywraplp.Solver.OPTIMAL:\n    print(f\"optimal obj = {solver.Objective().Value()}\")\n    for src_idx in range(num_sources):\n        opt_vals = [var_flow[src_idx][dest_idx].solution_value()\n                    for dest_idx in range(num_destinations)]\n        opt_flow.append(opt_vals)"
  },
  {
    "objectID": "preface.html",
    "href": "preface.html",
    "title": "Preface",
    "section": "",
    "text": "Dear Reader,\nIf you’re reading this preface, then congratulations! You’ve either stumbled upon this book accidentally, or you’re one of the select few who shares my passion for optimization problems and solving them with Google OR-Tools. Either way, welcome!\nFirst things first, let me start by saying that writing a book is hard. Like, really hard. There were times when I thought I would never finish this darn thing. But then I reminded myself of why I started in the first place: I wanted to become an expert in Google OR-Tools and share that expertise with a broader audience. Plus, it was a great excuse to avoid doing laundry for weeks on end.\nNow, I’m not going to lie to you. If you’re not a fan of math, algorithms, or Python, then this book may not be for you. But if you’re anything like me, and you get a thrill out of finding the optimal solution to a complex problem, then buckle up! We’re about to embark on an adventure of optimization, constraints, and fancy algorithms.\nThroughout this book, we’ll cover everything from basic linear programming to more advanced metaheuristics. And trust me, we’ll have fun along the way. There will be laughter, tears (mostly from debugging errors), and hopefully a few “aha!” moments.\nIn all seriousness, I wrote this book because I believe that Google OR-Tools is an incredibly powerful tool for solving real-world optimization problems, and I want to share that knowledge with you. So, grab a cup of coffee (or tea, if you’re fancy like that) and let’s dive in!\nYours in optimization,\nKunlei Lian"
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Introduction",
    "section": "",
    "text": "This book covers the usage of Google OR-Tools to solve optimization problems in Python. There are several major chapters in this book:\nIn Chapter 2, we explain the steps needed to setup OR-Tools in a Python environment.\nIn Chapter 3, we use an example to illustrate the modeling capability of OR-Tools to solve linear programming problems.\nIn Chapter 4, we go through the modeling techniques made available in OR-Tools."
  },
  {
    "objectID": "env-setup.html#install-homebrew",
    "href": "env-setup.html#install-homebrew",
    "title": "2  Environment Setup",
    "section": "2.1 Install Homebrew",
    "text": "2.1 Install Homebrew\nThe first tool we need is Homebrew, ‘the Missing Package Manager for macOS (or Linux)’, and it can be accessed at https://brew.sh/. To install Homebrew, just copy the command below and run it in the Terminal.\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\nWe can then use the brew --version command to check the installed version. On my system, it shows the info below.\n ~/ brew --version\nHomebrew 3.6.20\nHomebrew/homebrew-core (git revision 5f1582e4d55; last commit 2023-02-05)\nHomebrew/homebrew-cask (git revision fa3b8a669d; last commit 2023-02-05)"
  },
  {
    "objectID": "env-setup.html#install-anaconda",
    "href": "env-setup.html#install-anaconda",
    "title": "2  Environment Setup",
    "section": "2.2 Install Anaconda",
    "text": "2.2 Install Anaconda\nSince there are several Python versions available for our use and we may end up having multiple Python versions installed on our machine, it is important to use a consistent environment to work on our project in. Anaconda is a package and environment manager for Python and it provides easy-to-use tools to facilitate our data science needs. To install Anaconda, run the below command in the Terminal.\n ~/ brew install anaconda\nAfter the installation is done, we can use conda --version to verify whether it is available on our machine or not.\n ~/ conda --version\nconda 23.1.0"
  },
  {
    "objectID": "env-setup.html#create-a-conda-environment",
    "href": "env-setup.html#create-a-conda-environment",
    "title": "2  Environment Setup",
    "section": "2.3 Create a Conda Environment",
    "text": "2.3 Create a Conda Environment\nNow we will create a Conda environment named ‘ortools’. Execute the below command in the Terminal, which effectively creates the required environment with Python version 3.10.\n ~/ conda create -n ortools python=3.10\nRetrieving notices: ...working... done\nCollecting package metadata (current_repodata.json): done\nSolving environment: done\n\n## Package Plan ##\n\n  environment location: /opt/homebrew/anaconda3/envs/test\n\n  added / updated specs:\n    - python=3.10\n\n\nThe following packages will be downloaded:\n\n    package                    |            build\n    ---------------------------|-----------------\n    setuptools-67.4.0          |     pyhd8ed1ab_0         567 KB  conda-forge\n    ------------------------------------------------------------\n                                           Total:         567 KB\n\nThe following NEW packages will be INSTALLED:\n\n  bzip2              conda-forge/osx-arm64::bzip2-1.0.8-h3422bc3_4\n  ca-certificates    conda-forge/osx-arm64::ca-certificates-2022.12.7-h4653dfc_0\n  libffi             conda-forge/osx-arm64::libffi-3.4.2-h3422bc3_5\n  libsqlite          conda-forge/osx-arm64::libsqlite-3.40.0-h76d750c_0\n  libzlib            conda-forge/osx-arm64::libzlib-1.2.13-h03a7124_4\n  ncurses            conda-forge/osx-arm64::ncurses-6.3-h07bb92c_1\n  openssl            conda-forge/osx-arm64::openssl-3.0.8-h03a7124_0\n  pip                conda-forge/noarch::pip-23.0.1-pyhd8ed1ab_0\n  python             conda-forge/osx-arm64::python-3.10.9-h3ba56d0_0_cpython\n  readline           conda-forge/osx-arm64::readline-8.1.2-h46ed386_0\n  setuptools         conda-forge/noarch::setuptools-67.4.0-pyhd8ed1ab_0\n  tk                 conda-forge/osx-arm64::tk-8.6.12-he1e0b03_0\n  tzdata             conda-forge/noarch::tzdata-2022g-h191b570_0\n  wheel              conda-forge/noarch::wheel-0.38.4-pyhd8ed1ab_0\n  xz                 conda-forge/osx-arm64::xz-5.2.6-h57fd34a_0\n\n\nProceed ([y]/n)?\nType ‘y’ to proceed and Conda will create the environment for us. We can use cnoda env list to show all the created environments on our machine:\n ~/ conda env list\n# conda environments:\n#\nbase                     /opt/homebrew/anaconda3\nortools                   /opt/homebrew/anaconda3/envs/ortools\nNote that we need to manually activate an environemnt in order to use it: conda activate ortools. On my machine, the activated environment ortools will appear in the beginning of my prompt.\n ~/ conda activate ortools\n(ortools)  ~/"
  },
  {
    "objectID": "env-setup.html#install-google-or-tools",
    "href": "env-setup.html#install-google-or-tools",
    "title": "2  Environment Setup",
    "section": "2.4 Install Google OR-Tools",
    "text": "2.4 Install Google OR-Tools\nAs of this writing, the latest version of Google OR-Tools is 9.5.2237, and we can install it in our newly created environment using the command pip install ortools==9.5.2237. We can use conda list to verify whether it is available in our environment.\n(ortools)  ~/ conda list\n# packages in environment at /opt/homebrew/anaconda3/envs/ortools:\n#\n# Name                    Version                   Build  Channel\nabsl-py                   1.4.0                    pypi_0    pypi\nbzip2                     1.0.8                h3422bc3_4    conda-forge\nca-certificates           2022.12.7            h4653dfc_0    conda-forge\nlibffi                    3.4.2                h3422bc3_5    conda-forge\nlibsqlite                 3.40.0               h76d750c_0    conda-forge\nlibzlib                   1.2.13               h03a7124_4    conda-forge\nncurses                   6.3                  h07bb92c_1    conda-forge\nnumpy                     1.24.2                   pypi_0    pypi\nopenssl                   3.0.8                h03a7124_0    conda-forge\nortools                   9.5.2237                 pypi_0    pypi\npip                       23.0.1             pyhd8ed1ab_0    conda-forge\nprotobuf                  4.22.0                   pypi_0    pypi\npython                    3.10.9          h3ba56d0_0_cpython    conda-forge\nreadline                  8.1.2                h46ed386_0    conda-forge\nsetuptools                67.4.0             pyhd8ed1ab_0    conda-forge\ntk                        8.6.12               he1e0b03_0    conda-forge\ntzdata                    2022g                h191b570_0    conda-forge\nwheel                     0.38.4             pyhd8ed1ab_0    conda-forge\nxz                        5.2.6                h57fd34a_0    conda-forge\nNow we have Python and Google OR-Tools ready, we can start our next journey."
  },
  {
    "objectID": "linear-programming.html#modeling-capabilities",
    "href": "linear-programming.html#modeling-capabilities",
    "title": "3  Linear Programming",
    "section": "3.1 Modeling Capabilities",
    "text": "3.1 Modeling Capabilities\nThere are three components in a mathematical model, namely, decision varaibles, constraints and objective, for which we will go over in the following sections.\n\n3.1.1 Solver\nIn Google OR-Tools, a Solver instance must be created first so that variables, constraints and objective can be added to it. The Solver class is defined in the ortools.linear_solver.pywraplp module and it requires a solver id to instantiate an object. In the code snippet below, the required module is imported first and a solver object is created with GLOP, Google’s own optimization engine for solving linear programming problems. It is good practice to verify whether the desired solver is indeed created successfully or not.\n\nfrom ortools.linear_solver import pywraplp\n\nsolver = pywraplp.Solver.CreateSolver(\"GLOP\")\n\nif solver:\n    print(\"solver creation success!\")\nelse:\n    print(\"solver creation failure!\")\n\nsolver creation success!\n\n\n\n\n3.1.2 Decision Variables\nThe Solver class defines a number of ways to create decision variables:\n\nVar(lb, ub, integer, name)\nNumVar(lb, ub, name)\nIntVar(lb, ub, name)\nBoolVar(name)\n\n\nFunction Var()\n\nThe Var() method is the most flexible way to define variables, as it can be used to create numerical, integral and boolean variables. In the following code, a numerical variable named ‘var1’ is created with bound (0.0, 1.0). Note that the parameter integer is set to False in the call to function Var().\n\nvar1 = solver.Var(lb=0, ub=1.0, integer=False, name=\"var1\")\n\nWe could create an integer variable using the same function:\n\nvar2 = solver.Var(lb=0, ub=1.0, integer=True, name=\"var2\")\n\n\nFunction NumVar()\n\nvar1 could be creatd alternatively using the specialized function NumVar():\n\nvar1 = solver.NumVar(lb=0, ub=1.0, name=\"var1\")\n\n\nFunction IntVar()\n\nSimilarly, var2 could be created alternatively using the specialized function IntVar():\n\nvar2 = solver.IntVar(lb=0, ub=1.0, name=\"var2\")\n\n\nFunction BoolVar()\n\nA boolean variable could be created using the BoolVar() function:\n\nvar3 = solver.BoolVar(name=\"var3\")\n\n\n\n3.1.3 Constraints\nConstraints limit the solution space of an optimization problem, and there are two ways to define constraints in Google OR-Tools. In the first approach, we could use the Add() function to create a constraint and automatically add it to the model at the same time, as the below code snippet illustrates.\n\ncons1 = solver.Add(constraint=var1 + var2 <= 1, name=\"cons1\")\n\ntype(cons1)\n\nortools.linear_solver.pywraplp.Constraint\n\n\nNote that the Add() function returns an object of the Constraint class defined in the pywraplp module, as shown in the code output. It is a good practice to retain the reference of the newly created constraint, as we might want to query its information later on.\nThe second approach works in a slightly different way. It starts with an empty constraint, with potential lower bound and upper bounds provided, and add components of the constraint gradually. The code snippet below shows an example of adding a second constraint to the model. In this approach, we must retain the reference to the constraint, as it is needed to add decision variables to the constraint in following steps.\n\ncons2 = solver.Constraint(-solver.infinity(), 10.0, \"cons2\")\ncons2.SetCoefficient(var1, 2)\ncons2.SetCoefficient(var2, 3)\ncons2.SetCoefficient(var3, 4)\ntype(cons2)\n\nortools.linear_solver.pywraplp.Constraint\n\n\n\n\n3.1.4 Objective\nSimilar to constraints, there are two ways to define the objective in Google OR-Tools. In the first approach, we directly add an objective to the model by using the Maximize() or Minimize() function. Below is an example:\n\nsolver.Minimize(var1 + var2 + var3)\n\nNote that the function itself does not return a reference to the newly created objective function, but we could use a dedicated function to retrive it:\n\nobj = solver.Objective()\nprint(obj)\n\n<ortools.linear_solver.pywraplp.Objective; proxy of <Swig Object of type 'operations_research::MPObjective *' at 0x10f1e92c0> >\n\n\nIn the second approach, we build the objective incrementally, just as in the second approach of creating constraints. Specifically, we start with an empty objective function, and gradually add components to it. In the end, we specify the optimization sense - whether we want to maximize or minimnize the objective.\n\nobj = solver.Objective()\nobj.SetCoefficient(var1, 1.0)\nobj.SetCoefficient(var2, 1.0)\nobj.SetCoefficient(var3, 1.0)\nobj.SetMinimization()\nprint(obj)\n\n<ortools.linear_solver.pywraplp.Objective; proxy of <Swig Object of type 'operations_research::MPObjective *' at 0x10fc86670> >\n\n\n\n\n3.1.5 Objective and Constraint Expressions\nWhen we build constraints or objective functions, sometimes they comprise of complex expressions that we would like to build incrementally, possibly within loops. For example, we might have a mathematical expression of the form \\(expr = 2x_1 + 3x_2 + 4x_3 + x_4\\), which could be part of the objective function or any constraints. In this case, we can either use the aforementioned SetCoefficient() function to add each element of the expression to the constraint or objective, or we could build an expression first and add it once in the end. The code snippet below shows an example.\n\ninfinity = solver.Infinity()\nx1 = solver.NumVar(0, infinity, name=\"x1\")\nx2 = solver.NumVar(0, infinity, name=\"x2\")\nx3 = solver.NumVar(0, infinity, name=\"x3\")\nx4 = solver.NumVar(0, infinity, name=\"x4\")\n\nexpr = []\nexpr.append(2 * x1)\nexpr.append(3 * x2)\nexpr.append(4 * x3)\nexpr.append(x4)\n\nconstr = solver.Add(solver.Sum(expr) <= 10)\nprint(constr)\n\nsolver.Minimize(solver.Sum(expr))\n\n<ortools.linear_solver.pywraplp.Constraint; proxy of <Swig Object of type 'operations_research::MPConstraint *' at 0x10fcb3060> >\n\n\nOf course, it is not obvious here that the retitive calls to the append() method are any more convenient than the SetCoefficient() method. Let’s say that we have a slightly more complex expression of the form \\(\\sum_{0 \\le i < 4}w_i \\cdot x_i\\), now we could build the expression using a loop:\n\nw = [2, 3, 4, 1]\nx = [x1, x2, x3, x4]\nexpr = []\nfor i in range(4):\n    expr.append(w[i] * x[i])\n\nconstr = solver.Add(solver.Sum(expr) <= 10)\n\n\n\n3.1.6 Query the Model\nAfter we build the model, we can query it using some helper functions. For example, to get the total number of constraints, we use the NumVariables() function. In a similar fashion, we can retrieve the total number of constraints with the NumConstraints() function.\n\nnum_vars = solver.NumVariables()\nprint(f\"there are a total of {num_vars} variables in the model\")\n\nnum_constr = solver.NumConstraints()\nprint(f\"there are a total of {num_constr} constraints in the model\")\n\nthere are a total of 9 variables in the model\nthere are a total of 4 constraints in the model"
  },
  {
    "objectID": "linear-programming.html#applications",
    "href": "linear-programming.html#applications",
    "title": "3  Linear Programming",
    "section": "3.2 Applications",
    "text": "3.2 Applications\nIn this section, we use some examples to showcase the modeling capability of Google OR-Tools.\n\n3.2.1 Trivial Problem\nWe now consider an simple linear programming problem with two decision variables \\(x\\) and \\(y\\). The formal mathematical model is defined as below:\n\\[\\begin{align}\n\\text{max.} \\quad & x + 2y \\\\\n\\text{s.t.} \\quad & x + y \\le 10 \\\\\n& x >= 1 \\\\\n& y >= 1\n\\end{align}\\]\nFigure 3.1 shows the three defining constraints represented in blue lines and the feasible space depicted by the orange shaded area. The objective function is indicated by the red dashed lines. It can be seen from the figure that the point in green circle gives the maximal objective value of 19.\n\n\n\n\n\nFigure 3.1: A simple LP example\n\n\n\n\nLet’s now use Google OR-Tools to model and solve this problem. The code snippet below shows the complete program.\n\n# import Google OR-Tools library\nfrom ortools.linear_solver import pywraplp\n\n# create a solver\nsolver = pywraplp.Solver.CreateSolver(\"GLOP\")\n\n# create decision variables\nx = solver.NumVar(1.0, solver.Infinity(), \"x\")\ny = solver.NumVar(1.0, solver.Infinity(), \"y\")\n\n# create constraints\nconstr = solver.Add(x + y <= 10)\n\n# create objective\nsolver.Maximize(x + 2 * y)\n\n# solve the problem\nstatus = solver.Solve()\n\nif status == pywraplp.Solver.OPTIMAL or status == pywraplp.Solver.FEASIBLE:\n    print(f\"obj = {solver.Objective().Value()}\")\n    print(f\"x = {x.solution_value()}, reduced cost = {x.reduced_cost()}\")\n    print(f\"y = {y.solution_value()}, reduced cost = {y.reduced_cost()}\")\n    print(f\"constr dual value = {constr.dual_value()}\")\n\nobj = 19.0\nx = 1.0, reduced cost = -1.0\ny = 9.0, reduced cost = 0.0\nconstr dual value = 2.0\n\n\nWe can see from the output that the optimal solution is \\(x = 1.0\\) and \\(y = 9.0\\), and the optimal objective is 19.0. This can also be validated from Figure 3.1 that the optimal solution is exactly the green point that sits at the intersection of the three lines \\(x = 1\\), \\(x + y = 10\\) and \\(x + 2y = 19\\).\nFigure 3.1 also shows that the point (1, 1) should give us the minimal value of the objective function. To validate this, we can actually change the optimization sense of the objective function from maximization to minimization using the function SetOptimizationDirection(), as shown in the code below:\n\nsolver.Objective().SetOptimizationDirection(maximize=False)\n\nsolver.Solve()\n\nprint(f\"obj = {solver.Objective().Value()}\")\nprint(f\"x = {x.solution_value()}, reduced cost = {x.reduced_cost()}\")\nprint(f\"y = {y.solution_value()}, reduced cost = {y.reduced_cost()}\")\nprint(f\"constr dual value = {constr.dual_value()}\")\n\nobj = 3.0\nx = 1.0, reduced cost = 1.0\ny = 1.0, reduced cost = 2.0\nconstr dual value = 0.0\n\n\n\n\n3.2.2 Transportation Problem\nThe transportation problem involves moving goods from its sources \\(\\mathcal{S}\\) to destinations \\(\\mathcal{D}\\). Each source \\(s \\in \\mathcal{S}\\) has a total amount of goods \\(p_s\\) it could supply, and each destination \\(s \\in \\mathcal{D}\\) has a certain amount of demands \\(m_d\\). There is a transportation cost, denoted by \\(c_{sd}\\), to move one unit of goods from a source to a destination. The problem is to find the best set of goods to move from each source to each destination such that all the destination demands are met with the lowest transportation costs.\nTo model this transportation problem, we define the decision variable \\(x_{sd}\\) to be the amount of goods moving from source \\(s\\) to destinaiton \\(d\\). Then we could state the problem mathematically as below.\n\\[\\begin{align}\n\\text{min.} &\\quad \\sum_{s \\in \\mathcal{S}} \\sum_{d \\in \\mathcal{D}} c_{sd} x_{sd} \\label{tp-obj} \\\\\n\\text{s.t.} & \\quad \\sum_{d \\in \\mathcal{D}} x_{sd} = p_s, \\ \\forall s \\in \\mathcal{S} \\label{tp-cons1} \\\\\n& \\sum_{s \\in \\mathcal{S}} x_{sd} = m_d, \\ \\forall d \\in \\mathcal{D} \\label{tp-cons2} \\\\\n& x_{sd} \\geq 0, \\ \\forall s \\in \\mathcal{S}, d \\in \\mathcal{D} \\label{tp-cons3}\n\\end{align}\\]\nThe objective function \\(\\eqref{tp-obj}\\) aims to minimize the total transportation costs going from all sources to all destinations. Constraints \\(\\eqref{tp-cons1}\\) make sure that the sum of goods leaving a source node \\(s\\) must equal to its available supply \\(p_s\\). Constraints \\(\\eqref{tp-cons2}\\) require that the sum of goods gonig to a destination node \\(d\\) must equal to its demand \\(m_d\\). Constraints \\(\\eqref{tp-cons3}\\) state that the flow variables from sources to destination can only be nonnegative values.\nTable 3.1 shows an instance of the transportation problem in which there are four sources and five destinations. Entries in the last row give the corresponding demand from each destination, and the last column list the available supply at each source. The entries in the middle of the table show the transportation cost associated with moving from a specific source to a specific destination. For example, it costs $18 to move one unit of good from source S2 to D3.\n\n\n\n\nTable 3.1: A transportation problem\n\n\n\nD1\nD2\nD3\nD4\nD5\nSupply\n\n\n\n\nS1\n8\n5\n13\n12\n12\n58\n\n\nS2\n8\n7\n18\n6\n5\n55\n\n\nS3\n11\n12\n5\n11\n18\n64\n\n\nS4\n19\n13\n5\n10\n18\n71\n\n\nDemand\n44\n28\n36\n52\n88\n248\n\n\n\n\n\n\nWe show here two modeling flavors of using OR-Tools to solve this problem. In the first approach, decision variables are created using the NumVar() function, cnostraints are defined using the Add() function and the objective function is added using the Minimize() function. Note that both constraints and the objective function are generated with the help of of Sum() function that creates an expression.\n\nfrom ortools.linear_solver import pywraplp\n\n# gather data\nnum_sources = 4\nnum_destinations = 5\nsupplies = [58, 55, 64, 71]\ndemands = [44, 28, 36, 52, 88]\ncosts = [[8, 5, 13, 12, 12], \n        [8, 7, 18, 6, 5], \n        [11, 12, 5, 11, 18], \n        [19, 13, 5, 10, 18]]\n\n# create solver\nsolver = pywraplp.Solver.CreateSolver(\"GLOP\")\n\n# create decision variables\nvar_flow = []\nfor src_idx in range(num_sources):\n    vars = [\n        solver.NumVar(0, solver.Infinity(), \n                    name=f\"var_{src_idx}, {dest_idx}\")\n        for dest_idx in range(num_destinations)\n    ]\n    var_flow.append(vars)\n\n# create constraints\nfor src_idx in range(num_sources):\n    expr = [var_flow[src_idx][dest_idx] \n            for dest_idx in range(num_destinations)]\n    solver.Add(solver.Sum(expr) == supplies[src_idx])\n\nfor dest_idx in range(num_destinations):\n    expr = [var_flow[src_idx][dest_idx] \n            for src_idx in range(num_sources)]\n    solver.Add(solver.Sum(expr) == demands[dest_idx])\n\n# create objective function\nobj_expr = []\nfor src_idx in range(num_sources):\n    for dest_idx in range(num_destinations):\n        obj_expr.append(var_flow[src_idx][dest_idx] * costs[src_idx][dest_idx])\nsolver.Minimize(solver.Sum(obj_expr))\n\nstatus = solver.Solve()\n\nopt_flow = []\nif status == pywraplp.Solver.OPTIMAL:\n    print(f\"optimal obj = {solver.Objective().Value()}\")\n    for src_idx in range(num_sources):\n        opt_vals = [var_flow[src_idx][dest_idx].solution_value()\n                    for dest_idx in range(num_destinations)]\n        opt_flow.append(opt_vals)\n\noptimal obj = 2013.0\n\n\nThe optimal solution is shown in Table 3.2.\n\n\n\n\nTable 3.2: The optimal solution\n\n\n\nD1\nD2\nD3\nD4\nD5\nSupply\n\n\n\n\nS1\n0\n28\n0\n0\n30\n58\n\n\nS2\n0\n0\n0\n0\n55\n55\n\n\nS3\n44\n0\n20\n0\n0\n64\n\n\nS4\n0\n0\n16\n52\n3\n71\n\n\nDemand\n44\n28\n36\n52\n88\n248\n\n\n\n\n\n\nIn the second approach shown in the code snippet below, decision variables are created with the Var(integer=False) method instead of the NumVar() method. In addition, both constraints and the objective function are created using the SetCoefficient() method. In the case of constraints, a lower bound and upper bound are used to generated an empty constraint, and variables are then added to the constraint one by one with their corresponding coefficient. In the case of the objective function, an empty objective is first initialized and variables are then added to it sequentially. Note that the optimization sense is set using the SetMinimization() function.\n\nfrom ortools.linear_solver import pywraplp\n\n# gather data\nnum_sources = 4\nnum_destinations = 5\nsupplies = [58, 55, 64, 71]\ndemands = [44, 28, 36, 52, 88]\ncosts = [[8, 5, 13, 12, 12], \n        [8, 7, 18, 6, 5], \n        [11, 12, 5, 11, 18],\n        [19, 13, 5, 10, 18]]\n\n# create solver\nsolver = pywraplp.Solver.CreateSolver(\"GLOP\")\n\n# create decision variables\nvar_flow = []\nfor src_idx in range(num_sources):\n    vars = [\n        solver.Var(\n            0, solver.Infinity(), integer=False, \n            name=f\"var_{src_idx}, {dest_idx}\"\n        )\n        for dest_idx in range(num_destinations)\n    ]\n    var_flow.append(vars)\n\n# create constraints\nfor src_idx in range(num_sources):\n    constr = solver.Constraint(supplies[src_idx], supplies[src_idx])\n    for dest_idx in range(num_destinations):\n        constr.SetCoefficient(var_flow[src_idx][dest_idx], 1.0)\n\nfor dest_idx in range(num_destinations):\n    constr = solver.Constraint(demands[dest_idx], demands[dest_idx])\n    for src_idx in range(num_sources):\n        constr.SetCoefficient(var_flow[src_idx][dest_idx], 1.0)\n\n# create objective function\nobj = solver.Objective()\nfor src_idx in range(num_sources):\n    for dest_idx in range(num_destinations):\n        obj.SetCoefficient(var_flow[src_idx][dest_idx], costs[src_idx][dest_idx])\nobj.SetMinimization()\n\nstatus = solver.Solve()\n\nopt_flow = []\nif status == pywraplp.Solver.OPTIMAL:\n    print(f\"optimal obj = {solver.Objective().Value()}\")\n    for src_idx in range(num_sources):\n        opt_vals = [var_flow[src_idx][dest_idx].solution_value()\n                    for dest_idx in range(num_destinations)]\n        opt_flow.append(opt_vals)\n\noptimal obj = 2013.0\n\n\nTo validate the results, Table 3.3 shows the optimal solution produced by the second modeling approach, which is the same as in the previous approach.\n\n\n\n\nTable 3.3: The optimal solution\n\n\n\nD1\nD2\nD3\nD4\nD5\nSupply\n\n\n\n\nS1\n0\n28\n0\n0\n30\n58\n\n\nS2\n0\n0\n0\n0\n55\n55\n\n\nS3\n44\n0\n20\n0\n0\n64\n\n\nS4\n0\n0\n16\n52\n3\n71\n\n\nDemand\n44\n28\n36\n52\n88\n248\n\n\n\n\n\n\n\n\n3.2.3 Resource Allocation Problem\nThe resource allocation problems involves distributing scarce resources among alternative activities. The resources could be machines in a manufacturing facility, money available to spend, or CPU runtime. The activities could be anything that brings profit at the cost of consuming resources. The objective of this problem is therefore to allocate the available resources to activities such that the total profit is maximized.\nHere, we give a general resource allocation model devoid of any practical meanings. To this end, we define a few input parameters to this problem:\n\n\\(\\mathcal{A}\\): the set of candidate activities\n\\(\\mathcal{R}\\): the set of avaiable resources\n\\(p_a\\): the profit of performing one unit of activity \\(a \\in \\mathcal{A}\\)\n\\(c_{ar}\\): the amount of resource \\(r \\in \\mathcal{R}\\) required by one unit of activity \\(a \\in \\mathcal{A}\\)\n\\(b_r\\): the total amount of available quantities for resource \\(r \\in \\mathcal{R}\\)\n\nThe decision variable \\(x_a\\) represents the amount of activity \\(a \\in \\mathcal{A}\\) we select to perform, and the mathematical mode is defined below:\n\\[\\begin{align}\n\\text{max.} &\\quad \\sum_{a \\in \\mathcal{A}} p_a x_a \\label{ra-obj} \\\\\n\\text{s.t.} & \\quad \\sum_{a \\in \\mathcal{A}} c_{ar} \\leq b_r, \\ \\forall r \\in \\mathcal{R} \\label{ra-cons1} \\\\\n& x_a \\geq 0, \\ a \\in \\mathcal{A}\n\\end{align}\\]\nTable 3.4 shows an instance of the resource allocation problem, in which there are three type of resources and five candidate activities. The last row gives the profit of performing each unit of an activity, while the last column shows the available amount of resources. The remaining entries in the table refer to the resource consumption for each activity. For example, selecting one unit of activity 1 (A1) requires 90, 64 and 55 units of resources R1, R2 and R3, respectively.\n\n\n\n\nTable 3.4: A resource allocation problem\n\n\n\nA1\nA2\nA3\nA4\nA5\nAvailable\n\n\n\n\nR1\n90\n57\n51\n97\n67\n2001\n\n\nR2\n64\n58\n97\n56\n93\n2616\n\n\nR3\n55\n87\n77\n52\n51\n1691\n\n\nProfit\n1223\n1238\n1517\n1616\n1027\n\n\n\n\n\n\n\nIn the code snippet below, we use Google OR-Tools to solve this problem instance. Again, we start with initializing a solver object, follwed by creation of five decision variables, one for each activity. Both the constraints and objective function are created using the first modeling approach demonstrated previously. The optimal solution is outputed in the end.\n\nfrom ortools.linear_solver import pywraplp\n\n# gather instance data\nnum_resources = 3\nnum_activities = 5\nprofits = [1223, 1238, 1517, 1616, 1027]\navailable_resources = [2001, 2616, 1691]\ncosts = [[90, 57, 51, 97, 67],\n        [64, 58, 97, 56, 93],\n        [55, 87, 77, 52, 51]]\n\n# initialize a solver object\nsolver = pywraplp.Solver.CreateSolver(\"GLOP\")\n\ninfinity = solver.Infinity()\n# create decision variables\nvar_x = [solver.NumVar(0, infinity, name=f\"x_P{a}\") \n        for a in range(num_activities)]\n\n# create objective function\nsolver.Maximize(solver.Sum([profits[a] * var_x[a] \n                            for a in range(num_activities)]))\n\n# create constraints\nfor r_idx in range(num_resources):\n    cons = solver.Add(\n            solver.Sum([costs[r_idx][a_idx] * var_x[a_idx] \n                        for a_idx in range(num_activities)]) \n                      <= available_resources[r_idx])\n    \nstatus = solver.Solve()\nif status != pywraplp.Solver.OPTIMAL:\n    print(\"solver failure!\")\n\nprint(\"solve complete!\")\nopt_obj = solver.Objective().Value()\nprint(f\"optimal obj = {opt_obj:.2f}\")\n\nopt_sol = [var_x[a_idx].solution_value() \n           for a_idx in range(num_activities)]\nfor a_idx in range(num_activities):\n    print(f\"opt_x[{a_idx + 1}] = {opt_sol[a_idx]:.2f}\")\n\nsolve complete!\noptimal obj = 41645.23\nopt_x[1] = 0.00\nopt_x[2] = 0.00\nopt_x[3] = 12.45\nopt_x[4] = 14.08\nopt_x[5] = 0.00\n\n\n\n\n3.2.4 Workforce Planning Problem\nIn the workforce planning problem, there are a number of time periods and each period has a workforce requirement that must be satisfied. In addition, there are a set of available work patterns to assign workers to and each pattern cover one or more time periods. Note that assignment of workers to a particular pattern incurs a certain cost. The problem is then to identify the number of workers assigned to each pattern such that the total cost is minimized.\nTable 3.5 shows a contrived workforce planning problem instance. In this problem, there are a total of 10 time periods and there are four patterns available to assign workers to. The last row gives the work requirement in each time period and the last column shows the cost of assigning a worker to a pattern.\n\n\nTable 3.5: A workforce planning problem instance\n\n\nCoverage\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\nCost\n\n\n\n\nPattern 1\nx\nx\nx\nx\n\n\n\n\n\n\n10\n\n\nPattern 2\n\n\nx\nx\nx\n\n\n\n\n\n30\n\n\nPattern 3\n\n\n\nx\nx\nx\nx\n\n\n\n20\n\n\nPattern 4\n\n\n\n\n\n\nx\nx\nx\nx\n40\n\n\nRequirement\n3\n4\n3\n1\n5\n7\n2\n4\n5\n1\n\n\n\n\n\nTo model this problem, we use \\(\\mathcal{T}\\) and \\(\\mathcal{P}\\) to denote the set of time periods and patterns, respectively. The parameter \\(m_{pt}\\) indicates whether a pattern \\(p \\in \\mathcal{P}\\) covers a certain time period \\(t \\in \\mathcal{T}\\). The work requirement of each time period and the cost of assigning a pattern is represented as \\(r_t\\) and \\(c_p\\), respectively.\nNow we are ready to define the variable \\(x_p\\) as the number of workers that are assigned to pattern \\(p\\), and the mathematical model can be stated as below.\n\\[\\begin{align}\n\\text{min.} & \\quad \\sum_{p \\in \\mathcal{P}} c_p x_p \\\\\n\\text{s.t.} & \\quad \\sum_{p \\in \\mathcal{P}} m_{pt} x_p \\geq r_t, \\ \\forall t \\in \\mathcal{T} \\\\\n&\\quad x_p \\geq 0, \\ \\forall p \\in \\mathcal{P}\n\\end{align}\\]\nThe code snippet below gives the Python code to solve this problem using Google OR-Tools.\n\nfrom ortools.linear_solver import pywraplp\n\n# import instance data\nnum_periods = 10\nnum_patterns = 4\nrequirements = [3, 4, 3, 1, 5, 7, 2, 4, 5, 1]\ncosts = [10, 30, 20, 40]\npatterns = [set([1, 2, 3, 4]),\n            set([3, 4, 5]),\n            set([4, 5, 6, 7]),\n            set([7, 8, 9, 10])]\n\n# create solver object\nsolver = pywraplp.Solver.CreateSolver('GLOP')\n\ninfinity = solver.Infinity()\n# create decision variables\nvar_p = [solver.NumVar(0, infinity, name=f\"x_{p}\")\n         for p in range(num_patterns)]\n\n# create objective function\nsolver.Minimize(\n    solver.Sum([costs[p] * var_p[p] \n                for p in range(num_patterns)])\n)\n\n# create constraints\nfor t in range(num_periods):   \n    solver.Add(\n        solver.Sum([var_p[p] \n                    for p in range(num_patterns) \n                    if (t + 1) in patterns[p]])\n        >= requirements[t])\n\n# solve the problem and retrieve optimal solution\nstatus = solver.Solve()\nif status == pywraplp.Solver.OPTIMAL:\n    print(f\"obj = {solver.Objective().Value()}\")\n    for p in range(num_patterns):\n        print(f\"var_{p + 1} = {var_p[p].solution_value()}\")\n\nobj = 380.0\nvar_1 = 4.0\nvar_2 = 0.0\nvar_3 = 7.0\nvar_4 = 5.0\n\n\n\n\n3.2.5 Sudoku Problem\nIn a Sudoku problem, a grid of 9x9 is given and the task is to fill all the cells with numbers 1-9. At the beginning, some of the cells are already gilled with numbers and the requirements are that the remaining cells must be filled so that each row, each column, and each of the 9 3x3 sub-grids contain all the numbers from 1 to 9 without any repitition. The difficulty level of Sudoku problems depends on the number of cells that are already filled in the grid at the beginning of the game. Problems with fewer initial digits filled are considered more challenging. Figure 3.2 illustrate a sample Sudoku problem.\n\n\n\n\n\nFigure 3.2: A Sudoku problem\n\n\n\n\nTo model this problem, we define set \\(S = (1, 2, 3, 4, 5, 6, 7, 8, 9)\\) and use \\(i, j \\in S\\) to index the row and column respectively. In addition, we use \\(M=\\{(i, j, k) | i, j, k \\in S\\}\\) to represent all the known numbers in the grid.\nTo formulate this problem, we define 9 binary variables for each cell in the 9x9 grid. Each of the 9 variables corresponds to one of the numbers in set \\(S\\). Formally, \\(x_{ijk}\\) represents whether the value \\(k\\) shows up in cell \\((i, j)\\) of the grid. Note that \\(i, j, k \\in S\\). The mathematical formulation can be stated as below.\n\\[\\begin{align}\n\\text{min.} &\\quad 0 \\label{sudoku-obj} \\\\\n\\text{s.t.} &\\quad \\sum_{j \\in S}x_{ijk} = 1, \\ \\forall i, k \\in S \\label{sudoku-cons1} \\\\\n&\\quad \\sum_{i \\in S} x_{ijk} = 1, \\ \\forall j, k \\in S \\label{sudoku-cons2} \\\\\n&\\quad \\sum_{k \\in S} x_{ijk} = 1, \\ \\forall i, j \\in S \\label{sudoku-cons3} \\\\\n&\\quad \\sum_{(i - 1) \\times 3 + 1}^{(i - 1) \\times 3 + 3} \\sum_{(j - 1) \\times 3 + 1}^{(j - 1) \\times 3 + 3} x_{ijk} = 1, \\ \\forall i, j \\in \\{1, 2, 3\\}, k \\in S \\label{sudoku-cons4}\\\\\n&\\quad x_{ijk} = 1, \\ \\forall (i, j, k) \\in M \\label{sudoku-cons5}\\\\\n&\\quad x_{ijk} \\in \\{0, 1\\}, \\ \\forall i, j,k \\in S\n\\end{align}\\]\nSince no feasible soution is more preferable than another, we use a constant value as the objective function, meaning any feasible soution is an optimal solution to this problem. Constraints \\(\\eqref{sudoku-cons1}\\) require that the number \\(k \\in S\\) shows up once and only once in each row of the grid. Similarly, \\(\\eqref{sudoku-cons2}\\) make sure that the number \\(k \\in S\\) shows up once and only once in each column of the grid. For each cell in the grid, only one of the numbers in \\(S\\) can appear, which is guaranteed by constraints \\(\\eqref{sudoku-cons3}\\). Constraints \\(\\eqref{sudoku-cons4}\\) ensure that the numbers in set \\(S\\) show up once and only once in each of the sub-grids. Constraints \\(\\eqref{sudoku-cons5}\\) make sure that the existing numbers in the grid stay the same in the optimal solution.\nWe can then solve the problem using Google OR-Tools and the code snippet is given below.\n\nimport numpy as np\nfrom ortools.linear_solver import pywraplp\n\n# import data\ngrid_size = 9\nsubgrid_size = 3\nM = [[(1, 3, 6)],\n     [(2, 3, 3)],\n     [(3, 1, 5), (3, 7, 3), (3, 8, 7), (3, 9, 9)],\n     [(4, 1, 2), (4, 2, 1), (4, 3, 4), (4, 4, 0)],\n     [(5, 6, 5), (5, 7, 4)],\n     [(6, 1, 3), (6, 2, 5), (6, 3, 8), (6, 7, 9)],\n     [(7, 1, 4), (7, 9, 2)],\n     [(8, 3, 5)],\n     [(9, 1, 8), (9, 2, 2)]]\n\n# create solver\nsolver = pywraplp.Solver.CreateSolver(\"SCIP\")\n\n# # create decision variables\nsudoku_vars = np.empty((grid_size, grid_size, grid_size), dtype=object)\nfor row in range(grid_size):\n     for col in range(grid_size):\n          for num in range(grid_size):\n               sudoku_vars[row][col][num] = solver.Var(0, \n                                   1, \n                                   integer=True, \n                                   name=f\"x_{row, col, num}\")\n\n# create objective\nsolver.Minimize(0)\n\n# create constraints\nfor row in range(grid_size):\n     for num in range(grid_size):\n          solver.Add(\n               solver.Sum([sudoku_vars[row][col][num] \n                              for col in range(grid_size)\n                         ]) == 1\n                    )\n\nfor col in range(grid_size):\n     for num in range(grid_size):\n          solver.Add(\n               solver.Sum([sudoku_vars[row][col][num] \n                              for row in range(grid_size)\n                         ]) == 1\n                    )\n          \nfor row in range(grid_size):\n     for col in range(grid_size):\n          solver.Add(\n               solver.Sum([sudoku_vars[row][col][num] \n                              for num in range(grid_size)\n                         ]) == 1\n                    )\n          \nfor row in range(grid_size):\n     known_values = M[row]\n     for value in known_values:\n          row, col, num = value\n          solver.Add(\n               sudoku_vars[row - 1][col - 1][num - 1] == 1\n          )\n\n# solve the problem\nstatus = solver.Solve()\n\nif status == pywraplp.Solver.OPTIMAL or status == pywraplp.Solver.FEASIBLE:\n     sudoku_sol = np.zeros((grid_size, grid_size), dtype=int)\n     for row in range(grid_size):\n          for col in range(grid_size):\n               for num in range(grid_size):\n                    if sudoku_vars[row][col][num].solution_value() == 1:\n                         sudoku_sol[row][col] = num + 1\n\nFigure 3.3 shows one solution to the example problem.\n\n\n\n\n\nFigure 3.3: One solution to the Sudoku problem"
  },
  {
    "objectID": "integer-programming.html#modeling-capabilities",
    "href": "integer-programming.html#modeling-capabilities",
    "title": "4  Integer Programming",
    "section": "4.1 Modeling Capabilities",
    "text": "4.1 Modeling Capabilities\nWhen modeling integer programs, there are two main tasks that require attention. The first is declaring integer variables, and the second is selecting a solver that is capable of solving integer programs.\n\n4.1.1 Declaring Integer Variables\nAs reviewed in Chapter 3, Google OR-Tools provides two options to create integer variables:\n\nThe Var(lb, ub, integer: bool, name) function\nThe IntVar(lb, ub, name) function\nThe Variable.SetInteger(integer: bool) function\n\nIn the code snippet below, we create three integer variables using all the aforementioned approaches:\n\nfrom ortools.linear_solver import pywraplp\n\nsolver = pywraplp.Solver.CreateSolver('SCIP')\n\n# option 1\nx = solver.Var(lb=0, ub=10, integer=True, name='x')\n\n# option 2\ny = solver.IntVar(lb=10, ub=20, name='y')\n\n# option 3\nz = solver.NumVar(lb=0, ub=5.5, name='z')\nz.SetInteger(integer=True)\n\nWe can verify the types of variables \\(x, y, z\\):\n\nprint(f\"x is integer? {x.integer()}\")\nprint(f\"y is integer? {y.integer()}\")\nprint(f\"z is integer? {z.integer()}\")\n\nx is integer? True\ny is integer? True\nz is integer? True\n\n\n\n\n4.1.2 Selecting an Integer Solver\nThere are several solvers available for solving integer programs, and some options include:\n\nCBC_MIXED_INTEGER_PROGRAMMING or CBC\nBOP_INTEGER_PROGRAMMING or BOP\nSAT_INTEGER_PROGRAMMING or SAT or CP_SAT\nSCIP_MIXED_INTEGER_PROGRAMMING or SCIP\nGUROBI_MIXED_INTEGER_PROGRAMMING or GUROBI or GUROBI_MIP\nCPLEX_MIXED_INTEGER_PROGRAMMING or CPLEX or CPLEX_MIP\nXPRESS_MIXED_INTEGER_PROGRAMMING or XPRESS or XPRESS_MIP\nGLPK_MIXED_INTEGER_PROGRAMMING or GLPK or GLPK_MIP\n\nIt’s important to note that some of these solvers are open-source, while others require a commercial license. The code block above demonstrates how to create an instance of an integer solver. To do so, we simply need to specify the name of the solver in the Solver.CreateSolver() function.\n\nsolver = pywraplp.Solver.CreateSolver('CBC')"
  },
  {
    "objectID": "ip-jsp.html#disjunctive-model",
    "href": "ip-jsp.html#disjunctive-model",
    "title": "5  Job Shop Scheduling",
    "section": "5.1 Disjunctive model",
    "text": "5.1 Disjunctive model\nThis model is taken from Ku and Beck (2016) and Manne (1960). The decision variables are defined as follows:\n\n\\(x_{ij}\\): the processing starting time of job \\(j\\) on machine \\(i\\)\n\\(z_{ijk}\\): a binary variable that equals 1 if job \\(j\\) precedes job \\(k\\) on machine \\(i\\)\n\nThe disjunctive model can then be stated as below.\n\\[\\begin{align}\n    \\text{min.} &\\quad C_{max} \\label{jsp-dis-obj}\\\\\n    \\text{s.t.} &\\quad x_{ij} \\geq 0, \\ \\forall j \\in \\mathcal{J}, i \\in \\mathcal{M} \\label{jsp-dis-cons1}\\\\\n    &\\quad x_{o_h^j, j} \\geq x_{o_{h-1}^j, j} + p_{o_{h-1}^j, j}, \\ \\forall j \\in \\mathcal{J}, h = 2, \\cdots, m \\label{jsp-dis-cons2}\\\\\n    &\\quad x_{ij} \\geq x_{ik} + p_{ik} - V \\cdot z_{ijk}, \\ \\forall i \\in \\mathcal{M}, j, k \\in \\mathcal{J}, j < k  \\label{jsp-dis-cons3}\\\\\n    &\\quad x_{ik} \\geq x_{ij} + p_{ij} - V \\cdot (1 - z_{ijk}), \\ \\forall i \\in \\mathcal{M}, j, k \\in \\mathcal{J}, j < k  \\label{jsp-dis-cons4}\\\\\n    &\\quad C_{max} \\geq x_{o_m^j, j} + p_{o_m^j, j}, \\ \\forall j \\in \\mathcal{J}  \\label{jsp-dis-cons5}\\\\\n    &\\quad z_{ijk} \\in \\{0, 1\\}, \\ \\forall i \\in \\mathcal{M}, j, k \\in \\mathcal{J} \\label{jsp-dis-cons6}\n\\end{align}\\]\nThe objective \\(\\eqref{jsp-dis-obj}\\) aims to minimize the maximal completion time of any job \\(j \\in \\mathcal{J}\\). Constraints \\(\\eqref{jsp-dis-cons1}\\) require that all the job processing starting time must not be negative values. Constraints \\(\\eqref{jsp-dis-cons2}\\) enforce the sequencing order among operations for every job, which state that the \\(h\\)-th operation of job \\(j\\), \\(o_h^j\\), cannot start unless its preceeding operation \\(o_{h - 1}^j\\) finishes. Constraints \\(\\eqref{jsp-dis-cons3}\\) and \\(\\eqref{jsp-dis-cons4}\\) together make sure that at most one job can be processed on a machine at any time. To be specific, in case of job \\(j\\) preceding job \\(k\\) on machine \\(i\\), \\(z_{ijk}\\) takes the value of 1 and constraints \\(\\eqref{jsp-dis-cons4}\\) ensure that job \\(k\\) won’t start processing on machine \\(i\\) unless job \\(i\\) completes processing; Otherwise, \\(z_{ijk}\\) takes the value of 0 and constraints \\(\\eqref{jsp-dis-cons3}\\) require that job \\(j\\) starts processing after job \\(k\\). Note that both constraints are needed when we require \\(j < k\\); Otherwise, only one of them is needed if we create a constraint for every pair of \\(j\\) and \\(k\\) on a machine. Constraints \\(\\eqref{jsp-dis-cons5}\\) derive \\(C_{max}\\) across all jobs. The last constraints \\(\\eqref{jsp-dis-cons6}\\) state the variable type of \\(z_{ijk}\\).\nThe disjunctive formulation code is presented entirely in the following lines. The data related to the specific case are read between lines 5 to 8, and a solver object is created in line 11. The variable \\(x_{ij}\\) is introduced in lines 16 to 23, followed by the introduction of variable \\(z_{ijk}\\) in lines 25 to 34. The variable \\(C_{max}\\) is defined in lines 36 to 38. The objective of the model is set in line 41, and the constraints are established in lines 44 to 80. The instance is solved, and the optimal solution is obtained from lines 82 to 93.\n\nfrom typing import List, Dict\nfrom ortools.linear_solver import pywraplp\n\n# read and parse the data\nfilename = './data/jssp/ft06.txt'\nnum_jobs, num_machines, \\\noperations, processing_times = \\\n    read_jssp_instance(filename)\n\n# create solver\nsolver = pywraplp.Solver.CreateSolver('SCIP')\n\n# create variables\ninfinity = solver.Infinity()\nvar_time: List[List] = []\nfor machine in range(num_machines):\n    arr = [\n        solver.NumVar(0, \n                    infinity, \n                    name=f'x_{machine, job}') \n        for job in range(num_jobs)\n        ]\n    var_time.append(arr)\n\nvar_prec: Dict = []\nfor machine in range(num_machines):\n    mac_dict = {}\n    for job_j in range(num_jobs - 1):\n        for job_k in range(job_j + 1, num_jobs):\n            mac_dict[(job_j, job_k)] = \\\n            solver.BoolVar(\n                name=f'z_{machine, job_j, job_k}'\n            )\n    var_prec.append(mac_dict)\n\nvar_makespan = solver.NumVar(0, \n                            infinity, \n                            name='C_max')\n\n# create objective\nsolver.Minimize(var_makespan)\n\n# create constraints\nfor job, job_operations in enumerate(operations):\n    for h in range(1, num_machines):\n        curr_machine = job_operations[h]\n        prev_machine = job_operations[h - 1]\n        prev_time = processing_times[job][prev_machine]\n        solver.Add(\n            var_time[curr_machine][job] >= \n                var_time[prev_machine][job] + \n                prev_time\n            )\n\nV = 0\nfor job in processing_times:\n    V += sum(processing_times[job].values())\nfor machine in range(num_machines):\n    for job_j in range(num_jobs - 1):\n        for job_k in range(job_j + 1, num_jobs):\n            solver.Add(\n                var_time[machine][job_j] >= \n                var_time[machine][job_k] +\n                processing_times[job_k][machine] - \n                V * var_prec[machine][(job_j, job_k)]\n            )\n            solver.Add(\n                var_time[machine][job_k] >= \n                var_time[machine][job_j] +\n                processing_times[job_j][machine] - \n                V * (1 - var_prec[machine][(job_j, job_k)])\n            )\n            \nfor job in range(num_jobs):\n    last_oper_machine = operations[job][-1]\n    solver.Add(\n        var_makespan >= \n        var_time[last_oper_machine][job] + \n        processing_times[job][last_oper_machine]\n    )\n\nstatus = solver.Solve()\n\nif status == solver.OPTIMAL:\n    print(f\"min. makespan = {solver.Objective().Value():.2f}\")\n    \n    opt_time = []\n    for machine in range(num_machines):\n        arr = [\n            int(var_time[machine][job].solution_value()) \n            for job in range(num_jobs)\n        ]\n        opt_time.append(arr)\n\nmin. makespan = 55.00\n\n\nThe output of the model indicates that the lowest possible time needed to complete all tasks in this instance is 55. To illustrate the most efficient solution, we have created a function called show_schedule() that displays a Gantt chart of the tasks needed to process all jobs. Figure 5.1 displays the optimal solution for this instance.\n\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\n\ndef show_schedule(num_jobs, operations, processing_times, opt_time):\n    colors = mpl.colormaps[\"Set1\"].colors\n\n    fig, ax = plt.subplots(figsize=[7, 3], dpi=100)\n\n    for idx, job in enumerate(range(num_jobs)):\n        machines = operations[job]\n        job_start_times = [opt_time[machine][job] \n                            for machine in machines]\n        job_processing_times = [processing_times[job][machine] \n                                for machine in operations[job]]\n        \n        if idx >= len(colors):\n            idx = idx % len(colors)\n        color = colors[idx]\n\n        bars = ax.barh(machines, \n                width=job_processing_times, \n                left=job_start_times, \n                label=f'Job {job + 1}', \n                color=color)\n        \n        ax.bar_label(bars, \n                    fmt=f'{job + 1}', \n                    label_type='center')\n        \n    ax.set_yticks(machines)\n    ax.set_xlabel(\"Time\")\n    ax.set_ylabel(\"Machine\")\n    fig.tight_layout()\n    plt.show()\n    \nshow_schedule(num_jobs, operations, processing_times, opt_time)\n\n\n\n\nFigure 5.1: Optimal solution of the ft06 instance using the disjunctive formulation"
  },
  {
    "objectID": "ip-jsp.html#time-indexed-model",
    "href": "ip-jsp.html#time-indexed-model",
    "title": "5  Job Shop Scheduling",
    "section": "5.2 Time-indexed model",
    "text": "5.2 Time-indexed model\nThe time-indexed formulation, proposed by Kondili, Pantelides, and Sargent (1988) and Ku and Beck (2016), involves the use of a binary variable \\(x_{ijt}\\) that takes the value of 1 if job \\(j\\) starts at time \\(t\\) on machine \\(i\\). The model can be expressed as follows.\n\\[\\begin{align}\n\\text{min.} &\\quad C_{max} \\label{jsp-time-obj}\\\\\n\\text{s.t.} &\\quad \\sum_{t \\in H} x_{ijt} = 1, \\ \\forall j \\in \\mathcal{J}, i \\in \\mathcal{M} \\label{jsp-time-cons1} \\\\\n&\\quad \\sum_{t \\in H} (t + p_{ij}) \\cdot x_{ijt} \\leq C_{max}, \\ \\forall j \\in \\mathcal{J}, i \\in \\mathcal{M} \\label{jsp-time-cons2} \\\\\n&\\quad \\sum_{j \\in \\mathcal{J}} \\sum_{t' \\in T_{ijt}} x_{ijt'} \\leq 1, \\ \\forall i \\in \\mathcal{M}, t \\in H, T_{ijt} = \\{t - p_{ij} + 1, \\cdots, t\\} \\label{jsp-time-cons3} \\\\\n&\\quad \\sum_{t \\in H} (t + p_{o_{h - 1}^j}, j) \\cdot x_{o_{h - 1}^j, jt} \\leq \\sum_{t \\in H} t \\cdot x_{o_h^j, jt}, \\ \\forall j \\in \\mathcal{J}, h = 2, \\cdots, m \\label{jsp-time-cons4} \\\\\n&\\quad x_{ijt} \\in \\{0, 1\\}, \\ \\forall j \\in \\mathcal{J}, i \\in \\mathcal{M}, t \\in H \\label{jsp-time-cons5}\n\\end{align}\\]\nIn this formulation, the first set of constraints, referred to as \\(\\eqref{jsp-time-cons1}\\), state that each job \\(j\\) must start at one specific time within the scheduling horizon \\(H\\), which is determined as the sum of processing times for all jobs - \\(H = \\sum_{i \\in \\mathcal{I}, j \\in \\mathcal{J}} p_{ij}\\). Constraints \\(\\eqref{jsp-time-cons2}\\) are used to calculate the value of \\(C_{max}\\), while constraints \\(\\eqref{jsp-time-cons3}\\) ensure that only one job can be processed by a machine at any given time. It’s important to note that a job will remain on a machine for its full processing time and cannot be interrupted. Constraints \\(\\eqref{jsp-time-cons4}\\) make sure that the order of processing jobs is followed, and constraints \\(\\eqref{jsp-time-cons5}\\) define the variable types used in the formulation.\nThe following code provides a program that uses the time-indexed formulation to solve the ft06 instance, with the value of \\(H\\) being the sum of all job processing times plus one. The two variables, \\(x_{ijt}\\) and \\(C_{max}\\), are created in lines 18 - 27. The constraints are created in lines 33 - 57. The optimal solution is retrieved in lines 61 - 71. It can be seen from the output that the same optimal objective, 55, is obtained using this formulation.\n\nfrom typing import List, Dict\nfrom ortools.linear_solver import pywraplp\nimport numpy as np\n\n# read and parse the data\nfilename = './data/jssp/ft06.txt'\nnum_jobs, num_machines, \\\noperations, processing_times = \\\n    read_jssp_instance(filename)\n    \n# create solver\nsolver = pywraplp.Solver.CreateSolver('SCIP')\n\n# create variables\nH = 1\nfor job in processing_times:\n    H += sum(processing_times[job].values())\nvar_x = np.empty((num_machines, num_jobs, H), dtype=object)\nfor machine in range(num_machines):\n    for job in range(num_jobs):\n        for t in range(H):\n            var_x[machine][job][t] = solver.BoolVar(name=f'x_{machine, job, t}')\n\ninfinity = solver.Infinity()\nvar_makespan = solver.NumVar(0, \n                            infinity, \n                            name='C_max')\n\n# create objective\nsolver.Minimize(var_makespan)\n\n# create constraints\nfor machine in range(num_machines):\n    for job in range(num_jobs):\n        solver.Add(solver.Sum([var_x[machine][job][t] for t in range(H)]) == 1)\n        \nfor machine in range(num_machines):\n    for job in range(num_jobs):\n        arr = [var_x[machine][job][t] * (t + processing_times[job][machine]) for t in range(H)]\n        solver.Add(solver.Sum(arr) <= var_makespan)\n        \nfor machine in range(num_machines):\n    for t in range(H):\n        arr = [var_x[machine][job][tt]\n                    for job in range(num_jobs)\n                    for tt in range(t - processing_times[job][machine] + 1, t + 1)]\n        solver.Add(solver.Sum(arr) <= 1)\n\nfor job in range(num_jobs):\n    for oper in range(1, num_machines):\n        prev_machine = operations[job][oper - 1]\n        curr_machine = operations[job][oper]\n        expr_prev = [(t + processing_times[job][prev_machine]) * var_x[prev_machine][job][t] \n                    for t in range(H)]\n        expr_curr = [t * var_x[curr_machine][job][t]\n                    for t in range(H)]\n        solver.Add(solver.Sum(expr_prev) <= solver.Sum(expr_curr))\n\nstatus = solver.Solve()\n\nif status == solver.OPTIMAL:\n    print(f\"min. makespan = {solver.Objective().Value():.2f}\")\n    \n    opt_time = []\n    for machine in range(num_machines):\n        arr = []\n        for job in range(num_jobs):\n            for t in range(t):\n                if int(var_x[machine][job][t].solution_value()) == 1:\n                    arr.append(t)\n        opt_time.append(arr)\n\nmin. makespan = 55.00\n\n\nThe optimal solution can be seen in Figure 5.2. Even though both formulations achieve the same optimal objective value, there are some minor discrepancies between the optimal solutions. For instance, in Figure 5.1, there is a gap after job 4 completes processing on machine 3, which is not present in Figure 5.2.\n\nshow_schedule(num_jobs, operations, processing_times, opt_time)\n\n\n\n\nFigure 5.2: Optimal solution of the ft06 instance using the time-indexed formulation"
  },
  {
    "objectID": "ip-jsp.html#rank-based-model",
    "href": "ip-jsp.html#rank-based-model",
    "title": "5  Job Shop Scheduling",
    "section": "5.3 Rank-based model",
    "text": "5.3 Rank-based model\nThe rank-based model is due to Wagner (1959) and taken from Ku and Beck (2016). There are three decision variables in this formulation:\n\n\\(x_{ijk}\\): a binary variable that equals 1 if job \\(j\\) is scheduled at the \\(k\\)-th position on machine \\(i\\)\n\\(h_{ik}\\): a numerical variable that represents the start time of job at the \\(k\\)-th position of machine \\(i\\).\n\\(C_{max}\\): the makespan to be minimized\n\nThe complete model is given below.\n\\[\\begin{align}\n\\text{min.} &\\quad C_{max} \\label{jsp-rank-obj} \\\\\n\\text{s.t.} &\\quad \\sum_{j \\in \\mathcal{J}} x_{ijk} = 1, \\ \\forall i \\in \\mathcal{M}, k = 1, \\cdots, n \\label{jsp-rank-cons1} \\\\\n&\\quad \\sum_{k = 1}^n x_{ijk} = 1, \\ \\forall i \\in \\mathcal{M}, j \\in \\mathcal{J} \\label{jsp-rank-cons2} \\\\\n&\\quad h_{ik} + \\sum_{j \\in \\mathcal{J}} p_{ij} x_{ijk} \\leq h_{i,k+1}, \\ \\forall i \\in \\mathcal{M}, k = 1, \\cdots, n-1 \\label{jsp-rank-cons3}\\\\\n&\\quad\n\\begin{split}\n    &\\sum_{i \\in \\mathcal{M}} r_{ijl} h_{ik} + \\sum_{i \\in \\mathcal{M}} r_{ijl}p_{ij} \\leq V \\cdot (1 - \\sum_{i \\in \\mathcal{M}}r_{ijl}x_{ijk})\\  +\\  \\\\\n    &V \\cdot (1 - \\sum_{i \\in \\mathcal{M}}r_{ij,l+1}x_{ijk'}) + \\sum_{i \\in \\mathcal{M}}r_{ij,l+1}h_{ik'},\\\\\n    &\\forall j \\in \\mathcal{J}, k, k' = 1, \\cdots, n, l = 1, \\cdots, m - 1\n\\end{split}\n\\label{jsp-rank-cons4}\\\\\n&\\quad h_{in} + \\sum_{j \\in \\mathcal{J}} p_{ij}x_{ijk} \\leq C_{max}, \\ \\forall i \\in \\mathcal{M} \\label{jsp-rank-cons5}\\\\\n&\\quad h_{ik} \\geq 0, \\ \\forall i \\in \\mathcal{M}, k = 1, \\cdots, n \\label{jsp-rank-cons6} \\\\\n&\\quad x_{ijk} \\in \\{0, 1\\}, \\ \\forall j \\in \\mathcal{J}, i \\in \\mathcal{M}, k = 1, \\cdots, n \\label{jsp-rank-cons7}\\\\\n&\\quad C_{max} \\geq 0 \\label{jsp-rank-cons8}\n\\end{align}\\]\nIn this formulation, constraints \\(\\eqref{jsp-rank-cons1}\\) make sure that there is only one job assigned to a particular rank \\(k\\) on machine \\(i\\). Constraints \\(\\eqref{jsp-rank-cons2}\\) ensure that any job \\(j\\) is assigned to one and only one rank on a machine \\(i\\). Constraints \\(\\eqref{jsp-rank-cons3}\\) require that a machine can only process at most one job at any point of time. Constraints \\(\\eqref{jsp-rank-cons4}\\) guarantee that the processing order of a job is respected. Constraints \\(\\eqref{jsp-rank-cons5}\\) computes the makespan. The remaining constraints \\(\\eqref{jsp-rank-cons6}\\), \\(\\eqref{jsp-rank-cons7}\\) and \\(\\eqref{jsp-rank-cons8}\\) indicate the variable types.\nWe now solve the same problem instance using this rank-based formulation in Google OR-Tools, for which the complete code is shown below.\n\nfrom typing import List\nfrom itertools import product\nimport numpy as np\nfrom ortools.linear_solver import pywraplp\n\n# read and parse the data\nfilename = './data/jssp/ft06.txt'\nnum_jobs, num_machines, \\\noperations, processing_times = \\\n    read_jssp_instance(filename)\n    \n# create solver\nsolver = pywraplp.Solver.CreateSolver('SCIP')\n\n# create variables\nvar_x = np.empty(shape=(num_machines, num_jobs, num_jobs), dtype=object)\nfor machine, job, rank in product(range(num_machines), \n                                range(num_jobs), \n                                range(num_jobs)):\n    var_x[machine][job][rank] = solver.BoolVar(name=f'x_{machine, job, rank}')\n            \n\ninfinity = solver.Infinity()\nvar_h = np.empty(shape=(num_machines, num_jobs), dtype=object)\nfor machine, rank in product(range(num_machines), range(num_jobs)):\n    var_h[machine][rank] = solver.NumVar(0, infinity, name=f'h_{machine, rank}')\n\nvar_makespan = solver.NumVar(0, infinity, name=f'makesplan')\n\n# create objective\nsolver.Minimize(var_makespan)\n\n# create constraints\nfor machine, rank in product(range(num_machines), range(num_jobs)):\n    expr = [var_x[machine][job][rank] for job in range(num_jobs)]\n    solver.Add(solver.Sum(expr) == 1)\n\nfor machine, job in product(range(num_machines), range(num_jobs)):\n    expr = [var_x[machine][job][rank] for rank in range(num_jobs)]\n    solver.Add(solver.Sum(expr) == 1)\n\nfor machine, rank in product(range(num_machines), range(num_jobs - 1)):\n    expr = [var_x[machine][job][rank] * processing_times[job][machine] \n            for job in range(num_jobs)]\n    solver.Add(var_h[machine][rank] + solver.Sum(expr) <= var_h[machine][rank + 1])\n\nr = np.zeros((num_machines, num_jobs, num_machines))\nfor job in range(num_jobs):\n    job_operations: List = operations[job]\n    for o_idx, o_machine in enumerate(job_operations):\n        r[o_machine][job][o_idx] = 1\nV = 0\nfor job in processing_times:\n    V += sum(processing_times[job].values())\n\nfor job, k, kk, l in product(range(num_jobs), \n                            range(num_jobs), \n                            range(num_jobs), \n                            range(num_machines - 1)):\n    expr_1 = [r[machine][job][l] * var_h[machine][k] \n            for machine in range(num_machines)]\n    expr_2 = [r[machine][job][l] * processing_times[job][machine]\n            for machine in range(num_machines)]\n    expr_3 = [r[machine][job][l] * var_x[machine][job][k]\n            for machine in range(num_machines)]\n    expr_4 = [r[machine][job][l + 1] * var_x[machine][job][kk] \n            for machine in range(num_machines)]\n    expr_5 = [r[machine][job][l + 1] * var_h[machine][kk] \n            for machine in range(num_machines)]\n    solver.Add(solver.Sum(expr_1) + solver.Sum(expr_2) <= V * (1 - solver.Sum(expr_3)) + V * (1 - solver.Sum(expr_4)) + solver.Sum(expr_5))\n\nfor machine in range(num_machines):\n    expr = [var_x[machine][job][num_jobs - 1] * processing_times[job][machine] for job in range(num_jobs)]\n    solver.Add(var_h[machine][num_jobs - 1] + solver.Sum(expr) <= var_makespan)\n\nstatus = solver.Solve()\n\nif status == pywraplp.Solver.OPTIMAL:\n    print(f\"opt_obj = {solver.Objective().Value():.4f}\")\n    opt_time = []\n    for machine in range(num_machines):\n        arr = []\n        for job in range(num_jobs):\n            for rank in range(num_jobs):\n                if int(var_x[machine][job][rank].solution_value()) == 1:\n                    arr.append(var_h[machine][rank].solution_value())\n        opt_time.append(arr)\n\nopt_obj = 55.0000\n\n\nFigure 5.3 displays the optimal solution obtained by utilizing the rank-based model. Upon careful examination, it is slightly distinct from the optimal solutions produced by the disjunctive model and the time-indexed model. Nevertheless, all three models achieve the same objective value of 55.\n\nshow_schedule(num_jobs, operations, processing_times, opt_time)\n\n\n\n\nFigure 5.3: Optional solution found by the rank-based model for instance ft06\n\n\n\n\nWhile this book does not aim to compare the performance of the three modeling approaches, Table 5.1 presents the computational times required by each formulation to discover the optimal solutions. The table indicates that the disjunctive model is the most efficient of the three, followed by the time-indexed model, while the rank-based model requires the longest time to converge. It should be noted that making a conclusion about the performance of these models based on one experimental run on a single instance is insufficient.\n\n\n\n\nTable 5.1: Computational time comparison of the three formulations\n\n\nInstance\nDisjunctive Model\nTime-indexed Model\nRank-based Model\n\n\n\n\nft06\n1.7s\n1m34.9s\n11m38.2s\n\n\n\n\n\n\n\n\n\n\nBeasley, John E. 1990. “OR-Library: Distributing Test Problems by Electronic Mail.” Journal of the Operational Research Society 41 (11): 1069–72.\n\n\nKondili, E, CC Pantelides, and R WH Sargent. 1988. “A General Algorithm for Scheduling Batch Operations.” In. Barton, ACT. https://search.informit.org/doi/10.3316/informit.394925233030714.\n\n\nKu, Wen-Yang, and J. Christopher Beck. 2016. “Mixed Integer Programming Models for Job Shop Scheduling: A Computational Analysis.” Computers & Operations Research 73 (September): 165–73. https://doi.org/10.1016/j.cor.2016.04.006.\n\n\nManne, Alan S. 1960. “On the Job-Shop Scheduling Problem.” Operations Research 8 (2): 219–23. https://doi.org/10.1287/opre.8.2.219.\n\n\nWagner, Harvey M. 1959. “An Integer Linear-Programming Model for Machine Scheduling.” Naval Research Logistics Quarterly 6 (2): 131–40. https://doi.org/10.1002/nav.3800060205."
  },
  {
    "objectID": "ip-cvrp.html",
    "href": "ip-cvrp.html",
    "title": "7  Capacitated Vehicle Routing Problem",
    "section": "",
    "text": "The Capacitated Vehicle Routing Problem (CVRP) is a classical combinatorial optimization problem that involves finding the optimal set of routes for a fleet of vehicles to deliver goods or services to a set of customers. In the CVRP, a set of customers is given, each with a known demand and location. A fleet of vehicles, each with a limited capacity, is available to serve these customers. The problem is to find a set of routes visited by the vehicles such that each customer is visited once and only once and the total traveling distance is minimized.\nWe use the notation provided in Toth and Vigo (2014) to facilitate the presentation of different CVRP models. The depot, denoted as 0, serves as the starting point for transporting goods to customers in \\(\\mathcal{N} = {1, 2, \\cdots, n}\\) using a homogeneous fleet \\(\\mathcal{K} = {1, 2, \\cdots, |\\mathcal{K}|}\\). Each customer in \\(\\mathcal{N}\\) has a demand of \\(q_i \\geq 0\\), and each vehicle has a positive capacity of \\(Q > 0\\). The cost of transportation, denoted by \\(c_{ij}\\), is incurred when a vehicle travels between \\(i\\) and \\(j\\). A vehicle’s route begins at the depot, visits some or all the customers in \\(\\mathcal{N}\\), and then returns to the depot. The objective is to determine the optimal set of routes for the fleet to minimize the total cost of transportation.\nThe CVRP could be defined on a directed graph \\(\\mathcal{G} = (\\mathcal{V}, \\mathcal{A})\\), where \\(\\mathcal{V} = \\{0\\} \\cup \\{1, 2, \\cdots, n\\} = \\{0, 1, \\cdots, n\\}\\), and \\(\\mathcal{A} = \\{(i, j) | i, j \\in \\mathcal{V}, i \\neq j\\}\\). Let \\(S\\) be a subset of \\(\\mathcal{V}\\), that is, \\(S \\subseteq \\mathcal{V}\\). The in-arcs and out-arcs of \\(S\\) are defined as follows:\n\n\\(\\delta^-(S) = \\{(i, j) \\in \\mathcal{A} | i \\notin S, j \\in S \\}\\)\n\\(\\delta^+(S) = \\{(i, j) \\in \\mathcal{A} | i \\in S, j \\notin S \\}\\)\n\nIn addition, we use \\(\\mathcal{A}(S) = \\{(i, j) \\in \\mathcal{A} | i \\in S, j \\in S \\}\\) to indicate all the arcs that connect nodes within \\(S\\).\n\n7.0.0.1 CVRP Instances\nWe use the instances taken from CVRPLIB (2014) to illustrate the modeling and solving process with Google OR-Tools. CVRPLIB (2014) contains many benchmarking instances for CVRP and we use the python package vrplib to load the instance P-n16-k8.vrp and its optimal solution P-n16-k8.sol.\n\n# install vrplib with command: pip install vrplib\nimport vrplib\n\n# Read VRPLIB formatted instances (default)\ninstance = vrplib.read_instance(\"./data/cvrp/P-n16-k8.vrp\")\nsolution = vrplib.read_solution(\"./data/cvrp/P-n16-k8.sol\")\n\nLet’s first create a function to visualize vehicle routes, as given below.\n\nimport networkx as nx\nimport numpy as np\nimport matplotlib as mpl\n\ndef show_vehicle_routes(locations, edges):\n    \"\"\"draw vehicles routings\n    adapted from https://stackoverflow.com/a/50682819\n    \n    examples:\n    locations = {\n        0: (5, 5),\n        1: (4, 9),\n        2: (6, 4),\n        3: (2, 6),\n    }\n\n    edges = [\n        (0, 1, {'vehicle': '0'}),\n        (1, 2, {'vehicle': '0'}),\n        (2, 0, {'vehicle': '0'}),\n        (0, 3, {'vehicle': '1'}),\n        (3, 0, {'vehicle': '1'}),\n    ]\n\n    Args:\n        locations (dict): location id -> (lat, lon)\n        edges (list): list of edges\n    \"\"\"\n    G = nx.DiGraph()\n    G.add_edges_from(edges)\n    plt.figure(figsize=(15,10))\n    \n    vehicles = set([e[2]['vehicle'] for e in edges])\n    num_vehicles = len(vehicles)\n    \n    colors = mpl.colormaps[\"Set1\"].colors\n    for v in range(num_vehicles):\n        temp = [e for e in edges if e[2]['vehicle'] == str(v)]\n        \n        color_idx = v \n        if color_idx >= len(colors):\n            color_idx = color_idx % len(colors)\n        color = np.array([colors[color_idx]])\n        \n        nx.draw_networkx_nodes(G, \n                                locations, \n                                nodelist=[x[0] for x in temp], \n                                node_color=color)\n        nx.draw_networkx_edges(G,\n                                locations, \n                                edgelist=temp,\n                                width=4, \n                                edge_color=color, \n                                style='dashed')\n\n    #let's color the node 0 in black\n    nx.draw_networkx_nodes(G, locations, \n                            nodelist=[0], \n                            node_color='k')\n\n    # labels\n    nx.draw_networkx_labels(G, locations, \n                            font_color='w', \n                            font_size=12, \n                            font_family='sans-serif')\n\n    #print out the graph\n    plt.axis('off')\n    plt.show()\n\nFigure 7.1 shows the optimal vehicle routes for the instance P-n16-k8.vrp.\n\n\nCode\n# visualize the optimal solution\nnode_coords = instance['node_coord']\nlocations = {}\nfor idx, coord in enumerate(node_coords):\n    locations[idx] = (coord[0], coord[1])\n\nroutes = solution['routes']\nvehicle_idx = 0\nedges = []\nfor route in routes:\n    r_temp = route.copy()\n    r_temp.insert(0, 0)\n    r_temp.insert(len(r_temp), 0)\n    for i in range(len(r_temp) - 1):\n        edges.append((r_temp[i], r_temp[i + 1], {'vehicle': str(vehicle_idx)}))\n    \n    vehicle_idx += 1\n\nshow_vehicle_routes(locations, edges)\n\n\n\n\n\nFigure 7.1: Optimal routes for instance P-n16-k8.vrp\n\n\n\n\n\n\n7.0.0.2 Subtour Elimination Constraints (SECs)\n\n\n7.0.0.3 Two-index Formulation - 1\nThis formulation was proposed by Laporte, Mercure, and Nobert (1986) and we present the formulation given in Toth and Vigo (2014). In this formulation, we define the variable \\(x_{ij}\\) that equals 1 if the arc \\((i, j)\\) is traversed by a vehicle. The complete model is given below.\n\\[\\begin{align}\n    \\text{min.} &\\quad \\sum_{(i, j) \\in \\mathcal{A}} c_{ij} x_{ij} \\label{cvrp-two-index-obj} \\\\\n    \\text{s.t.} &\\quad \\sum_{j \\in \\delta^+(i)}x_{ij} = 1, \\ \\forall i \\in \\mathcal{N} \\label\n    {cvrp-two-index-cons1}\\\\\n    &\\quad \\sum_{i \\in \\delta^-(j)} x_{ij} = 1, \\ \\forall j \\in \\mathcal{N} \\label{cvrp-two-index-cons2} \\\\\n    &\\quad \\sum_{j \\in \\delta^+(0)} x_{oj} = |\\mathcal{K}| \\label{cvrp-two-index-cons3} \\\\\n    &\\quad \\sum_{(i, j) \\in \\delta^+(S)} x_{ij} \\geq r(S), \\ \\forall S \\subseteq \\mathcal{N}, S \\neq \\emptyset \\label{cvrp-two-index-cons4} \\\\\n    &\\quad x_{ij} \\in \\{0, 1\\}, \\ \\forall (i, j) \\in \\mathcal{A} \\label{cvrp-two-index-cons5}\n\\end{align}\\]\nThe objective function represented by equation \\(\\eqref{cvrp-two-index-obj}\\) is to minimize the overall transportation costs. The constraints expressed in equations \\(\\eqref{cvrp-two-index-cons1}\\) and \\(\\eqref{cvrp-two-index-cons2}\\) work together to guarantee that each customer is visited only once, with one incoming and outgoing arc. Constraints \\(\\eqref{cvrp-two-index-cons3}\\) ensure that all available vehicles are utilized to serve the customers. Constraints \\(\\eqref{cvrp-two-index-cons4}\\) prevent the formation of sub-tours. Finally, the variable types are defined by the last set of constraints, which are presented in equation \\(\\eqref{cvrp-two-index-cons5}\\).\nTo solve the aforementioned instance, we’ll first prepare the data for our following implementation use. Let’s first define two classes, Node and Vehicle, to represent a node in the network and the vechiles, respectively.\n\nclass Node:\n    \"\"\"a node is either a depot (0) or a customer\n    \"\"\"\n    \n    def __init__(self, id, x_coord, y_coord, demand):\n        self._id = id\n        self._x_coord = x_coord\n        self._y_coord = y_coord\n        self._demand = demand\n        \n    @property\n    def id(self): return self._id\n    \n    @property\n    def x_coord(self): return self._x_coord\n    \n    @property\n    def y_coord(self): return self._y_coord\n    \n    @property\n    def demand(self): return self._demand\n    \n    def __str__(self):\n        return f\"id: {self._id}, x_coord: {self._x_coord}, y_coord: {self._y_coord}, demand: {self._demand}\"\n\n\nclass Vehicle:\n    \"\"\"a vehicle\n    \"\"\"\n    \n    def __init__(self, id, capacity):\n        self._id = id\n        self._capacity = capacity\n        \n    @property\n    def id(self): return self._id\n    \n    @property\n    def capacity(self): return self._capacity\n    \n    def __str__(self):\n        return f\"id: {self._id}, capacity: {self._capacity}\"\n\nNow let’s define a class CvrpDataCenter to hold all the information we need later. It also has a helper function to read and parse an CVRP instance.\n\nfrom typing import List\nimport vrplib\nimport re\nfrom itertools import combinations\n\nclass CvrpDataCenter:\n    \"\"\"this class manages all the data for a CVRP instance\n    \"\"\"\n    \n    def __init__(self):\n        self._nodes: List = None\n        self._vehicles: List = None\n        self._distance: List[List] = None\n\n    def read_cvrp_instance(self, instance_file):\n        \"\"\"read a given cvrp instance\n\n        Args:\n            instance_file (str): instance file\n        \"\"\"\n        instance = vrplib.read_instance(instance_file)\n\n        # gather nodes\n        nodes = []\n        idx = 0\n        for node, demand in zip(instance['node_coord'], \n                                instance['demand']):\n            node = Node(id=idx, \n                        x_coord=node[0], \n                        y_coord=node[1], \n                        demand=demand)\n            idx += 1\n            nodes.append(node)\n            \n        # gather vehicles\n        comment = instance['comment']\n        num_vehicles = int(re.search(r'\\d', comment).group())\n        vehicles = []\n        for v in range(num_vehicles):\n            vehicle = Vehicle(v, int(instance['capacity']))\n            vehicles.append(vehicle)\n        \n        # gather distance matrix\n        distance = instance['edge_weight']\n        \n        self._nodes = nodes\n        self._vehicles = vehicles\n        self._distance = distance\n    \n    @property\n    def nodes(self): return self._nodes\n    \n    @property\n    def vehicles(self): return self._vehicles\n    \n    @property\n    def num_nodes(self): return len(self._nodes)\n    \n    @property\n    def num_vehicles(self): return len(self._vehicles)\n    \n    @property\n    def vehicle_capacity(self): \n        return self._vehicles[0].capacity\n\n    def distance(self, i, j, integer=False):\n        return round(self._distance[i][j]) \\\n            if integer else self._distance[i][j]\n    \n    def get_all_combinations(self, numbers):\n        combs = []\n        for i in range(1, len(numbers) + 1):\n            combs.extend(list(combinations(numbers, i)))\n        return combs\n\nTo implement this formulation using Google OR-Tools, we first create a CvrpDataCenter object and read in the instance P-n16-k8.vrp. Then we create a solver object with solver option SCIP to solve mixed integer programming problems.\n\nfrom ortools.linear_solver import pywraplp\nimport numpy as np\nfrom itertools import product\nimport math\n\n# prepare instance\ncvrp_data_center = CvrpDataCenter()\ncvrp_data_center.read_cvrp_instance(\"./data/cvrp/P-n16-k8.vrp\")\n\n# instantiate solver\nsolver = pywraplp.Solver.CreateSolver('SCIP')\n\nNow let’s create the decision variable \\(x_{ij}\\). Note that we don’t need to create variables when \\(i = j\\) since there is no arc pointing to itself in the graph \\(\\mathcal{G}\\) we defined earlier.\n\n# create decision variables\nnum_nodes = cvrp_data_center.num_nodes\nnum_vehicles = cvrp_data_center.num_vehicles\nvar_x = np.empty((num_nodes, num_nodes), dtype=object)\nfor i, j in product(range(num_nodes), range(num_nodes)):\n    if i == j: continue\n    var_x[i][j] = solver.BoolVar(name=\"x_{i, j}\")\n\nThen we create the objective function.\n\n# define objective function\nobj_expr = [\n    cvrp_data_center.distance(i, j, integer=True) * var_x[i][j]\n    for i, j in product(range(num_nodes), range(num_nodes))\n    if i != j\n]\nsolver.Minimize(solver.Sum(obj_expr))\n\nAnd we create the constraints \\(\\eqref{cvrp-two-index-cons1}\\) and \\(\\eqref{cvrp-two-index-cons2}\\).\n\n# create incoming and outgoing arc constraints\nfor i in range(1, num_nodes):\n    out_arcs = [var_x[i][j] for j in range(num_nodes) if j != i]\n    in_arcs = [var_x[j][i] for j in range(num_nodes) if j != i]\n    solver.Add(solver.Sum(out_arcs) == 1)\n    solver.Add(solver.Sum(in_arcs) == 1)\n\nConstraints \\(\\eqref{cvrp-two-index-cons3}\\) are created as follows.\n\n# create fleet size constraint\nexpr = [var_x[0][i] for i in range(1, num_nodes)]\nsolver.Add(solver.Sum(expr) == num_vehicles)\n\n<ortools.linear_solver.pywraplp.Constraint; proxy of <Swig Object of type 'operations_research::MPConstraint *' at 0x1484a7900> >\n\n\nTo create the subtour elimination constraints \\(\\eqref{cvrp-two-index-cons4}\\), we first need to enumerate all the non-empty subset of \\(\\mathcal{N}\\), for which we define a helper function named get_all_combinations() in the CvrpDataCenter class. In the code snippet below, we define a separate constraint for every nonempty customer set \\(S\\), and the right-hand side \\(r(S)\\) is defined as \\(\\lceil {q(S) / Q} \\rceil\\).\n\n# create subtour elimination constraint\nnodes = cvrp_data_center.nodes\nvehicle_capacity = cvrp_data_center.vehicle_capacity\ncustomer_ids = [node.id for node in nodes if node.id > 0]\nnode_ids = [node.id for node in nodes]\nnonempty_customer_sets = cvrp_data_center.get_all_combinations(customer_ids)\nfor customer_set in nonempty_customer_sets:\n    others = set(node_ids).difference(customer_set)\n    expr = [var_x[i][j]\n            for i in customer_set\n            for j in others]\n    total_demand = sum([node.demand \n                        for node in nodes \n                        if node.id in set(customer_set)])\n    rhs = math.ceil(total_demand / vehicle_capacity)\n    solver.Add(solver.Sum(expr) >= rhs)\n\nPutting it all together, we have the complete program below. It can be seen from the output that the optimal solution is 450 and there are 8 routes in the identified solution.\n\nfrom ortools.linear_solver import pywraplp\nimport numpy as np\nfrom itertools import product\nimport math\n\n# prepare instance\ncvrp_data_center = CvrpDataCenter()\ncvrp_data_center.read_cvrp_instance(\"./data/cvrp/P-n16-k8.vrp\")\n\n# instantiate solver\nsolver = pywraplp.Solver.CreateSolver('SCIP')\n\n# create decision variables\nnum_nodes = cvrp_data_center.num_nodes\nnum_vehicles = cvrp_data_center.num_vehicles\nvar_x = np.empty((num_nodes, num_nodes), dtype=object)\nfor i, j in product(range(num_nodes), range(num_nodes)):\n    if i == j: continue\n    var_x[i][j] = solver.BoolVar(name=\"x_{i, j}\")\n\n# define objective function\nobj_expr = [\n    cvrp_data_center.distance(i, j, integer=True) * var_x[i][j]\n    for i, j in product(range(num_nodes), range(num_nodes))\n    if i != j\n]\nsolver.Minimize(solver.Sum(obj_expr))\n\n# create incoming and outgoing arc constraints\nfor i in range(1, num_nodes):\n    out_arcs = [var_x[i][j] for j in range(num_nodes) if j != i]\n    in_arcs = [var_x[j][i] for j in range(num_nodes) if j != i]\n    solver.Add(solver.Sum(out_arcs) == 1)\n    solver.Add(solver.Sum(in_arcs) == 1)\n\n# create fleet size constraint\nexpr = [var_x[0][i] for i in range(1, num_nodes)]\nsolver.Add(solver.Sum(expr) == num_vehicles)\n\n# create subtour elimination constraint\nnodes = cvrp_data_center.nodes\nvehicle_capacity = cvrp_data_center.vehicle_capacity\ncustomer_ids = [node.id for node in nodes if node.id > 0]\nnode_ids = [node.id for node in nodes]\nnonempty_customer_sets = cvrp_data_center.get_all_combinations(customer_ids)\nfor customer_set in nonempty_customer_sets:\n    others = set(node_ids).difference(customer_set)\n    expr = [var_x[i][j]\n            for i in customer_set\n            for j in others]\n    total_demand = sum([node.demand \n                        for node in nodes \n                        if node.id in set(customer_set)])\n    rhs = math.ceil(total_demand / vehicle_capacity)\n    solver.Add(solver.Sum(expr) >= rhs)\n    \nstatus = solver.Solve()\nif not status:\n    opt_obj = solver.Objective().Value()\n    print(f'optimal value: {opt_obj}')\n    \n    opt_x = np.zeros((num_nodes, num_nodes))\n    for i, j in product(range(num_nodes), range(num_nodes)):\n        if i == j: continue\n        opt_x[i][j] = int(var_x[i][j].solution_value())\n\n    routes = []\n    for i in range(1, num_nodes):\n        if opt_x[0][i] == 0: continue\n        # new route found\n        route = []\n        \n        route_length = 0\n        # add the first arc\n        arc_start = 0\n        arc_end = i\n        route.append((arc_start, arc_end))\n        route_length += cvrp_data_center.distance(arc_start, \n                                                arc_end, \n                                                integer=True)\n        \n        # add remaining arcs on the route\n        arc_start = arc_end\n        while True:\n            for j in range(num_nodes):\n                if opt_x[arc_start][j] == 1:\n                    arc_end = j\n                    break\n            route.append((arc_start, arc_end))\n            route_length += cvrp_data_center.distance(arc_start, \n                                                    arc_end, \n                                                    integer=True)\n            if arc_end == 0: break\n            arc_start = arc_end\n\n        routes.append(route)\n        print(f'route: {route}, length: {route_length}')\n\noptimal value: 450.0\nroute: [(0, 1), (1, 0)], length: 28\nroute: [(0, 2), (2, 0)], length: 42\nroute: [(0, 4), (4, 11), (11, 0)], length: 57\nroute: [(0, 5), (5, 9), (9, 3), (3, 0)], length: 93\nroute: [(0, 6), (6, 0)], length: 24\nroute: [(0, 10), (10, 12), (12, 15), (15, 0)], length: 67\nroute: [(0, 13), (13, 8), (8, 0)], length: 71\nroute: [(0, 14), (14, 7), (7, 0)], length: 68\n\n\nFigure 7.2 shows the routes found by the two-index formulation. Note that the routes are different from the ones in Figure 7.1 but they have the same objective value.\n\n\nCode\nlocations = {\n    node.id: (node.x_coord, node.y_coord)\n    for node in nodes\n}\n\nedges = []\nvehicle_idx = 0\nfor route in routes:\n    for arc in route:\n        edges.append((arc[0], arc[1], {'vehicle': str(vehicle_idx)}))\n    vehicle_idx += 1\nedges\n\nshow_vehicle_routes(locations, edges)\n\n\n\n\n\nFigure 7.2: Optimal routes found by the two-index formulation\n\n\n\n\nTo facilitate the model comparison in following steps, we’ll wrap the above program into a dedicated class CvrpTwoIndexModel1.\n\nfrom ortools.linear_solver import pywraplp\nfrom itertools import product\nimport numpy as np\nimport math\n\nclass CvrpTwoIndexModel1:\n    \"\"\"solve the cvrp model using the two index formulation\n    \"\"\"\n\n    def __init__(self, cvrp_data_center: CvrpDataCenter):\n        self._data_center: CvrpDataCenter = cvrp_data_center\n        self._solver = pywraplp.Solver.CreateSolver('SCIP')\n        self._var_x = None\n        \n        self._opt_obj = None\n        self._opt_x = None\n        self._opt_routes = None\n    \n    def read_instance(self, instance_file):\n        self._data_center.read_cvrp_instance(instance_file)\n\n    def build_model(self):\n        self._create_variables()\n        self._create_objective()\n        self._create_constr_flow()\n        self._create_constr_fleet()\n        self._create_constr_subtour()\n        \n    def optimize(self):\n        status = self._solver.Solve()\n        if not status:\n            self._retrieve_opt_solution()\n            self._retrieve_opt_routes()\n    \n    def _create_variables(self):\n        num_nodes = self._data_center.num_nodes\n        self._var_x = np.empty((num_nodes, num_nodes), dtype=object)\n        for i, j in product(range(num_nodes), range(num_nodes)):\n            if i == j: continue\n            self._var_x[i][j] = self._solver.BoolVar(name=\"x_{i, j}\")\n\n    def _create_objective(self):\n        num_nodes = self._data_center.num_nodes\n        obj_expr = [\n            self._data_center.distance(i, j, integer=True) * \n                self._var_x[i][j]\n                for i, j in product(range(num_nodes), range(num_nodes))\n                if i != j\n        ]\n        self._solver.Minimize(self._solver.Sum(obj_expr))\n            \n    def _create_constr_flow(self):\n        # create incoming and outgoing arc constraints\n        num_nodes = self._data_center.num_nodes\n        for i in range(1, num_nodes):\n            out_arcs = [self._var_x[i][j] for j in range(num_nodes) if j != i]\n            in_arcs = [self._var_x[j][i] for j in range(num_nodes) if j != i]\n            self._solver.Add(self._solver.Sum(out_arcs) == 1)\n            self._solver.Add(self._solver.Sum(in_arcs) == 1)\n            \n    def _create_constr_fleet(self):\n        # create fleet size constraint\n        num_nodes = self._data_center.num_nodes\n        num_vehicles = self._data_center.num_vehicles\n        expr = [self._var_x[0][i] for i in range(1, num_nodes)]\n        self._solver.Add(self._solver.Sum(expr) == num_vehicles)\n    \n    def _create_constr_subtour(self):\n        # create subtour elimination constraint\n        nodes = self._data_center.nodes\n        vehicle_capacity = self._data_center.vehicle_capacity\n        customer_ids = [node.id for node in nodes if node.id > 0]\n        node_ids = [node.id for node in nodes]\n        nonempty_customer_sets = self._data_center.get_all_combinations(customer_ids)\n        for customer_set in nonempty_customer_sets:\n            others = set(node_ids).difference(customer_set)\n            expr = [self._var_x[i][j]\n                    for i in customer_set\n                    for j in others]\n            total_demand = sum([node.demand \n                                for node in nodes \n                                if node.id in set(customer_set)])\n            rhs = math.ceil(total_demand / vehicle_capacity)\n            self._solver.Add(self._solver.Sum(expr) >= rhs)\n        print(f\"No. subtour elimination constraints: {len(nonempty_customer_sets)}\")\n    \n    def show_model_summary(self):\n        print(f\"No. of variables: {self._solver.NumVariables()}\")\n        print(f\"No. of constraints: {self._solver.NumConstraints()}\")\n    \n    def _retrieve_opt_solution(self):\n        self._opt_obj = self._solver.Objective().Value()\n        print(f'optimal value: {self._opt_obj}')\n        \n        num_nodes = self._data_center.num_nodes\n        self._opt_x = np.zeros((num_nodes, num_nodes))\n        for i, j in product(range(num_nodes), range(num_nodes)):\n            if i == j: continue\n            self._opt_x[i][j] = int(self._var_x[i][j].solution_value())\n\n    def _retrieve_opt_routes(self):\n        num_nodes = self._data_center.num_nodes\n        self._routes = []\n        for i in range(1, num_nodes):\n            if self._opt_x[0][i] == 0: continue\n            # new route found\n            route = []\n            \n            route_length = 0\n            # add the first arc\n            arc_start = 0\n            arc_end = i\n            route.append((arc_start, arc_end))\n            route_length += self._data_center\\\n                    .distance(arc_start, \n                            arc_end,\n                            integer=True)\n            \n            # add remaining arcs on the route\n            arc_start = arc_end\n            while True:\n                for j in range(num_nodes):\n                    if self._opt_x[arc_start][j] == 1:\n                        arc_end = j\n                        break\n                route.append((arc_start, arc_end))\n                route_length += self._data_center\\\n                    .distance(arc_start,\n                            arc_end,\n                            integer=True)\n                if arc_end == 0: break\n                arc_start = arc_end\n\n            self._routes.append(route)\n            print(f'route: {route}, length: {route_length}')\n\nThe code below validates that the same optimal solution is obtained using this object-oriented approach.\n\ncvrp_two_index_model_1 = CvrpTwoIndexModel1(CvrpDataCenter())\ncvrp_two_index_model_1.read_instance(\"./data/cvrp/P-n16-k8.vrp\")\ncvrp_two_index_model_1.build_model()\ncvrp_two_index_model_1.show_model_summary()\ncvrp_two_index_model_1.optimize()\n\nNo. subtour elimination constraints: 32767\nNo. of variables: 240\nNo. of constraints: 32798\noptimal value: 450.0\nroute: [(0, 1), (1, 0)], length: 28\nroute: [(0, 2), (2, 0)], length: 42\nroute: [(0, 4), (4, 11), (11, 0)], length: 57\nroute: [(0, 5), (5, 9), (9, 3), (3, 0)], length: 93\nroute: [(0, 6), (6, 0)], length: 24\nroute: [(0, 10), (10, 12), (12, 15), (15, 0)], length: 67\nroute: [(0, 13), (13, 8), (8, 0)], length: 71\nroute: [(0, 14), (14, 7), (7, 0)], length: 68\n\n\nIt can be seen from the model output that there are a total of 32798 constraints, out of which 32767 are subtour elimination constraints, even for such a small instance with only 15 customers. In the next section, we will present another two index formulation to handle this exponential number of constraints.\n\n\n7.0.0.4 Two-index Formulation - 2\n\n\n7.0.0.5 Three-index Formulation\nThis formulation is also known as the MTZ-formulation as a new set of constraints initially proposed for traveling salesman problem (Miller, Tucker, and Zemlin (1960)) is used to eliminate subtours.\n\n\n7.0.0.6 Commodity-flow Formulation\n\n\n\n\nCVRPLIB. 2014. “CVRPLIB.” http://vrp.galgos.inf.puc-rio.br/index.php/en/.\n\n\nLaporte, Gilbert, Hélène Mercure, and Yves Nobert. 1986. “An Exact Algorithm for the Asymmetrical Capacitated Vehicle Routing Problem.” Networks 16 (1): 33–46. https://doi.org/10.1002/net.3230160104.\n\n\nMiller, C. E., A. W. Tucker, and R. A. Zemlin. 1960. “Integer Programming Formulation of Traveling Salesman Problems.” Journal of the ACM 7 (4): 326–29. https://doi.org/10.1145/321043.321046.\n\n\nToth, Paolo, and Daniele Vigo. 2014. Vehicle Routing: Problems, Methods, and Applications. SIAM."
  },
  {
    "objectID": "column-generation.html",
    "href": "column-generation.html",
    "title": "8  Column Generation",
    "section": "",
    "text": "Column generation is a technique used in linear programming to solve problems with a large number of variables. Some classical/typical applications of column generation include:\nTransportation and distribution problems: Column generation can be used to optimize transportation and distribution networks by determining the most efficient routes for goods and services.\nCrew scheduling: Column generation is useful in determining optimal crew scheduling for airlines, railways, and other transportation companies.\nCutting stock problems: In the manufacturing industry, column generation can be used to optimize cutting stock problems by finding the best way to cut raw materials into smaller pieces to minimize waste.\nNetwork design: Column generation can be applied to network design problems, such as determining the optimal location of facilities in a supply chain network.\nVehicle routing: Column generation can be used to optimize vehicle routing problems, such as determining the best routes for delivery trucks or garbage trucks.\nResource allocation: Column generation can also be applied to resource allocation problems, such as scheduling employees or assigning tasks to machines in a production facility.\nOverall, column generation is a powerful technique that can be applied to a wide range of optimization problems."
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "9  Summary",
    "section": "",
    "text": "In summary, this book has no content whatsoever."
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Beasley, John E. 1990. “OR-Library: Distributing Test Problems by\nElectronic Mail.” Journal of the Operational Research\nSociety 41 (11): 1069–72.\n\n\nCVRPLIB. 2014. “CVRPLIB.” http://vrp.galgos.inf.puc-rio.br/index.php/en/.\n\n\nKondili, E, CC Pantelides, and R WH Sargent. 1988. “A\nGeneral Algorithm for Scheduling\nBatch Operations.” In. Barton, ACT. https://search.informit.org/doi/10.3316/informit.394925233030714.\n\n\nKu, Wen-Yang, and J. Christopher Beck. 2016. “Mixed\nInteger Programming Models for Job Shop\nScheduling: A Computational Analysis.” Computers\n& Operations Research 73 (September): 165–73. https://doi.org/10.1016/j.cor.2016.04.006.\n\n\nLaporte, Gilbert, Hélène Mercure, and Yves Nobert. 1986. “An Exact\nAlgorithm for the Asymmetrical Capacitated Vehicle Routing\nProblem.” Networks 16 (1): 33–46. https://doi.org/10.1002/net.3230160104.\n\n\nManne, Alan S. 1960. “On the Job-Shop\nScheduling Problem.” Operations\nResearch 8 (2): 219–23. https://doi.org/10.1287/opre.8.2.219.\n\n\nMiller, C. E., A. W. Tucker, and R. A. Zemlin. 1960. “Integer\nProgramming Formulation of\nTraveling Salesman\nProblems.” Journal of the ACM 7 (4):\n326–29. https://doi.org/10.1145/321043.321046.\n\n\nToth, Paolo, and Daniele Vigo. 2014. Vehicle Routing: Problems,\nMethods, and Applications. SIAM.\n\n\nWagner, Harvey M. 1959. “An Integer Linear-Programming Model for\nMachine Scheduling.” Naval Research Logistics Quarterly\n6 (2): 131–40. https://doi.org/10.1002/nav.3800060205."
  }
]