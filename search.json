[
  {
    "objectID": "index.html#for-the-impatient",
    "href": "index.html#for-the-impatient",
    "title": "Hands-on Optimization with OR-Tools in Python",
    "section": "For the Impatient",
    "text": "For the Impatient\nIf you have experience with other optimization tools and you are just looking for some OR-Tools code examples, the example formulation and implementation below should give you a jump start. The formulation is devoid of any practical meanings.\n\\[\\begin{align}\n    \\text{min.} &\\quad \\sum_{s \\in \\mathcal{S}} \\sum_{d \\in \\mathcal{D}} c_{sd} x_{sd} \\label{tp-obj} \\\\\n    \\text{s.t.} &\\quad \\sum_{d \\in \\mathcal{D}} x_{sd} = p_s, \\ \\forall s \\in \\mathcal{S} \\label{tp-cons1} \\\\\n    &\\quad \\sum_{s \\in \\mathcal{S}} x_{sd} = m_d, \\ \\forall d \\in \\mathcal{D} \\label{tp-cons2} \\\\\n    &\\quad x_{sd} \\geq 0, \\ \\forall s \\in \\mathcal{S}, d \\in \\mathcal{D} \\label{tp-cons3}\n\\end{align}\\]\nThe implementation in OR-Tools of the above model aims to convey a few information:\n\nA solver object has to be instantiated first in order to create variables, objective and constraints.\nNumerical variables can be created using the solver.NumVar() method.\nObjective is added using the solver.Minimize() (solver.Maximize()) function.\nConstraints are added using the solver.Add() function.\nObjective and constraint expressions can be built by first putting their elements into a list and using the solver.Sum() method to aggregate them.\n\n\nfrom ortools.linear_solver import pywraplp\n\n# gather data\nnum_sources = 4\nnum_destinations = 5\nsupplies = [58, 55, 64, 71]\ndemands = [44, 28, 36, 52, 88]\ncosts = [[8, 5, 13, 12, 12], \n        [8, 7, 18, 6, 5], \n        [11, 12, 5, 11, 18], \n        [19, 13, 5, 10, 18]]\n\n# create solver\nsolver = pywraplp.Solver.CreateSolver(\"GLOP\")\n\n# create decision variables\nvar_flow = []\nfor src_idx in range(num_sources):\n    vars = [\n        solver.NumVar(0, solver.Infinity(), \n                    name=f\"var_{src_idx}, {dest_idx}\")\n        for dest_idx in range(num_destinations)\n    ]\n    var_flow.append(vars)\n\n# create constraints\nfor src_idx in range(num_sources):\n    expr = [var_flow[src_idx][dest_idx] \n            for dest_idx in range(num_destinations)]\n    solver.Add(solver.Sum(expr) == supplies[src_idx])\n\nfor dest_idx in range(num_destinations):\n    expr = [var_flow[src_idx][dest_idx] \n            for src_idx in range(num_sources)]\n    solver.Add(solver.Sum(expr) == demands[dest_idx])\n\n# create objective function\nobj_expr = []\nfor src_idx in range(num_sources):\n    for dest_idx in range(num_destinations):\n        obj_expr.append(var_flow[src_idx][dest_idx] * costs[src_idx][dest_idx])\nsolver.Minimize(solver.Sum(obj_expr))\n\nstatus = solver.Solve()\n\nopt_flow = []\nif status == pywraplp.Solver.OPTIMAL:\n    print(f\"optimal obj = {solver.Objective().Value()}\")\n    for src_idx in range(num_sources):\n        opt_vals = [var_flow[src_idx][dest_idx].solution_value()\n                    for dest_idx in range(num_destinations)]\n        opt_flow.append(opt_vals)"
  },
  {
    "objectID": "preface.html",
    "href": "preface.html",
    "title": "Preface",
    "section": "",
    "text": "Dear Reader,\nIf you’re reading this preface, then congratulations! You’ve either stumbled upon this book accidentally, or you’re one of the select few who shares my passion for optimization problems and solving them with Google OR-Tools. Either way, welcome!\nFirst things first, let me start by saying that writing a book is hard. Like, really hard. There were times when I thought I would never finish this darn thing. But then I reminded myself of why I started in the first place: I wanted to become an expert in Google OR-Tools and share that expertise with a broader audience. Plus, it was a great excuse to avoid doing laundry for weeks on end.\nNow, I’m not going to lie to you. If you’re not a fan of math, algorithms, or Python, then this book may not be for you. But if you’re anything like me, and you get a thrill out of finding the optimal solution to a complex problem, then buckle up! We’re about to embark on an adventure of optimization, constraints, and fancy algorithms.\nThroughout this book, we’ll cover everything from basic linear programming to more advanced metaheuristics. And trust me, we’ll have fun along the way. There will be laughter, tears (mostly from debugging errors), and hopefully a few “aha!” moments.\nIn all seriousness, I wrote this book because I believe that Google OR-Tools is an incredibly powerful tool for solving real-world optimization problems, and I want to share that knowledge with you. So, grab a cup of coffee (or tea, if you’re fancy like that) and let’s dive in!\nYours in optimization,\nKunlei Lian"
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Introduction",
    "section": "",
    "text": "This book covers the usage of Google OR-Tools to solve optimization problems in Python. There are several major chapters in this book:\nIn Chapter 2, we explain the steps needed to setup OR-Tools in a Python environment.\nIn Chapter 3, we use an example to illustrate the modeling capability of OR-Tools to solve linear programming problems.\nIn Chapter 4, we go through the modeling techniques made available in OR-Tools."
  },
  {
    "objectID": "env-setup.html#install-homebrew",
    "href": "env-setup.html#install-homebrew",
    "title": "2  Environment Setup",
    "section": "2.1 Install Homebrew",
    "text": "2.1 Install Homebrew\nThe first tool we need is Homebrew, ‘the Missing Package Manager for macOS (or Linux)’, and it can be accessed at https://brew.sh/. To install Homebrew, just copy the command below and run it in the Terminal.\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\nWe can then use the brew --version command to check the installed version. On my system, it shows the info below.\n ~/ brew --version\nHomebrew 3.6.20\nHomebrew/homebrew-core (git revision 5f1582e4d55; last commit 2023-02-05)\nHomebrew/homebrew-cask (git revision fa3b8a669d; last commit 2023-02-05)"
  },
  {
    "objectID": "env-setup.html#install-anaconda",
    "href": "env-setup.html#install-anaconda",
    "title": "2  Environment Setup",
    "section": "2.2 Install Anaconda",
    "text": "2.2 Install Anaconda\nSince there are several Python versions available for our use and we may end up having multiple Python versions installed on our machine, it is important to use a consistent environment to work on our project in. Anaconda is a package and environment manager for Python and it provides easy-to-use tools to facilitate our data science needs. To install Anaconda, run the below command in the Terminal.\n ~/ brew install anaconda\nAfter the installation is done, we can use conda --version to verify whether it is available on our machine or not.\n ~/ conda --version\nconda 23.1.0"
  },
  {
    "objectID": "env-setup.html#create-a-conda-environment",
    "href": "env-setup.html#create-a-conda-environment",
    "title": "2  Environment Setup",
    "section": "2.3 Create a Conda Environment",
    "text": "2.3 Create a Conda Environment\nNow we will create a Conda environment named ‘ortools’. Execute the below command in the Terminal, which effectively creates the required environment with Python version 3.10.\n ~/ conda create -n ortools python=3.10\nRetrieving notices: ...working... done\nCollecting package metadata (current_repodata.json): done\nSolving environment: done\n\n## Package Plan ##\n\n  environment location: /opt/homebrew/anaconda3/envs/test\n\n  added / updated specs:\n    - python=3.10\n\n\nThe following packages will be downloaded:\n\n    package                    |            build\n    ---------------------------|-----------------\n    setuptools-67.4.0          |     pyhd8ed1ab_0         567 KB  conda-forge\n    ------------------------------------------------------------\n                                           Total:         567 KB\n\nThe following NEW packages will be INSTALLED:\n\n  bzip2              conda-forge/osx-arm64::bzip2-1.0.8-h3422bc3_4\n  ca-certificates    conda-forge/osx-arm64::ca-certificates-2022.12.7-h4653dfc_0\n  libffi             conda-forge/osx-arm64::libffi-3.4.2-h3422bc3_5\n  libsqlite          conda-forge/osx-arm64::libsqlite-3.40.0-h76d750c_0\n  libzlib            conda-forge/osx-arm64::libzlib-1.2.13-h03a7124_4\n  ncurses            conda-forge/osx-arm64::ncurses-6.3-h07bb92c_1\n  openssl            conda-forge/osx-arm64::openssl-3.0.8-h03a7124_0\n  pip                conda-forge/noarch::pip-23.0.1-pyhd8ed1ab_0\n  python             conda-forge/osx-arm64::python-3.10.9-h3ba56d0_0_cpython\n  readline           conda-forge/osx-arm64::readline-8.1.2-h46ed386_0\n  setuptools         conda-forge/noarch::setuptools-67.4.0-pyhd8ed1ab_0\n  tk                 conda-forge/osx-arm64::tk-8.6.12-he1e0b03_0\n  tzdata             conda-forge/noarch::tzdata-2022g-h191b570_0\n  wheel              conda-forge/noarch::wheel-0.38.4-pyhd8ed1ab_0\n  xz                 conda-forge/osx-arm64::xz-5.2.6-h57fd34a_0\n\n\nProceed ([y]/n)?\nType ‘y’ to proceed and Conda will create the environment for us. We can use cnoda env list to show all the created environments on our machine:\n ~/ conda env list\n# conda environments:\n#\nbase                     /opt/homebrew/anaconda3\nortools                   /opt/homebrew/anaconda3/envs/ortools\nNote that we need to manually activate an environemnt in order to use it: conda activate ortools. On my machine, the activated environment ortools will appear in the beginning of my prompt.\n ~/ conda activate ortools\n(ortools)  ~/"
  },
  {
    "objectID": "env-setup.html#install-google-or-tools",
    "href": "env-setup.html#install-google-or-tools",
    "title": "2  Environment Setup",
    "section": "2.4 Install Google OR-Tools",
    "text": "2.4 Install Google OR-Tools\nAs of this writing, the latest version of Google OR-Tools is 9.5.2237, and we can install it in our newly created environment using the command pip install ortools==9.5.2237. We can use conda list to verify whether it is available in our environment.\n(ortools)  ~/ conda list\n# packages in environment at /opt/homebrew/anaconda3/envs/ortools:\n#\n# Name                    Version                   Build  Channel\nabsl-py                   1.4.0                    pypi_0    pypi\nbzip2                     1.0.8                h3422bc3_4    conda-forge\nca-certificates           2022.12.7            h4653dfc_0    conda-forge\nlibffi                    3.4.2                h3422bc3_5    conda-forge\nlibsqlite                 3.40.0               h76d750c_0    conda-forge\nlibzlib                   1.2.13               h03a7124_4    conda-forge\nncurses                   6.3                  h07bb92c_1    conda-forge\nnumpy                     1.24.2                   pypi_0    pypi\nopenssl                   3.0.8                h03a7124_0    conda-forge\nortools                   9.5.2237                 pypi_0    pypi\npip                       23.0.1             pyhd8ed1ab_0    conda-forge\nprotobuf                  4.22.0                   pypi_0    pypi\npython                    3.10.9          h3ba56d0_0_cpython    conda-forge\nreadline                  8.1.2                h46ed386_0    conda-forge\nsetuptools                67.4.0             pyhd8ed1ab_0    conda-forge\ntk                        8.6.12               he1e0b03_0    conda-forge\ntzdata                    2022g                h191b570_0    conda-forge\nwheel                     0.38.4             pyhd8ed1ab_0    conda-forge\nxz                        5.2.6                h57fd34a_0    conda-forge\nNow we have Python and Google OR-Tools ready, we can start our next journey."
  },
  {
    "objectID": "linear-programming.html#modeling-capabilities",
    "href": "linear-programming.html#modeling-capabilities",
    "title": "3  Linear Programming",
    "section": "3.1 Modeling Capabilities",
    "text": "3.1 Modeling Capabilities\nThere are three components in a mathematical model, namely, decision varaibles, constraints and objective, for which we will go over in the following sections.\n\n3.1.1 Solver\nIn Google OR-Tools, a Solver instance must be created first so that variables, constraints and objective can be added to it. The Solver class is defined in the ortools.linear_solver.pywraplp module and it requires a solver id to instantiate an object. In the code snippet below, the required module is imported first and a solver object is created with GLOP, Google’s own optimization engine for solving linear programming problems. It is good practice to verify whether the desired solver is indeed created successfully or not.\n\nfrom ortools.linear_solver import pywraplp\n\nsolver = pywraplp.Solver.CreateSolver(\"GLOP\")\n\nif solver:\n    print(\"solver creation success!\")\nelse:\n    print(\"solver creation failure!\")\n\nsolver creation success!\n\n\n\n\n3.1.2 Decision Variables\nThe Solver class defines a number of ways to create decision variables:\n\nVar(lb, ub, integer, name)\nNumVar(lb, ub, name)\nIntVar(lb, ub, name)\nBoolVar(name)\n\n\nFunction Var()\n\nThe Var() method is the most flexible way to define variables, as it can be used to create numerical, integral and boolean variables. In the following code, a numerical variable named ‘var1’ is created with bound (0.0, 1.0). Note that the parameter integer is set to False in the call to function Var().\n\nvar1 = solver.Var(lb=0, ub=1.0, integer=False, name=\"var1\")\n\nWe could create an integer variable using the same function:\n\nvar2 = solver.Var(lb=0, ub=1.0, integer=True, name=\"var2\")\n\n\nFunction NumVar()\n\nvar1 could be creatd alternatively using the specialized function NumVar():\n\nvar1 = solver.NumVar(lb=0, ub=1.0, name=\"var1\")\n\n\nFunction IntVar()\n\nSimilarly, var2 could be created alternatively using the specialized function IntVar():\n\nvar2 = solver.IntVar(lb=0, ub=1.0, name=\"var2\")\n\n\nFunction BoolVar()\n\nA boolean variable could be created using the BoolVar() function:\n\nvar3 = solver.BoolVar(name=\"var3\")\n\n\n\n3.1.3 Constraints\nConstraints limit the solution space of an optimization problem, and there are two ways to define constraints in Google OR-Tools. In the first approach, we could use the Add() function to create a constraint and automatically add it to the model at the same time, as the below code snippet illustrates.\n\ncons1 = solver.Add(constraint=var1 + var2 &lt;= 1, name=\"cons1\")\n\ntype(cons1)\n\nortools.linear_solver.pywraplp.Constraint\n\n\nNote that the Add() function returns an object of the Constraint class defined in the pywraplp module, as shown in the code output. It is a good practice to retain the reference of the newly created constraint, as we might want to query its information later on.\nThe second approach works in a slightly different way. It starts with an empty constraint, with potential lower bound and upper bounds provided, and add components of the constraint gradually. The code snippet below shows an example of adding a second constraint to the model. In this approach, we must retain the reference to the constraint, as it is needed to add decision variables to the constraint in following steps.\n\ncons2 = solver.Constraint(-solver.infinity(), 10.0, \"cons2\")\ncons2.SetCoefficient(var1, 2)\ncons2.SetCoefficient(var2, 3)\ncons2.SetCoefficient(var3, 4)\ntype(cons2)\n\nortools.linear_solver.pywraplp.Constraint\n\n\n\n\n3.1.4 Objective\nSimilar to constraints, there are two ways to define the objective in Google OR-Tools. In the first approach, we directly add an objective to the model by using the Maximize() or Minimize() function. Below is an example:\n\nsolver.Minimize(var1 + var2 + var3)\n\nNote that the function itself does not return a reference to the newly created objective function, but we could use a dedicated function to retrive it:\n\nobj = solver.Objective()\nprint(obj)\n\n&lt;ortools.linear_solver.pywraplp.Objective; proxy of &lt;Swig Object of type 'operations_research::MPObjective *' at 0x10f1e92c0&gt; &gt;\n\n\nIn the second approach, we build the objective incrementally, just as in the second approach of creating constraints. Specifically, we start with an empty objective function, and gradually add components to it. In the end, we specify the optimization sense - whether we want to maximize or minimnize the objective.\n\nobj = solver.Objective()\nobj.SetCoefficient(var1, 1.0)\nobj.SetCoefficient(var2, 1.0)\nobj.SetCoefficient(var3, 1.0)\nobj.SetMinimization()\nprint(obj)\n\n&lt;ortools.linear_solver.pywraplp.Objective; proxy of &lt;Swig Object of type 'operations_research::MPObjective *' at 0x10fc86670&gt; &gt;\n\n\n\n\n3.1.5 Objective and Constraint Expressions\nWhen we build constraints or objective functions, sometimes they comprise of complex expressions that we would like to build incrementally, possibly within loops. For example, we might have a mathematical expression of the form \\(expr = 2x_1 + 3x_2 + 4x_3 + x_4\\), which could be part of the objective function or any constraints. In this case, we can either use the aforementioned SetCoefficient() function to add each element of the expression to the constraint or objective, or we could build an expression first and add it once in the end. The code snippet below shows an example.\n\ninfinity = solver.Infinity()\nx1 = solver.NumVar(0, infinity, name=\"x1\")\nx2 = solver.NumVar(0, infinity, name=\"x2\")\nx3 = solver.NumVar(0, infinity, name=\"x3\")\nx4 = solver.NumVar(0, infinity, name=\"x4\")\n\nexpr = []\nexpr.append(2 * x1)\nexpr.append(3 * x2)\nexpr.append(4 * x3)\nexpr.append(x4)\n\nconstr = solver.Add(solver.Sum(expr) &lt;= 10)\nprint(constr)\n\nsolver.Minimize(solver.Sum(expr))\n\n&lt;ortools.linear_solver.pywraplp.Constraint; proxy of &lt;Swig Object of type 'operations_research::MPConstraint *' at 0x10fcb3060&gt; &gt;\n\n\nOf course, it is not obvious here that the retitive calls to the append() method are any more convenient than the SetCoefficient() method. Let’s say that we have a slightly more complex expression of the form \\(\\sum_{0 \\le i &lt; 4}w_i \\cdot x_i\\), now we could build the expression using a loop:\n\nw = [2, 3, 4, 1]\nx = [x1, x2, x3, x4]\nexpr = []\nfor i in range(4):\n    expr.append(w[i] * x[i])\n\nconstr = solver.Add(solver.Sum(expr) &lt;= 10)\n\n\n\n3.1.6 Query the Model\nAfter we build the model, we can query it using some helper functions. For example, to get the total number of constraints, we use the NumVariables() function. In a similar fashion, we can retrieve the total number of constraints with the NumConstraints() function.\n\nnum_vars = solver.NumVariables()\nprint(f\"there are a total of {num_vars} variables in the model\")\n\nnum_constr = solver.NumConstraints()\nprint(f\"there are a total of {num_constr} constraints in the model\")\n\nthere are a total of 9 variables in the model\nthere are a total of 4 constraints in the model"
  },
  {
    "objectID": "linear-programming.html#applications",
    "href": "linear-programming.html#applications",
    "title": "3  Linear Programming",
    "section": "3.2 Applications",
    "text": "3.2 Applications\nIn this section, we use some examples to showcase the modeling capability of Google OR-Tools.\n\n3.2.1 Trivial Problem\nWe now consider an simple linear programming problem with two decision variables \\(x\\) and \\(y\\). The formal mathematical model is defined as below:\n\\[\\begin{align}\n\\text{max.} \\quad & x + 2y \\\\\n\\text{s.t.} \\quad & x + y \\le 10 \\\\\n& x &gt;= 1 \\\\\n& y &gt;= 1\n\\end{align}\\]\nFigure 3.1 shows the three defining constraints represented in blue lines and the feasible space depicted by the orange shaded area. The objective function is indicated by the red dashed lines. It can be seen from the figure that the point in green circle gives the maximal objective value of 19.\n\n\n\n\n\nFigure 3.1: A simple LP example\n\n\n\n\nLet’s now use Google OR-Tools to model and solve this problem. The code snippet below shows the complete program.\n\n# import Google OR-Tools library\nfrom ortools.linear_solver import pywraplp\n\n# create a solver\nsolver = pywraplp.Solver.CreateSolver(\"GLOP\")\n\n# create decision variables\nx = solver.NumVar(1.0, solver.Infinity(), \"x\")\ny = solver.NumVar(1.0, solver.Infinity(), \"y\")\n\n# create constraints\nconstr = solver.Add(x + y &lt;= 10)\n\n# create objective\nsolver.Maximize(x + 2 * y)\n\n# solve the problem\nstatus = solver.Solve()\n\nif status == pywraplp.Solver.OPTIMAL or status == pywraplp.Solver.FEASIBLE:\n    print(f\"obj = {solver.Objective().Value()}\")\n    print(f\"x = {x.solution_value()}, reduced cost = {x.reduced_cost()}\")\n    print(f\"y = {y.solution_value()}, reduced cost = {y.reduced_cost()}\")\n    print(f\"constr dual value = {constr.dual_value()}\")\n\nobj = 19.0\nx = 1.0, reduced cost = -1.0\ny = 9.0, reduced cost = 0.0\nconstr dual value = 2.0\n\n\nWe can see from the output that the optimal solution is \\(x = 1.0\\) and \\(y = 9.0\\), and the optimal objective is 19.0. This can also be validated from Figure 3.1 that the optimal solution is exactly the green point that sits at the intersection of the three lines \\(x = 1\\), \\(x + y = 10\\) and \\(x + 2y = 19\\).\nFigure 3.1 also shows that the point (1, 1) should give us the minimal value of the objective function. To validate this, we can actually change the optimization sense of the objective function from maximization to minimization using the function SetOptimizationDirection(), as shown in the code below:\n\nsolver.Objective().SetOptimizationDirection(maximize=False)\n\nsolver.Solve()\n\nprint(f\"obj = {solver.Objective().Value()}\")\nprint(f\"x = {x.solution_value()}, reduced cost = {x.reduced_cost()}\")\nprint(f\"y = {y.solution_value()}, reduced cost = {y.reduced_cost()}\")\nprint(f\"constr dual value = {constr.dual_value()}\")\n\nobj = 3.0\nx = 1.0, reduced cost = 1.0\ny = 1.0, reduced cost = 2.0\nconstr dual value = 0.0\n\n\n\n\n3.2.2 Transportation Problem\nThe transportation problem involves moving goods from its sources \\(\\mathcal{S}\\) to destinations \\(\\mathcal{D}\\). Each source \\(s \\in \\mathcal{S}\\) has a total amount of goods \\(p_s\\) it could supply, and each destination \\(s \\in \\mathcal{D}\\) has a certain amount of demands \\(m_d\\). There is a transportation cost, denoted by \\(c_{sd}\\), to move one unit of goods from a source to a destination. The problem is to find the best set of goods to move from each source to each destination such that all the destination demands are met with the lowest transportation costs.\nTo model this transportation problem, we define the decision variable \\(x_{sd}\\) to be the amount of goods moving from source \\(s\\) to destinaiton \\(d\\). Then we could state the problem mathematically as below.\n\\[\\begin{align}\n\\text{min.} &\\quad \\sum_{s \\in \\mathcal{S}} \\sum_{d \\in \\mathcal{D}} c_{sd} x_{sd} \\label{tp-obj} \\\\\n\\text{s.t.} & \\quad \\sum_{d \\in \\mathcal{D}} x_{sd} = p_s, \\ \\forall s \\in \\mathcal{S} \\label{tp-cons1} \\\\\n& \\sum_{s \\in \\mathcal{S}} x_{sd} = m_d, \\ \\forall d \\in \\mathcal{D} \\label{tp-cons2} \\\\\n& x_{sd} \\geq 0, \\ \\forall s \\in \\mathcal{S}, d \\in \\mathcal{D} \\label{tp-cons3}\n\\end{align}\\]\nThe objective function \\(\\eqref{tp-obj}\\) aims to minimize the total transportation costs going from all sources to all destinations. Constraints \\(\\eqref{tp-cons1}\\) make sure that the sum of goods leaving a source node \\(s\\) must equal to its available supply \\(p_s\\). Constraints \\(\\eqref{tp-cons2}\\) require that the sum of goods gonig to a destination node \\(d\\) must equal to its demand \\(m_d\\). Constraints \\(\\eqref{tp-cons3}\\) state that the flow variables from sources to destination can only be nonnegative values.\nTable 3.1 shows an instance of the transportation problem in which there are four sources and five destinations. Entries in the last row give the corresponding demand from each destination, and the last column list the available supply at each source. The entries in the middle of the table show the transportation cost associated with moving from a specific source to a specific destination. For example, it costs $18 to move one unit of good from source S2 to D3.\n\n\n\n\nTable 3.1: A transportation problem\n\n\n\nD1\nD2\nD3\nD4\nD5\nSupply\n\n\n\n\nS1\n8\n5\n13\n12\n12\n58\n\n\nS2\n8\n7\n18\n6\n5\n55\n\n\nS3\n11\n12\n5\n11\n18\n64\n\n\nS4\n19\n13\n5\n10\n18\n71\n\n\nDemand\n44\n28\n36\n52\n88\n248\n\n\n\n\n\n\nWe show here two modeling flavors of using OR-Tools to solve this problem. In the first approach, decision variables are created using the NumVar() function, cnostraints are defined using the Add() function and the objective function is added using the Minimize() function. Note that both constraints and the objective function are generated with the help of of Sum() function that creates an expression.\n\nfrom ortools.linear_solver import pywraplp\n\n# gather data\nnum_sources = 4\nnum_destinations = 5\nsupplies = [58, 55, 64, 71]\ndemands = [44, 28, 36, 52, 88]\ncosts = [[8, 5, 13, 12, 12], \n        [8, 7, 18, 6, 5], \n        [11, 12, 5, 11, 18], \n        [19, 13, 5, 10, 18]]\n\n# create solver\nsolver = pywraplp.Solver.CreateSolver(\"GLOP\")\n\n# create decision variables\nvar_flow = []\nfor src_idx in range(num_sources):\n    vars = [\n        solver.NumVar(0, solver.Infinity(), \n                    name=f\"var_{src_idx}, {dest_idx}\")\n        for dest_idx in range(num_destinations)\n    ]\n    var_flow.append(vars)\n\n# create constraints\nfor src_idx in range(num_sources):\n    expr = [var_flow[src_idx][dest_idx] \n            for dest_idx in range(num_destinations)]\n    solver.Add(solver.Sum(expr) == supplies[src_idx])\n\nfor dest_idx in range(num_destinations):\n    expr = [var_flow[src_idx][dest_idx] \n            for src_idx in range(num_sources)]\n    solver.Add(solver.Sum(expr) == demands[dest_idx])\n\n# create objective function\nobj_expr = []\nfor src_idx in range(num_sources):\n    for dest_idx in range(num_destinations):\n        obj_expr.append(var_flow[src_idx][dest_idx] * costs[src_idx][dest_idx])\nsolver.Minimize(solver.Sum(obj_expr))\n\nstatus = solver.Solve()\n\nopt_flow = []\nif status == pywraplp.Solver.OPTIMAL:\n    print(f\"optimal obj = {solver.Objective().Value()}\")\n    for src_idx in range(num_sources):\n        opt_vals = [var_flow[src_idx][dest_idx].solution_value()\n                    for dest_idx in range(num_destinations)]\n        opt_flow.append(opt_vals)\n\noptimal obj = 2013.0\n\n\nThe optimal solution is shown in Table 3.2.\n\n\n\n\nTable 3.2: The optimal solution\n\n\n\nD1\nD2\nD3\nD4\nD5\nSupply\n\n\n\n\nS1\n0\n28\n0\n0\n30\n58\n\n\nS2\n0\n0\n0\n0\n55\n55\n\n\nS3\n44\n0\n20\n0\n0\n64\n\n\nS4\n0\n0\n16\n52\n3\n71\n\n\nDemand\n44\n28\n36\n52\n88\n248\n\n\n\n\n\n\nIn the second approach shown in the code snippet below, decision variables are created with the Var(integer=False) method instead of the NumVar() method. In addition, both constraints and the objective function are created using the SetCoefficient() method. In the case of constraints, a lower bound and upper bound are used to generated an empty constraint, and variables are then added to the constraint one by one with their corresponding coefficient. In the case of the objective function, an empty objective is first initialized and variables are then added to it sequentially. Note that the optimization sense is set using the SetMinimization() function.\n\nfrom ortools.linear_solver import pywraplp\n\n# gather data\nnum_sources = 4\nnum_destinations = 5\nsupplies = [58, 55, 64, 71]\ndemands = [44, 28, 36, 52, 88]\ncosts = [[8, 5, 13, 12, 12], \n        [8, 7, 18, 6, 5], \n        [11, 12, 5, 11, 18],\n        [19, 13, 5, 10, 18]]\n\n# create solver\nsolver = pywraplp.Solver.CreateSolver(\"GLOP\")\n\n# create decision variables\nvar_flow = []\nfor src_idx in range(num_sources):\n    vars = [\n        solver.Var(\n            0, solver.Infinity(), integer=False, \n            name=f\"var_{src_idx}, {dest_idx}\"\n        )\n        for dest_idx in range(num_destinations)\n    ]\n    var_flow.append(vars)\n\n# create constraints\nfor src_idx in range(num_sources):\n    constr = solver.Constraint(supplies[src_idx], supplies[src_idx])\n    for dest_idx in range(num_destinations):\n        constr.SetCoefficient(var_flow[src_idx][dest_idx], 1.0)\n\nfor dest_idx in range(num_destinations):\n    constr = solver.Constraint(demands[dest_idx], demands[dest_idx])\n    for src_idx in range(num_sources):\n        constr.SetCoefficient(var_flow[src_idx][dest_idx], 1.0)\n\n# create objective function\nobj = solver.Objective()\nfor src_idx in range(num_sources):\n    for dest_idx in range(num_destinations):\n        obj.SetCoefficient(var_flow[src_idx][dest_idx], costs[src_idx][dest_idx])\nobj.SetMinimization()\n\nstatus = solver.Solve()\n\nopt_flow = []\nif status == pywraplp.Solver.OPTIMAL:\n    print(f\"optimal obj = {solver.Objective().Value()}\")\n    for src_idx in range(num_sources):\n        opt_vals = [var_flow[src_idx][dest_idx].solution_value()\n                    for dest_idx in range(num_destinations)]\n        opt_flow.append(opt_vals)\n\noptimal obj = 2013.0\n\n\nTo validate the results, Table 3.3 shows the optimal solution produced by the second modeling approach, which is the same as in the previous approach.\n\n\n\n\nTable 3.3: The optimal solution\n\n\n\nD1\nD2\nD3\nD4\nD5\nSupply\n\n\n\n\nS1\n0\n28\n0\n0\n30\n58\n\n\nS2\n0\n0\n0\n0\n55\n55\n\n\nS3\n44\n0\n20\n0\n0\n64\n\n\nS4\n0\n0\n16\n52\n3\n71\n\n\nDemand\n44\n28\n36\n52\n88\n248\n\n\n\n\n\n\n\n\n3.2.3 Resource Allocation Problem\nThe resource allocation problems involves distributing scarce resources among alternative activities. The resources could be machines in a manufacturing facility, money available to spend, or CPU runtime. The activities could be anything that brings profit at the cost of consuming resources. The objective of this problem is therefore to allocate the available resources to activities such that the total profit is maximized.\nHere, we give a general resource allocation model devoid of any practical meanings. To this end, we define a few input parameters to this problem:\n\n\\(\\mathcal{A}\\): the set of candidate activities\n\\(\\mathcal{R}\\): the set of avaiable resources\n\\(p_a\\): the profit of performing one unit of activity \\(a \\in \\mathcal{A}\\)\n\\(c_{ar}\\): the amount of resource \\(r \\in \\mathcal{R}\\) required by one unit of activity \\(a \\in \\mathcal{A}\\)\n\\(b_r\\): the total amount of available quantities for resource \\(r \\in \\mathcal{R}\\)\n\nThe decision variable \\(x_a\\) represents the amount of activity \\(a \\in \\mathcal{A}\\) we select to perform, and the mathematical mode is defined below:\n\\[\\begin{align}\n\\text{max.} &\\quad \\sum_{a \\in \\mathcal{A}} p_a x_a \\label{ra-obj} \\\\\n\\text{s.t.} & \\quad \\sum_{a \\in \\mathcal{A}} c_{ar} \\leq b_r, \\ \\forall r \\in \\mathcal{R} \\label{ra-cons1} \\\\\n& x_a \\geq 0, \\ a \\in \\mathcal{A}\n\\end{align}\\]\nTable 3.4 shows an instance of the resource allocation problem, in which there are three type of resources and five candidate activities. The last row gives the profit of performing each unit of an activity, while the last column shows the available amount of resources. The remaining entries in the table refer to the resource consumption for each activity. For example, selecting one unit of activity 1 (A1) requires 90, 64 and 55 units of resources R1, R2 and R3, respectively.\n\n\n\n\nTable 3.4: A resource allocation problem\n\n\n\nA1\nA2\nA3\nA4\nA5\nAvailable\n\n\n\n\nR1\n90\n57\n51\n97\n67\n2001\n\n\nR2\n64\n58\n97\n56\n93\n2616\n\n\nR3\n55\n87\n77\n52\n51\n1691\n\n\nProfit\n1223\n1238\n1517\n1616\n1027\n\n\n\n\n\n\n\nIn the code snippet below, we use Google OR-Tools to solve this problem instance. Again, we start with initializing a solver object, follwed by creation of five decision variables, one for each activity. Both the constraints and objective function are created using the first modeling approach demonstrated previously. The optimal solution is outputed in the end.\n\nfrom ortools.linear_solver import pywraplp\n\n# gather instance data\nnum_resources = 3\nnum_activities = 5\nprofits = [1223, 1238, 1517, 1616, 1027]\navailable_resources = [2001, 2616, 1691]\ncosts = [[90, 57, 51, 97, 67],\n        [64, 58, 97, 56, 93],\n        [55, 87, 77, 52, 51]]\n\n# initialize a solver object\nsolver = pywraplp.Solver.CreateSolver(\"GLOP\")\n\ninfinity = solver.Infinity()\n# create decision variables\nvar_x = [solver.NumVar(0, infinity, name=f\"x_P{a}\") \n        for a in range(num_activities)]\n\n# create objective function\nsolver.Maximize(solver.Sum([profits[a] * var_x[a] \n                            for a in range(num_activities)]))\n\n# create constraints\nfor r_idx in range(num_resources):\n    cons = solver.Add(\n            solver.Sum([costs[r_idx][a_idx] * var_x[a_idx] \n                        for a_idx in range(num_activities)]) \n                      &lt;= available_resources[r_idx])\n    \nstatus = solver.Solve()\nif status != pywraplp.Solver.OPTIMAL:\n    print(\"solver failure!\")\n\nprint(\"solve complete!\")\nopt_obj = solver.Objective().Value()\nprint(f\"optimal obj = {opt_obj:.2f}\")\n\nopt_sol = [var_x[a_idx].solution_value() \n           for a_idx in range(num_activities)]\nfor a_idx in range(num_activities):\n    print(f\"opt_x[{a_idx + 1}] = {opt_sol[a_idx]:.2f}\")\n\nsolve complete!\noptimal obj = 41645.23\nopt_x[1] = 0.00\nopt_x[2] = 0.00\nopt_x[3] = 12.45\nopt_x[4] = 14.08\nopt_x[5] = 0.00\n\n\n\n\n3.2.4 Workforce Planning Problem\nIn the workforce planning problem, there are a number of time periods and each period has a workforce requirement that must be satisfied. In addition, there are a set of available work patterns to assign workers to and each pattern cover one or more time periods. Note that assignment of workers to a particular pattern incurs a certain cost. The problem is then to identify the number of workers assigned to each pattern such that the total cost is minimized.\nTable 3.5 shows a contrived workforce planning problem instance. In this problem, there are a total of 10 time periods and there are four patterns available to assign workers to. The last row gives the work requirement in each time period and the last column shows the cost of assigning a worker to a pattern.\n\n\nTable 3.5: A workforce planning problem instance\n\n\nCoverage\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\nCost\n\n\n\n\nPattern 1\nx\nx\nx\nx\n\n\n\n\n\n\n10\n\n\nPattern 2\n\n\nx\nx\nx\n\n\n\n\n\n30\n\n\nPattern 3\n\n\n\nx\nx\nx\nx\n\n\n\n20\n\n\nPattern 4\n\n\n\n\n\n\nx\nx\nx\nx\n40\n\n\nRequirement\n3\n4\n3\n1\n5\n7\n2\n4\n5\n1\n\n\n\n\n\nTo model this problem, we use \\(\\mathcal{T}\\) and \\(\\mathcal{P}\\) to denote the set of time periods and patterns, respectively. The parameter \\(m_{pt}\\) indicates whether a pattern \\(p \\in \\mathcal{P}\\) covers a certain time period \\(t \\in \\mathcal{T}\\). The work requirement of each time period and the cost of assigning a pattern is represented as \\(r_t\\) and \\(c_p\\), respectively.\nNow we are ready to define the variable \\(x_p\\) as the number of workers that are assigned to pattern \\(p\\), and the mathematical model can be stated as below.\n\\[\\begin{align}\n\\text{min.} & \\quad \\sum_{p \\in \\mathcal{P}} c_p x_p \\\\\n\\text{s.t.} & \\quad \\sum_{p \\in \\mathcal{P}} m_{pt} x_p \\geq r_t, \\ \\forall t \\in \\mathcal{T} \\\\\n&\\quad x_p \\geq 0, \\ \\forall p \\in \\mathcal{P}\n\\end{align}\\]\nThe code snippet below gives the Python code to solve this problem using Google OR-Tools.\n\nfrom ortools.linear_solver import pywraplp\n\n# import instance data\nnum_periods = 10\nnum_patterns = 4\nrequirements = [3, 4, 3, 1, 5, 7, 2, 4, 5, 1]\ncosts = [10, 30, 20, 40]\npatterns = [set([1, 2, 3, 4]),\n            set([3, 4, 5]),\n            set([4, 5, 6, 7]),\n            set([7, 8, 9, 10])]\n\n# create solver object\nsolver = pywraplp.Solver.CreateSolver('GLOP')\n\ninfinity = solver.Infinity()\n# create decision variables\nvar_p = [solver.NumVar(0, infinity, name=f\"x_{p}\")\n         for p in range(num_patterns)]\n\n# create objective function\nsolver.Minimize(\n    solver.Sum([costs[p] * var_p[p] \n                for p in range(num_patterns)])\n)\n\n# create constraints\nfor t in range(num_periods):   \n    solver.Add(\n        solver.Sum([var_p[p] \n                    for p in range(num_patterns) \n                    if (t + 1) in patterns[p]])\n        &gt;= requirements[t])\n\n# solve the problem and retrieve optimal solution\nstatus = solver.Solve()\nif status == pywraplp.Solver.OPTIMAL:\n    print(f\"obj = {solver.Objective().Value()}\")\n    for p in range(num_patterns):\n        print(f\"var_{p + 1} = {var_p[p].solution_value()}\")\n\nobj = 380.0\nvar_1 = 4.0\nvar_2 = 0.0\nvar_3 = 7.0\nvar_4 = 5.0\n\n\n\n\n3.2.5 Sudoku Problem\nIn a Sudoku problem, a grid of 9x9 is given and the task is to fill all the cells with numbers 1-9. At the beginning, some of the cells are already gilled with numbers and the requirements are that the remaining cells must be filled so that each row, each column, and each of the 9 3x3 sub-grids contain all the numbers from 1 to 9 without any repitition. The difficulty level of Sudoku problems depends on the number of cells that are already filled in the grid at the beginning of the game. Problems with fewer initial digits filled are considered more challenging. Figure 3.2 illustrate a sample Sudoku problem.\n\n\n\n\n\nFigure 3.2: A Sudoku problem\n\n\n\n\nTo model this problem, we define set \\(S = (1, 2, 3, 4, 5, 6, 7, 8, 9)\\) and use \\(i, j \\in S\\) to index the row and column respectively. In addition, we use \\(M=\\{(i, j, k) | i, j, k \\in S\\}\\) to represent all the known numbers in the grid.\nTo formulate this problem, we define 9 binary variables for each cell in the 9x9 grid. Each of the 9 variables corresponds to one of the numbers in set \\(S\\). Formally, \\(x_{ijk}\\) represents whether the value \\(k\\) shows up in cell \\((i, j)\\) of the grid. Note that \\(i, j, k \\in S\\). The mathematical formulation can be stated as below.\n\\[\\begin{align}\n\\text{min.} &\\quad 0 \\label{sudoku-obj} \\\\\n\\text{s.t.} &\\quad \\sum_{j \\in S}x_{ijk} = 1, \\ \\forall i, k \\in S \\label{sudoku-cons1} \\\\\n&\\quad \\sum_{i \\in S} x_{ijk} = 1, \\ \\forall j, k \\in S \\label{sudoku-cons2} \\\\\n&\\quad \\sum_{k \\in S} x_{ijk} = 1, \\ \\forall i, j \\in S \\label{sudoku-cons3} \\\\\n&\\quad \\sum_{(i - 1) \\times 3 + 1}^{(i - 1) \\times 3 + 3} \\sum_{(j - 1) \\times 3 + 1}^{(j - 1) \\times 3 + 3} x_{ijk} = 1, \\ \\forall i, j \\in \\{1, 2, 3\\}, k \\in S \\label{sudoku-cons4}\\\\\n&\\quad x_{ijk} = 1, \\ \\forall (i, j, k) \\in M \\label{sudoku-cons5}\\\\\n&\\quad x_{ijk} \\in \\{0, 1\\}, \\ \\forall i, j,k \\in S\n\\end{align}\\]\nSince no feasible soution is more preferable than another, we use a constant value as the objective function, meaning any feasible soution is an optimal solution to this problem. Constraints \\(\\eqref{sudoku-cons1}\\) require that the number \\(k \\in S\\) shows up once and only once in each row of the grid. Similarly, \\(\\eqref{sudoku-cons2}\\) make sure that the number \\(k \\in S\\) shows up once and only once in each column of the grid. For each cell in the grid, only one of the numbers in \\(S\\) can appear, which is guaranteed by constraints \\(\\eqref{sudoku-cons3}\\). Constraints \\(\\eqref{sudoku-cons4}\\) ensure that the numbers in set \\(S\\) show up once and only once in each of the sub-grids. Constraints \\(\\eqref{sudoku-cons5}\\) make sure that the existing numbers in the grid stay the same in the optimal solution.\nWe can then solve the problem using Google OR-Tools and the code snippet is given below.\n\nimport numpy as np\nfrom ortools.linear_solver import pywraplp\n\n# import data\ngrid_size = 9\nsubgrid_size = 3\nM = [[(1, 3, 6)],\n     [(2, 3, 3)],\n     [(3, 1, 5), (3, 7, 3), (3, 8, 7), (3, 9, 9)],\n     [(4, 1, 2), (4, 2, 1), (4, 3, 4), (4, 4, 0)],\n     [(5, 6, 5), (5, 7, 4)],\n     [(6, 1, 3), (6, 2, 5), (6, 3, 8), (6, 7, 9)],\n     [(7, 1, 4), (7, 9, 2)],\n     [(8, 3, 5)],\n     [(9, 1, 8), (9, 2, 2)]]\n\n# create solver\nsolver = pywraplp.Solver.CreateSolver(\"SCIP\")\n\n# # create decision variables\nsudoku_vars = np.empty((grid_size, grid_size, grid_size), dtype=object)\nfor row in range(grid_size):\n     for col in range(grid_size):\n          for num in range(grid_size):\n               sudoku_vars[row][col][num] = solver.Var(0, \n                                   1, \n                                   integer=True, \n                                   name=f\"x_{row, col, num}\")\n\n# create objective\nsolver.Minimize(0)\n\n# create constraints\nfor row in range(grid_size):\n     for num in range(grid_size):\n          solver.Add(\n               solver.Sum([sudoku_vars[row][col][num] \n                              for col in range(grid_size)\n                         ]) == 1\n                    )\n\nfor col in range(grid_size):\n     for num in range(grid_size):\n          solver.Add(\n               solver.Sum([sudoku_vars[row][col][num] \n                              for row in range(grid_size)\n                         ]) == 1\n                    )\n          \nfor row in range(grid_size):\n     for col in range(grid_size):\n          solver.Add(\n               solver.Sum([sudoku_vars[row][col][num] \n                              for num in range(grid_size)\n                         ]) == 1\n                    )\n          \nfor row in range(grid_size):\n     known_values = M[row]\n     for value in known_values:\n          row, col, num = value\n          solver.Add(\n               sudoku_vars[row - 1][col - 1][num - 1] == 1\n          )\n\n# solve the problem\nstatus = solver.Solve()\n\nif status == pywraplp.Solver.OPTIMAL or status == pywraplp.Solver.FEASIBLE:\n     sudoku_sol = np.zeros((grid_size, grid_size), dtype=int)\n     for row in range(grid_size):\n          for col in range(grid_size):\n               for num in range(grid_size):\n                    if sudoku_vars[row][col][num].solution_value() == 1:\n                         sudoku_sol[row][col] = num + 1\n\nFigure 3.3 shows one solution to the example problem.\n\n\n\n\n\nFigure 3.3: One solution to the Sudoku problem"
  },
  {
    "objectID": "integer-programming.html#modeling-capabilities",
    "href": "integer-programming.html#modeling-capabilities",
    "title": "4  Integer Programming",
    "section": "4.1 Modeling Capabilities",
    "text": "4.1 Modeling Capabilities\nWhen modeling integer programs, there are two main tasks that require attention. The first is declaring integer variables, and the second is selecting a solver that is capable of solving integer programs.\n\n4.1.1 Declaring Integer Variables\nAs reviewed in Chapter 3, Google OR-Tools provides two options to create integer variables:\n\nThe Var(lb, ub, integer: bool, name) function\nThe IntVar(lb, ub, name) function\nThe Variable.SetInteger(integer: bool) function\n\nIn the code snippet below, we create three integer variables using all the aforementioned approaches:\n\nfrom ortools.linear_solver import pywraplp\n\nsolver = pywraplp.Solver.CreateSolver('SCIP')\n\n# option 1\nx = solver.Var(lb=0, ub=10, integer=True, name='x')\n\n# option 2\ny = solver.IntVar(lb=10, ub=20, name='y')\n\n# option 3\nz = solver.NumVar(lb=0, ub=5.5, name='z')\nz.SetInteger(integer=True)\n\nWe can verify the types of variables \\(x, y, z\\):\n\nprint(f\"x is integer? {x.integer()}\")\nprint(f\"y is integer? {y.integer()}\")\nprint(f\"z is integer? {z.integer()}\")\n\nx is integer? True\ny is integer? True\nz is integer? True\n\n\n\n\n4.1.2 Selecting an Integer Solver\nThere are several solvers available for solving integer programs, and some options include:\n\nCBC_MIXED_INTEGER_PROGRAMMING or CBC\nBOP_INTEGER_PROGRAMMING or BOP\nSAT_INTEGER_PROGRAMMING or SAT or CP_SAT\nSCIP_MIXED_INTEGER_PROGRAMMING or SCIP\nGUROBI_MIXED_INTEGER_PROGRAMMING or GUROBI or GUROBI_MIP\nCPLEX_MIXED_INTEGER_PROGRAMMING or CPLEX or CPLEX_MIP\nXPRESS_MIXED_INTEGER_PROGRAMMING or XPRESS or XPRESS_MIP\nGLPK_MIXED_INTEGER_PROGRAMMING or GLPK or GLPK_MIP\n\nIt’s important to note that some of these solvers are open-source, while others require a commercial license. The code block above demonstrates how to create an instance of an integer solver. To do so, we simply need to specify the name of the solver in the Solver.CreateSolver() function.\n\nsolver = pywraplp.Solver.CreateSolver('CBC')"
  },
  {
    "objectID": "ip-jsp.html#disjunctive-model",
    "href": "ip-jsp.html#disjunctive-model",
    "title": "5  Job Shop Scheduling",
    "section": "5.1 Disjunctive model",
    "text": "5.1 Disjunctive model\nThis model is taken from Ku and Beck (2016) and Manne (1960). The decision variables are defined as follows:\n\n\\(x_{ij}\\): the processing starting time of job \\(j\\) on machine \\(i\\)\n\\(z_{ijk}\\): a binary variable that equals 1 if job \\(j\\) precedes job \\(k\\) on machine \\(i\\)\n\nThe disjunctive model can then be stated as below.\n\\[\\begin{align}\n    \\text{min.} &\\quad C_{max} \\label{jsp-dis-obj}\\\\\n    \\text{s.t.} &\\quad x_{ij} \\geq 0, \\ \\forall j \\in \\mathcal{J}, i \\in \\mathcal{M} \\label{jsp-dis-cons1}\\\\\n    &\\quad x_{o_h^j, j} \\geq x_{o_{h-1}^j, j} + p_{o_{h-1}^j, j}, \\ \\forall j \\in \\mathcal{J}, h = 2, \\cdots, m \\label{jsp-dis-cons2}\\\\\n    &\\quad x_{ij} \\geq x_{ik} + p_{ik} - V \\cdot z_{ijk}, \\ \\forall i \\in \\mathcal{M}, j, k \\in \\mathcal{J}, j &lt; k  \\label{jsp-dis-cons3}\\\\\n    &\\quad x_{ik} \\geq x_{ij} + p_{ij} - V \\cdot (1 - z_{ijk}), \\ \\forall i \\in \\mathcal{M}, j, k \\in \\mathcal{J}, j &lt; k  \\label{jsp-dis-cons4}\\\\\n    &\\quad C_{max} \\geq x_{o_m^j, j} + p_{o_m^j, j}, \\ \\forall j \\in \\mathcal{J}  \\label{jsp-dis-cons5}\\\\\n    &\\quad z_{ijk} \\in \\{0, 1\\}, \\ \\forall i \\in \\mathcal{M}, j, k \\in \\mathcal{J} \\label{jsp-dis-cons6}\n\\end{align}\\]\nThe objective \\(\\eqref{jsp-dis-obj}\\) aims to minimize the maximal completion time of any job \\(j \\in \\mathcal{J}\\). Constraints \\(\\eqref{jsp-dis-cons1}\\) require that all the job processing starting time must not be negative values. Constraints \\(\\eqref{jsp-dis-cons2}\\) enforce the sequencing order among operations for every job, which state that the \\(h\\)-th operation of job \\(j\\), \\(o_h^j\\), cannot start unless its preceeding operation \\(o_{h - 1}^j\\) finishes. Constraints \\(\\eqref{jsp-dis-cons3}\\) and \\(\\eqref{jsp-dis-cons4}\\) together make sure that at most one job can be processed on a machine at any time. To be specific, in case of job \\(j\\) preceding job \\(k\\) on machine \\(i\\), \\(z_{ijk}\\) takes the value of 1 and constraints \\(\\eqref{jsp-dis-cons4}\\) ensure that job \\(k\\) won’t start processing on machine \\(i\\) unless job \\(i\\) completes processing; Otherwise, \\(z_{ijk}\\) takes the value of 0 and constraints \\(\\eqref{jsp-dis-cons3}\\) require that job \\(j\\) starts processing after job \\(k\\). Note that both constraints are needed when we require \\(j &lt; k\\); Otherwise, only one of them is needed if we create a constraint for every pair of \\(j\\) and \\(k\\) on a machine. Constraints \\(\\eqref{jsp-dis-cons5}\\) derive \\(C_{max}\\) across all jobs. The last constraints \\(\\eqref{jsp-dis-cons6}\\) state the variable type of \\(z_{ijk}\\).\nThe disjunctive formulation code is presented entirely in the following lines. The data related to the specific case are read between lines 5 to 8, and a solver object is created in line 11. The variable \\(x_{ij}\\) is introduced in lines 16 to 23, followed by the introduction of variable \\(z_{ijk}\\) in lines 25 to 34. The variable \\(C_{max}\\) is defined in lines 36 to 38. The objective of the model is set in line 41, and the constraints are established in lines 44 to 80. The instance is solved, and the optimal solution is obtained from lines 82 to 93.\n\nfrom typing import List, Dict\nfrom ortools.linear_solver import pywraplp\n\n# read and parse the data\nfilename = './data/jssp/ft06.txt'\nnum_jobs, num_machines, \\\noperations, processing_times = \\\n    read_jssp_instance(filename)\n\n# create solver\nsolver = pywraplp.Solver.CreateSolver('SCIP')\n\n# create variables\ninfinity = solver.Infinity()\nvar_time: List[List] = []\nfor machine in range(num_machines):\n    arr = [\n        solver.NumVar(0, \n                    infinity, \n                    name=f'x_{machine, job}') \n        for job in range(num_jobs)\n        ]\n    var_time.append(arr)\n\nvar_prec: Dict = []\nfor machine in range(num_machines):\n    mac_dict = {}\n    for job_j in range(num_jobs - 1):\n        for job_k in range(job_j + 1, num_jobs):\n            mac_dict[(job_j, job_k)] = \\\n            solver.BoolVar(\n                name=f'z_{machine, job_j, job_k}'\n            )\n    var_prec.append(mac_dict)\n\nvar_makespan = solver.NumVar(0, \n                            infinity, \n                            name='C_max')\n\n# create objective\nsolver.Minimize(var_makespan)\n\n# create constraints\nfor job, job_operations in enumerate(operations):\n    for h in range(1, num_machines):\n        curr_machine = job_operations[h]\n        prev_machine = job_operations[h - 1]\n        prev_time = processing_times[job][prev_machine]\n        solver.Add(\n            var_time[curr_machine][job] &gt;= \n                var_time[prev_machine][job] + \n                prev_time\n            )\n\nV = 0\nfor job in processing_times:\n    V += sum(processing_times[job].values())\nfor machine in range(num_machines):\n    for job_j in range(num_jobs - 1):\n        for job_k in range(job_j + 1, num_jobs):\n            solver.Add(\n                var_time[machine][job_j] &gt;= \n                var_time[machine][job_k] +\n                processing_times[job_k][machine] - \n                V * var_prec[machine][(job_j, job_k)]\n            )\n            solver.Add(\n                var_time[machine][job_k] &gt;= \n                var_time[machine][job_j] +\n                processing_times[job_j][machine] - \n                V * (1 - var_prec[machine][(job_j, job_k)])\n            )\n            \nfor job in range(num_jobs):\n    last_oper_machine = operations[job][-1]\n    solver.Add(\n        var_makespan &gt;= \n        var_time[last_oper_machine][job] + \n        processing_times[job][last_oper_machine]\n    )\n\nstatus = solver.Solve()\n\nif status == solver.OPTIMAL:\n    print(f\"min. makespan = {solver.Objective().Value():.2f}\")\n    \n    opt_time = []\n    for machine in range(num_machines):\n        arr = [\n            int(var_time[machine][job].solution_value()) \n            for job in range(num_jobs)\n        ]\n        opt_time.append(arr)\n\nmin. makespan = 55.00\n\n\nThe output of the model indicates that the lowest possible time needed to complete all tasks in this instance is 55. To illustrate the most efficient solution, we have created a function called show_schedule() that displays a Gantt chart of the tasks needed to process all jobs. Figure 5.1 displays the optimal solution for this instance.\n\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\n\ndef show_schedule(num_jobs, operations, processing_times, opt_time):\n    colors = mpl.colormaps[\"Set1\"].colors\n\n    fig, ax = plt.subplots(figsize=[7, 3], dpi=100)\n\n    for idx, job in enumerate(range(num_jobs)):\n        machines = operations[job]\n        job_start_times = [opt_time[machine][job] \n                            for machine in machines]\n        job_processing_times = [processing_times[job][machine] \n                                for machine in operations[job]]\n        \n        if idx &gt;= len(colors):\n            idx = idx % len(colors)\n        color = colors[idx]\n\n        bars = ax.barh(machines, \n                width=job_processing_times, \n                left=job_start_times, \n                label=f'Job {job + 1}', \n                color=color)\n        \n        ax.bar_label(bars, \n                    fmt=f'{job + 1}', \n                    label_type='center')\n        \n    ax.set_yticks(machines)\n    ax.set_xlabel(\"Time\")\n    ax.set_ylabel(\"Machine\")\n    fig.tight_layout()\n    plt.show()\n    \nshow_schedule(num_jobs, operations, processing_times, opt_time)\n\n\n\n\nFigure 5.1: Optimal solution of the ft06 instance using the disjunctive formulation"
  },
  {
    "objectID": "ip-jsp.html#time-indexed-model",
    "href": "ip-jsp.html#time-indexed-model",
    "title": "5  Job Shop Scheduling",
    "section": "5.2 Time-indexed model",
    "text": "5.2 Time-indexed model\nThe time-indexed formulation, proposed by Kondili, Pantelides, and Sargent (1988) and Ku and Beck (2016), involves the use of a binary variable \\(x_{ijt}\\) that takes the value of 1 if job \\(j\\) starts at time \\(t\\) on machine \\(i\\). The model can be expressed as follows.\n\\[\\begin{align}\n\\text{min.} &\\quad C_{max} \\label{jsp-time-obj}\\\\\n\\text{s.t.} &\\quad \\sum_{t \\in H} x_{ijt} = 1, \\ \\forall j \\in \\mathcal{J}, i \\in \\mathcal{M} \\label{jsp-time-cons1} \\\\\n&\\quad \\sum_{t \\in H} (t + p_{ij}) \\cdot x_{ijt} \\leq C_{max}, \\ \\forall j \\in \\mathcal{J}, i \\in \\mathcal{M} \\label{jsp-time-cons2} \\\\\n&\\quad \\sum_{j \\in \\mathcal{J}} \\sum_{t' \\in T_{ijt}} x_{ijt'} \\leq 1, \\ \\forall i \\in \\mathcal{M}, t \\in H, T_{ijt} = \\{t - p_{ij} + 1, \\cdots, t\\} \\label{jsp-time-cons3} \\\\\n&\\quad \\sum_{t \\in H} (t + p_{o_{h - 1}^j}, j) \\cdot x_{o_{h - 1}^j, jt} \\leq \\sum_{t \\in H} t \\cdot x_{o_h^j, jt}, \\ \\forall j \\in \\mathcal{J}, h = 2, \\cdots, m \\label{jsp-time-cons4} \\\\\n&\\quad x_{ijt} \\in \\{0, 1\\}, \\ \\forall j \\in \\mathcal{J}, i \\in \\mathcal{M}, t \\in H \\label{jsp-time-cons5}\n\\end{align}\\]\nIn this formulation, the first set of constraints, referred to as \\(\\eqref{jsp-time-cons1}\\), state that each job \\(j\\) must start at one specific time within the scheduling horizon \\(H\\), which is determined as the sum of processing times for all jobs - \\(H = \\sum_{i \\in \\mathcal{I}, j \\in \\mathcal{J}} p_{ij}\\). Constraints \\(\\eqref{jsp-time-cons2}\\) are used to calculate the value of \\(C_{max}\\), while constraints \\(\\eqref{jsp-time-cons3}\\) ensure that only one job can be processed by a machine at any given time. It’s important to note that a job will remain on a machine for its full processing time and cannot be interrupted. Constraints \\(\\eqref{jsp-time-cons4}\\) make sure that the order of processing jobs is followed, and constraints \\(\\eqref{jsp-time-cons5}\\) define the variable types used in the formulation.\nThe following code provides a program that uses the time-indexed formulation to solve the ft06 instance, with the value of \\(H\\) being the sum of all job processing times plus one. The two variables, \\(x_{ijt}\\) and \\(C_{max}\\), are created in lines 18 - 27. The constraints are created in lines 33 - 57. The optimal solution is retrieved in lines 61 - 71. It can be seen from the output that the same optimal objective, 55, is obtained using this formulation.\n\nfrom typing import List, Dict\nfrom ortools.linear_solver import pywraplp\nimport numpy as np\n\n# read and parse the data\nfilename = './data/jssp/ft06.txt'\nnum_jobs, num_machines, \\\noperations, processing_times = \\\n    read_jssp_instance(filename)\n    \n# create solver\nsolver = pywraplp.Solver.CreateSolver('SCIP')\n\n# create variables\nH = 1\nfor job in processing_times:\n    H += sum(processing_times[job].values())\nvar_x = np.empty((num_machines, num_jobs, H), dtype=object)\nfor machine in range(num_machines):\n    for job in range(num_jobs):\n        for t in range(H):\n            var_x[machine][job][t] = solver.BoolVar(name=f'x_{machine, job, t}')\n\ninfinity = solver.Infinity()\nvar_makespan = solver.NumVar(0, \n                            infinity, \n                            name='C_max')\n\n# create objective\nsolver.Minimize(var_makespan)\n\n# create constraints\nfor machine in range(num_machines):\n    for job in range(num_jobs):\n        solver.Add(solver.Sum([var_x[machine][job][t] for t in range(H)]) == 1)\n        \nfor machine in range(num_machines):\n    for job in range(num_jobs):\n        arr = [var_x[machine][job][t] * (t + processing_times[job][machine]) for t in range(H)]\n        solver.Add(solver.Sum(arr) &lt;= var_makespan)\n        \nfor machine in range(num_machines):\n    for t in range(H):\n        arr = [var_x[machine][job][tt]\n                    for job in range(num_jobs)\n                    for tt in range(t - processing_times[job][machine] + 1, t + 1)]\n        solver.Add(solver.Sum(arr) &lt;= 1)\n\nfor job in range(num_jobs):\n    for oper in range(1, num_machines):\n        prev_machine = operations[job][oper - 1]\n        curr_machine = operations[job][oper]\n        expr_prev = [(t + processing_times[job][prev_machine]) * var_x[prev_machine][job][t] \n                    for t in range(H)]\n        expr_curr = [t * var_x[curr_machine][job][t]\n                    for t in range(H)]\n        solver.Add(solver.Sum(expr_prev) &lt;= solver.Sum(expr_curr))\n\nstatus = solver.Solve()\n\nif status == solver.OPTIMAL:\n    print(f\"min. makespan = {solver.Objective().Value():.2f}\")\n    \n    opt_time = []\n    for machine in range(num_machines):\n        arr = []\n        for job in range(num_jobs):\n            for t in range(t):\n                if int(var_x[machine][job][t].solution_value()) == 1:\n                    arr.append(t)\n        opt_time.append(arr)\n\nmin. makespan = 55.00\n\n\nThe optimal solution can be seen in Figure 5.2. Even though both formulations achieve the same optimal objective value, there are some minor discrepancies between the optimal solutions. For instance, in Figure 5.1, there is a gap after job 4 completes processing on machine 3, which is not present in Figure 5.2.\n\nshow_schedule(num_jobs, operations, processing_times, opt_time)\n\n\n\n\nFigure 5.2: Optimal solution of the ft06 instance using the time-indexed formulation"
  },
  {
    "objectID": "ip-jsp.html#rank-based-model",
    "href": "ip-jsp.html#rank-based-model",
    "title": "5  Job Shop Scheduling",
    "section": "5.3 Rank-based model",
    "text": "5.3 Rank-based model\nThe rank-based model is due to Wagner (1959) and taken from Ku and Beck (2016). There are three decision variables in this formulation:\n\n\\(x_{ijk}\\): a binary variable that equals 1 if job \\(j\\) is scheduled at the \\(k\\)-th position on machine \\(i\\)\n\\(h_{ik}\\): a numerical variable that represents the start time of job at the \\(k\\)-th position of machine \\(i\\).\n\\(C_{max}\\): the makespan to be minimized\n\nThe complete model is given below.\n\\[\\begin{align}\n\\text{min.} &\\quad C_{max} \\label{jsp-rank-obj} \\\\\n\\text{s.t.} &\\quad \\sum_{j \\in \\mathcal{J}} x_{ijk} = 1, \\ \\forall i \\in \\mathcal{M}, k = 1, \\cdots, n \\label{jsp-rank-cons1} \\\\\n&\\quad \\sum_{k = 1}^n x_{ijk} = 1, \\ \\forall i \\in \\mathcal{M}, j \\in \\mathcal{J} \\label{jsp-rank-cons2} \\\\\n&\\quad h_{ik} + \\sum_{j \\in \\mathcal{J}} p_{ij} x_{ijk} \\leq h_{i,k+1}, \\ \\forall i \\in \\mathcal{M}, k = 1, \\cdots, n-1 \\label{jsp-rank-cons3}\\\\\n&\\quad\n\\begin{split}\n    &\\sum_{i \\in \\mathcal{M}} r_{ijl} h_{ik} + \\sum_{i \\in \\mathcal{M}} r_{ijl}p_{ij} \\leq V \\cdot (1 - \\sum_{i \\in \\mathcal{M}}r_{ijl}x_{ijk})\\  +\\  \\\\\n    &V \\cdot (1 - \\sum_{i \\in \\mathcal{M}}r_{ij,l+1}x_{ijk'}) + \\sum_{i \\in \\mathcal{M}}r_{ij,l+1}h_{ik'},\\\\\n    &\\forall j \\in \\mathcal{J}, k, k' = 1, \\cdots, n, l = 1, \\cdots, m - 1\n\\end{split}\n\\label{jsp-rank-cons4}\\\\\n&\\quad h_{in} + \\sum_{j \\in \\mathcal{J}} p_{ij}x_{ijk} \\leq C_{max}, \\ \\forall i \\in \\mathcal{M} \\label{jsp-rank-cons5}\\\\\n&\\quad h_{ik} \\geq 0, \\ \\forall i \\in \\mathcal{M}, k = 1, \\cdots, n \\label{jsp-rank-cons6} \\\\\n&\\quad x_{ijk} \\in \\{0, 1\\}, \\ \\forall j \\in \\mathcal{J}, i \\in \\mathcal{M}, k = 1, \\cdots, n \\label{jsp-rank-cons7}\\\\\n&\\quad C_{max} \\geq 0 \\label{jsp-rank-cons8}\n\\end{align}\\]\nIn this formulation, constraints \\(\\eqref{jsp-rank-cons1}\\) make sure that there is only one job assigned to a particular rank \\(k\\) on machine \\(i\\). Constraints \\(\\eqref{jsp-rank-cons2}\\) ensure that any job \\(j\\) is assigned to one and only one rank on a machine \\(i\\). Constraints \\(\\eqref{jsp-rank-cons3}\\) require that a machine can only process at most one job at any point of time. Constraints \\(\\eqref{jsp-rank-cons4}\\) guarantee that the processing order of a job is respected. Constraints \\(\\eqref{jsp-rank-cons5}\\) computes the makespan. The remaining constraints \\(\\eqref{jsp-rank-cons6}\\), \\(\\eqref{jsp-rank-cons7}\\) and \\(\\eqref{jsp-rank-cons8}\\) indicate the variable types.\nWe now solve the same problem instance using this rank-based formulation in Google OR-Tools, for which the complete code is shown below.\n\nfrom typing import List\nfrom itertools import product\nimport numpy as np\nfrom ortools.linear_solver import pywraplp\n\n# read and parse the data\nfilename = './data/jssp/ft06.txt'\nnum_jobs, num_machines, \\\noperations, processing_times = \\\n    read_jssp_instance(filename)\n    \n# create solver\nsolver = pywraplp.Solver.CreateSolver('SCIP')\n\n# create variables\nvar_x = np.empty(shape=(num_machines, num_jobs, num_jobs), dtype=object)\nfor machine, job, rank in product(range(num_machines), \n                                range(num_jobs), \n                                range(num_jobs)):\n    var_x[machine][job][rank] = solver.BoolVar(name=f'x_{machine, job, rank}')\n            \n\ninfinity = solver.Infinity()\nvar_h = np.empty(shape=(num_machines, num_jobs), dtype=object)\nfor machine, rank in product(range(num_machines), range(num_jobs)):\n    var_h[machine][rank] = solver.NumVar(0, infinity, name=f'h_{machine, rank}')\n\nvar_makespan = solver.NumVar(0, infinity, name=f'makesplan')\n\n# create objective\nsolver.Minimize(var_makespan)\n\n# create constraints\nfor machine, rank in product(range(num_machines), range(num_jobs)):\n    expr = [var_x[machine][job][rank] for job in range(num_jobs)]\n    solver.Add(solver.Sum(expr) == 1)\n\nfor machine, job in product(range(num_machines), range(num_jobs)):\n    expr = [var_x[machine][job][rank] for rank in range(num_jobs)]\n    solver.Add(solver.Sum(expr) == 1)\n\nfor machine, rank in product(range(num_machines), range(num_jobs - 1)):\n    expr = [var_x[machine][job][rank] * processing_times[job][machine] \n            for job in range(num_jobs)]\n    solver.Add(var_h[machine][rank] + solver.Sum(expr) &lt;= var_h[machine][rank + 1])\n\nr = np.zeros((num_machines, num_jobs, num_machines))\nfor job in range(num_jobs):\n    job_operations: List = operations[job]\n    for o_idx, o_machine in enumerate(job_operations):\n        r[o_machine][job][o_idx] = 1\nV = 0\nfor job in processing_times:\n    V += sum(processing_times[job].values())\n\nfor job, k, kk, l in product(range(num_jobs), \n                            range(num_jobs), \n                            range(num_jobs), \n                            range(num_machines - 1)):\n    expr_1 = [r[machine][job][l] * var_h[machine][k] \n            for machine in range(num_machines)]\n    expr_2 = [r[machine][job][l] * processing_times[job][machine]\n            for machine in range(num_machines)]\n    expr_3 = [r[machine][job][l] * var_x[machine][job][k]\n            for machine in range(num_machines)]\n    expr_4 = [r[machine][job][l + 1] * var_x[machine][job][kk] \n            for machine in range(num_machines)]\n    expr_5 = [r[machine][job][l + 1] * var_h[machine][kk] \n            for machine in range(num_machines)]\n    solver.Add(solver.Sum(expr_1) + solver.Sum(expr_2) &lt;= V * (1 - solver.Sum(expr_3)) + V * (1 - solver.Sum(expr_4)) + solver.Sum(expr_5))\n\nfor machine in range(num_machines):\n    expr = [var_x[machine][job][num_jobs - 1] * processing_times[job][machine] for job in range(num_jobs)]\n    solver.Add(var_h[machine][num_jobs - 1] + solver.Sum(expr) &lt;= var_makespan)\n\nstatus = solver.Solve()\n\nif status == pywraplp.Solver.OPTIMAL:\n    print(f\"opt_obj = {solver.Objective().Value():.4f}\")\n    opt_time = []\n    for machine in range(num_machines):\n        arr = []\n        for job in range(num_jobs):\n            for rank in range(num_jobs):\n                if int(var_x[machine][job][rank].solution_value()) == 1:\n                    arr.append(var_h[machine][rank].solution_value())\n        opt_time.append(arr)\n\nopt_obj = 55.0000\n\n\nFigure 5.3 displays the optimal solution obtained by utilizing the rank-based model. Upon careful examination, it is slightly distinct from the optimal solutions produced by the disjunctive model and the time-indexed model. Nevertheless, all three models achieve the same objective value of 55.\n\nshow_schedule(num_jobs, operations, processing_times, opt_time)\n\n\n\n\nFigure 5.3: Optional solution found by the rank-based model for instance ft06\n\n\n\n\nWhile this book does not aim to compare the performance of the three modeling approaches, Table 5.1 presents the computational times required by each formulation to discover the optimal solutions. The table indicates that the disjunctive model is the most efficient of the three, followed by the time-indexed model, while the rank-based model requires the longest time to converge. It should be noted that making a conclusion about the performance of these models based on one experimental run on a single instance is insufficient.\n\n\n\n\nTable 5.1: Computational time comparison of the three formulations\n\n\nInstance\nDisjunctive Model\nTime-indexed Model\nRank-based Model\n\n\n\n\nft06\n1.7s\n1m34.9s\n11m38.2s\n\n\n\n\n\n\n\n\n\n\nBeasley, John E. 1990. “OR-Library: Distributing Test Problems by Electronic Mail.” Journal of the Operational Research Society 41 (11): 1069–72.\n\n\nKondili, E, CC Pantelides, and R WH Sargent. 1988. “A General Algorithm for Scheduling Batch Operations.” In. Barton, ACT. https://search.informit.org/doi/10.3316/informit.394925233030714.\n\n\nKu, Wen-Yang, and J. Christopher Beck. 2016. “Mixed Integer Programming Models for Job Shop Scheduling: A Computational Analysis.” Computers & Operations Research 73 (September): 165–73. https://doi.org/10.1016/j.cor.2016.04.006.\n\n\nManne, Alan S. 1960. “On the Job-Shop Scheduling Problem.” Operations Research 8 (2): 219–23. https://doi.org/10.1287/opre.8.2.219.\n\n\nWagner, Harvey M. 1959. “An Integer Linear-Programming Model for Machine Scheduling.” Naval Research Logistics Quarterly 6 (2): 131–40. https://doi.org/10.1002/nav.3800060205."
  },
  {
    "objectID": "ip-tsp.html#tsp-instances",
    "href": "ip-tsp.html#tsp-instances",
    "title": "6  Traveling Salesman Problem",
    "section": "6.1 TSP Instances",
    "text": "6.1 TSP Instances\nBefore discussing the mathematical models of the TSP, we first provide an introduction to the instances that will be utilized to test various formulations and illustrate the resulting TSP solutions. The TSP is a widely recognized optimization problem that has been studied for several decades. Due to its significance, many benchmarking problem instances of varying sizes are available in literature. In this chapter, we do not aim to solve the most challenging TSP instances, but instead, our objective is to demonstrate how to apply different formulations of the TSP using OR-Tools.\nTo achieve this objective, we will focus on presenting some of the small-sized instances that can be solved effectively using OR-Tools. These instances are well-documented, which makes them easy to understand and implement in practice. Additionally, they help illustrate the optimization techniques used to solve the TSP, such as branch-and-bound and cutting plane methods. Moreover, small-sized instances allow for quicker computation, making it easier to observe the behavior of different algorithms and identify which formulations are most efficient.\nBy presenting a range of examples, we aim to provide a clear understanding of how to implement different TSP formulations using OR-Tools, which can be applied to real-world problems in various domains, such as transportation planning and logistics, network design, and circuit board drilling. Additionally, we aim to demonstrate the advantages and limitations of different TSP formulations and algorithms, highlighting which techniques perform well under specific circumstances. By doing so, readers can gain insight into how to apply TSP optimization techniques to their own problems effectively.\n\n6.1.1 TSPLIB\nThe TSP instances used in this section are sourced from TSPLIB95, a library of TSP benchmark instances. To make it easier to work with these instances, we utilize the tsplib95 Python library, which can be installed using the pip install tsplib95 command.\nIn the code snippet below, we demonstrate how to use the tsplib95 package to load the ulysses22.tsp problem from a data file downloaded from TSPLIB95. The loaded data can be used to formulate and solve TSP instances using OR-Tools or other optimization tools. The full instance data is provided at the end for reference. By leveraging the tsplib95 package, we can quickly and easily access TSP instances for experimentation and analysis, and focus our efforts on the formulation and optimization aspects of the problem.\n\nimport tsplib95\n\n# load problem\nproblem = tsplib95.load('./data/tsp/ulysses22.tsp')\n\n# show instance\nproblem.as_name_dict()\n\n{'name': 'ulysses22.tsp',\n 'comment': 'Odyssey of Ulysses (Groetschel/Padberg)',\n 'type': 'TSP',\n 'dimension': 22,\n 'edge_weight_type': 'GEO',\n 'display_data_type': 'COORD_DISPLAY',\n 'node_coords': {1: [38.24, 20.42],\n  2: [39.57, 26.15],\n  3: [40.56, 25.32],\n  4: [36.26, 23.12],\n  5: [33.48, 10.54],\n  6: [37.56, 12.19],\n  7: [38.42, 13.11],\n  8: [37.52, 20.44],\n  9: [41.23, 9.1],\n  10: [41.17, 13.05],\n  11: [36.08, -5.21],\n  12: [38.47, 15.13],\n  13: [38.15, 15.35],\n  14: [37.51, 15.17],\n  15: [35.49, 14.32],\n  16: [39.36, 19.56],\n  17: [38.09, 24.36],\n  18: [36.09, 23.0],\n  19: [40.44, 13.57],\n  20: [40.33, 14.15],\n  21: [40.37, 14.23],\n  22: [37.57, 22.56]}}\n\n\nThe list of nodes can be retrieved using the get_nodes() function, as shown below.\n\nlist(problem.get_nodes())\n\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22]\n\n\nTo get the distance between any pair of nodes, we use the get_weight() function.\n\nprint(f'distance between node 1 and 2 = {problem.get_weight(1, 2)}')\n\ndistance between node 1 and 2 = 509\n\n\n\n\n6.1.2 Visualize TSP Solution\nIn this section, our goal is to gain a better understanding of the TSP problem by visualizing the optimal solution found for instances provided by TSPLIB95. To achieve this, we define a class called TspVisualizer in our code that is responsible for displaying the route that connects all nodes in a TSP solution. The TspVisualizer class contains a single function, called show(locations, edges), which accepts two input parameters: locations and edges.\nThe locations parameter is a dictionary that contains the mapping between location ID and its corresponding coordinates. The edges parameter is a list of edges that form the TSP tour. By calling the show function with the appropriate input parameters, we can visualize the TSP tour and gain an intuitive understanding of what the TSP problem is trying to accomplish. This visualization can be a helpful tool in understanding how the different TSP formulations and algorithms work, and can aid in identifying potential improvements to the solution. The use of the TspVisualizer class allows for easy visualization of the TSP solution and makes it possible to explore and analyze TSP instances in a more meaningful way.\n\nimport networkx as nx\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\n\nclass TspVisualizer:\n    \"\"\"visualize a TSP tour\n    \"\"\"\n    \n    @staticmethod\n    def show(locations, edges):\n        \"\"\"draw TSP tour\n        adapted from https://stackoverflow.com/a/50682819\n        \n        examples:\n        locations = {\n            0: (5, 5),\n            1: (4, 9),\n            2: (6, 4),\n        }\n\n        edges = [\n            (0, 1),\n            (1, 2),\n            (2, 0),\n        ]\n\n        Args:\n            locations (dict): location id -&gt; (lat, lon)\n            edges (list): list of edges\n        \"\"\"\n        G = nx.DiGraph()\n        G.add_edges_from(edges)\n        plt.figure(figsize=(15,10))\n        \n        colors = mpl.colormaps[\"Set1\"].colors\n        color_idx = 1\n        color = np.array([colors[color_idx]])\n        \n        nx.draw_networkx_nodes(G, \n                                locations, \n                                nodelist=[x[0] \n                                        for x in edges], \n                                node_color=color)\n        nx.draw_networkx_edges(G,\n                                locations, \n                                edgelist=edges,\n                                width=4, \n                                edge_color=color, \n                                style='dashed')\n        \n        # labels\n        nx.draw_networkx_labels(G, locations, \n                                font_color='w', \n                                font_size=12, \n                                font_family='sans-serif')\n\n        #print out the graph\n        plt.axis('off')\n        plt.show()\n\nNow let’s load the optimal solution for the aforementioned instance and show its content below.\n\nsolution = tsplib95.load('./data/tsp/ulysses22.opt.tour')\nsolution.as_name_dict()\n\n{'name': 'ulysses22.opt.tour',\n 'comment': 'Optimal solution of ulysses22 (7013)',\n 'type': 'TOUR',\n 'dimension': 22,\n 'tours': [[1,\n   14,\n   13,\n   12,\n   7,\n   6,\n   15,\n   5,\n   11,\n   9,\n   10,\n   19,\n   20,\n   21,\n   16,\n   3,\n   2,\n   17,\n   22,\n   4,\n   18,\n   8]]}\n\n\nThe code snippet below plots the optimal tour, which is shown in Figure 6.1.\n\nlocations = problem.node_coords\ntour = solution.tours[0]\nedges = []\nfor i in range(len(tour) - 1):\n    edges.append((tour[i], tour[i + 1]))\nedges.append((tour[-1], tour[0]))\nedges = []\nfor i in range(len(tour) - 1):\n    edges.append((tour[i], tour[i + 1]))\nedges.append((tour[-1], tour[0]))\nTspVisualizer.show(locations, edges)\n\n\n\n\nFigure 6.1: Optimal tour of the ulysses22 instance\n\n\n\n\nLet’s put this visualization procedure into a dedicated function, as is given below.\n\nimport tsplib95\n\ndef visualize_tsp(instance_name: str):\n    # load problem\n    problem = tsplib95.load(f'./data/tsp/{instance_name}.tsp')\n    solution = tsplib95.load(f'./data/tsp/{instance_name}.opt.tour')\n\n    locations = problem.node_coords\n    tour = solution.tours[0]\n    edges = []\n    for i in range(len(tour) - 1):\n        edges.append((tour[i], tour[i + 1]))\n    edges.append((tour[-1], tour[0]))\n    edges = []\n    for i in range(len(tour) - 1):\n        edges.append((tour[i], tour[i + 1]))\n    edges.append((tour[-1], tour[0]))\n    TspVisualizer.show(locations, edges)\n\nFigure 6.2 and Figure 6.3 show the optimal tours for the berlin52 and pr76 instances, respectively.\n\nvisualize_tsp('berlin52')\n\n\n\n\nFigure 6.2: Optimal tour of the berlin52 instance\n\n\n\n\n\nvisualize_tsp('pr76')\n\n\n\n\nFigure 6.3: Optimal tour of the pr76 instance"
  },
  {
    "objectID": "ip-tsp.html#problem-description",
    "href": "ip-tsp.html#problem-description",
    "title": "6  Traveling Salesman Problem",
    "section": "6.2 Problem Description",
    "text": "6.2 Problem Description\nLet \\(\\mathcal{G} = (\\mathcal{V}, \\mathcal{A})\\) be an undirected complete graph, where \\(V = \\{1, 2, \\cdots, n\\}\\) represents a set of \\(n\\) cities or vertices, and \\(\\mathcal{A} = \\{(i, j)\\ |\\ i, j \\in \\mathcal{V}, i \\neq j\\}\\) represents the set of edges connecting these cities. The edges in \\(\\mathcal{A}\\) have weights or distances associated with them, \\(c_{ij}\\), representing the distances or costs to travel between pairs of cities.\nThe objective of the TSP is to find the shortest possible closed tour that visits each city in \\(\\mathcal{V}\\) exactly once and returns to the starting city, while obeying the following constraints:\n\nEach city must be visited exactly once: The tour must include all the cities in \\(\\mathcal{V}\\), and each city must be visited exactly once during the tour.\nThe tour must be closed: The last city visited in the tour must be the same as the starting city, forming a closed loop."
  },
  {
    "objectID": "ip-tsp.html#model-1---dfj",
    "href": "ip-tsp.html#model-1---dfj",
    "title": "6  Traveling Salesman Problem",
    "section": "6.3 Model 1 - DFJ",
    "text": "6.3 Model 1 - DFJ\nThe first formulation was proposed by Dantzig, Fulkerson, and Johnson (1954). It uses the following decision variables:\n\n\\(x_{ij}\\): a binary variable that equals 1 if arc \\((i, j) \\in \\mathcal{A}\\) shows up in the optimal solution, 0 otherwise\n\nWe can state the model as follows:\n\\[\\begin{align}\n\\text{min.} &\\quad \\sum_{(i, j) \\in \\mathcal{A}} c_{ij} x_{ij} \\label{tsp1-obj} \\\\\n\\text{s.t.} &\\quad \\sum_{j \\in \\mathcal{V},\\  j \\neq i} x_{ij} = 1, \\ \\forall i \\in \\mathcal{V} \\label{tsp1-cons1} \\\\\n&\\quad \\sum_{i \\in \\mathcal{V}, \\ i \\neq j} x_{ij} = 1, \\ \\forall j \\in \\mathcal{V} \\label{tsp1-cons2}\\\\\n&\\quad\n\\begin{split}\n    & \\sum_{i, j \\in S, \\ (i, j) \\in \\mathcal{A}} x_{ij} \\leq |S| - 1,\\\\\n    &\\qquad \\forall S \\subset \\mathcal{V}, \\ 2 \\leq |S| \\leq n - 2\n\\end{split}\n\\label{tsp1-cons3}  \\\\\n&\\quad x_{ij} \\in \\{0, 1\\}, \\ \\forall (i, j) \\in \\mathcal{A} \\label{tsp1-cons4}\n\\end{align}\\]\nThis specific TSP formulation aims to find the optimal route with the shortest total distance. To ensure that each node is visited exactly once, constraints \\(\\eqref{tsp1-cons1}\\) and \\(\\eqref{tsp1-cons2}\\), also known as degree constraints, are used. Another set of constraints \\(\\eqref{tsp1-cons3}\\), called subtour elimination constraints, ensure that the solution does not contain any subtours. Subtours are smaller cycles within the larger route that violate the requirement of visiting each city exactly once. Two examples of solutions with subtours are shown in figures Figure 6.4 and Figure 6.5. While these solutions satisfy the degree constraints, they violate the subtour elimination constraints. A subtour contains the same number of edges (or arcs) as nodes, so limiting the number of edges to be less than the number of nodes can help to eliminate subtours. Furthermore, because of the presence of degree constraints, subtours with only one node cannot exist, and similarly, subtours with \\(n-1\\) nodes are also impossible. Therefore, it is acceptable to define the subtour elimination constraints only for subtours that contain between 2 and \\(n-2\\) nodes.\n\n\n\n\n\nflowchart LR\n    1((1)) --&gt; 2((2))\n    2 --&gt; 3((3))\n    3 --&gt; 4((4))\n    4 --&gt; 7((7))\n    7 --&gt; 1\n    5((5)) --&gt; 6((6))\n    6 --&gt; 5\n\n\nFigure 6.4: Subtour with 2 nodes\n\n\n\n\n\n\n\n\n\nflowchart LR\n    1((1)) --&gt; 2((2))\n    2 --&gt; 3((3))\n    3 --&gt; 7((7))\n    7 --&gt; 1\n    4((4)) --&gt; 5((5)) \n    5 --&gt; 6((6))\n    6 --&gt; 4\n\n\nFigure 6.5: Subtour with 3 nodes\n\n\n\n\nAn equivalent way of constraints \\(\\eqref{tsp1-cons3}\\) is\n\\[\\begin{align}\n    \\sum_{i \\in S}\\sum_{j \\notin S} x_{ij} \\geq 1, \\ \\forall S \\subset \\mathcal{V}, \\ 2 \\leq |S| \\leq n - 2 \\label{tsp1-cons5}\n\\end{align}\\]\nTo understand this, observe that the value of \\(|S|\\) can be calculated as the sum of two terms: the sum of the decision variables \\(x_{ij}\\) for all edges \\((i,j)\\) that are included in the subset, and the sum of the decision variables \\(x_{ij}\\) for all edges that cross the boundary of the subtour, that is, \\(|S| = \\sum_{i, j \\in S, \\ (i, j) \\in \\mathcal{A}} x_{ij} + \\sum_{i \\in S}\\sum_{j \\notin S} x_{ij}\\). This means that the constraints \\(\\eqref{tsp1-cons3}\\) and \\(\\eqref{tsp1-cons5}\\) are interchangeable, as they represent the same condition in different forms.\nTo simplify the implementation of different TSP formulations that will be presented in the following sections, we have created a base class called TspModel in the code below. This class contains the instance information that needs to be solved, as well as several helper functions. Within the class definition, the attribute _node_list holds the list of nodes that must be visited by the TSP tour. The attribute _node_coords is a dictionary that stores the location information for each node. Finally, the attribute _distance is another dictionary that provides the distance between any pair of nodes. The read_inputs() function, defined between lines 15 and 31, takes a TSP problem instance and extracts the necessary information for solving the problem later. The get_combinations() function, defined between lines 33 and 34, generates all possible combinations of nodes with the specified size.\n\nfrom typing import Dict, List\nfrom itertools import combinations\nimport tsplib95\n\nclass TspModel:\n    \"\"\"base class for TSP models\n    \"\"\"\n    \n    def __init__(self, name: str):\n        self._name: str = name\n        self._node_list: List[int] = None\n        self._node_coords: Dict[int, List[float, float]] = None\n        self._distance: Dict[int, Dict[int, int]] = None\n        \n    def read_inputs(self, instance_file: str) -&gt; None:\n        problem = tsplib95.load(instance_file)\n\n        node_coords = problem.node_coords\n        self._node_coords = {\n            id: node_coords[id]\n            for id in node_coords\n        }\n        self._node_list = list(node_coords.keys())\n        \n        self._distance = {}\n        for i in self._node_list:\n            dist = {\n                j: problem.get_weight(i, j)\n                for j in self._node_list\n            }\n            self._distance[i] = dist\n\n    def get_combinations(self, size):\n        return list(combinations(self._node_list, size))\n        \n    @property\n    def name(self): return self._name\n    \n    @property\n    def num_nodes(self): return len(self._node_coords)\n\nTo implement the TSP model using OR-Tools, we define the TspModelV1 class that inherits from the base class TspModel. The constructor initializes a solver object and defines attributes to store decision variables and the optimal solution. The _create_variables() function creates binary decision variables for every arc in the problem, while the _create_objective() function calculates the total traveling cost. Degree constraints are defined in the _create_degree_constraints() function, while the subtour elimination constraints are defined in the _create_subtour_elimination_constraints() function. The build_model() function needs to be called before optimize() to construct the model.\n\nfrom itertools import product\nfrom ortools.linear_solver import pywraplp\n\nclass TspModelV1(TspModel):\n    \n    def __init__(self, name='Tspmodel_v1'):\n        super().__init__(name)\n        \n        self._solver = pywraplp.Solver.CreateSolver('SCIP')\n        self._var_x = None\n        self._opt_obj = None\n        self._opt_x = None\n        self._opt_route = None\n    \n    def build_model(self):\n        self._create_variables()\n        self._create_objective()\n        self._create_degree_constraints()\n        self._create_subtour_elimination_constraints()\n    \n    def optimize(self, enable_output: bool):\n        if enable_output: self._solver.EnableOutput()\n        status = self._solver.Solve()\n        if status is pywraplp.Solver.OPTIMAL:\n            self._retrieve_opt_solution()\n            self._retrieve_opt_route()\n    \n    def _create_variables(self):\n        self._var_x = {}\n        for i in self._node_list:\n            self._var_x[i] = {\n                j: self._solver.BoolVar('x_{i, j}')\n                for j in self._node_list\n                if j != i\n            }\n    \n    def _create_objective(self):\n        node_list = self._node_list\n        expr = [self._distance[i][j] * self._var_x[i][j]\n                for i, j in product(node_list, node_list)\n                if i != j]\n        self._solver.Minimize(self._solver.Sum(expr))\n        \n    def _create_degree_constraints(self):\n        for i in self._node_list:\n            out_expr = [self._var_x[i][j]\n                    for j in self._node_list\n                    if j != i\n                    ]\n            in_expr = [self._var_x[j][i]\n                        for j in self._node_list\n                        if j != i\n                    ]\n            self._solver.Add(self._solver.Sum(out_expr) == 1)\n            self._solver.Add(self._solver.Sum(in_expr) == 1)\n    \n    def _create_subtour_elimination_constraints(self):\n        num_nodes = self.num_nodes\n        for size in range(2, num_nodes - 1):\n            combinations = self.get_combinations(size)\n            for comb in combinations:\n                expr = [self._var_x[i][j]\n                        for i, j in product(comb, comb)\n                        if i != j]\n                self._solver.Add(self._solver.Sum(expr) &lt;= \n                                len(comb) - 1)\n    \n    def _retrieve_opt_solution(self):\n        self._opt_obj = float(self._solver.Objective().Value())\n        self._opt_x = {}\n        for i in self._node_list:\n            self._opt_x[i] = {\n                j: round(self._var_x[i][j].solution_value())\n                for j in self._node_list\n                if j != i\n            }\n            \n        print(f'optimal value = {self._opt_obj:.2f}')\n    \n    def _retrieve_opt_route(self):\n        self._opt_route = []\n        route_start = list(self._opt_x.keys())[0]\n        edge_start = route_start\n        while True:\n            for n in self._opt_x[edge_start]:\n                if self._opt_x[edge_start][n] == 0: continue\n                \n                edge_end = n\n                self._opt_route.append((edge_start, edge_end))\n                break\n            \n            if edge_end == route_start: break\n            edge_start = edge_end\n            \n    def show_opt_route(self):\n        TspVisualizer.show(self._node_coords, self._opt_route)\n        \n        \n    def show_model_info(self):\n        print(f\"Number of variables: {self._solver.NumVariables()}\")\n        print(f\"Number of constraints: {self._solver.NumConstraints()}\")\n\nNow we use the TspModelV1 class to solve the burma14 instance and plots the optimal solution found by the OR-Tools in Figure 6.6.\n\ninstance = './data/tsp/burma14.tsp'\n\nmodel_v1 = TspModelV1()\nmodel_v1.read_inputs(instance_file=instance)\nmodel_v1.build_model()\nmodel_v1.show_model_info()\nmodel_v1.optimize(False)\nmodel_v1.show_opt_route()\n\nNumber of variables: 182\nNumber of constraints: 16382\noptimal value = 3323.00\n\n\n\n\n\nFigure 6.6: Optimal route for the burma14 instance"
  },
  {
    "objectID": "ip-tsp.html#model-2---mtz",
    "href": "ip-tsp.html#model-2---mtz",
    "title": "6  Traveling Salesman Problem",
    "section": "6.4 Model 2 - MTZ",
    "text": "6.4 Model 2 - MTZ\nIn this formulation, an alternative way of modeling the subtour elimination constraints was proposed by Miller, Tucker, and Zemlin (1960). The model uses two types of decision variables:\n\n\\(x_{ij}\\): a binary variable that equals 1 if arc \\((i, j) \\in \\mathcal{A}\\) shows up in the optimal solution, 0 otherwise\n\\(u_i\\): a continuous variable for \\(i \\in \\mathcal{V} \\backslash \\{1\\}\\)\n\nThe complete formulation is given below.\n\\[\\begin{align}\n\\text{min.} &\\quad \\sum_{(i, j) \\in \\mathcal{A}} c_{ij} x_{ij} \\label{tsp2-obj} \\\\\n\\text{s.t.} &\\quad \\sum_{j \\in \\mathcal{V},\\  j \\neq i} x_{ij} = 1, \\ \\forall i \\in \\mathcal{V} \\label{tsp2-cons1} \\\\\n&\\quad \\sum_{i \\in \\mathcal{V}, \\ i \\neq j} x_{ij} = 1, \\ \\forall j \\in \\mathcal{V} \\label{tsp2-cons2}\\\\\n&\\quad\n\\begin{split}\n    &u_i - u_j + (n - 1) x_{ij} \\leq n - 2, \\\\\n    &\\qquad \\forall i, j \\in \\{2, \\cdots, n\\}, i \\neq j\n\\end{split}\n\\label{tsp2-cons3} \\\\\n&\\quad x_{ij} \\in \\{0, 1\\}, \\ \\forall (i, j) \\in \\mathcal{A} \\label{tsp2-cons4} \\\\\n&\\quad 1 \\leq n_i \\leq n - 1, i = 2, \\cdots, n \\label{tsp2-cons5}\n\\end{align}\\]\nIn this formulation, constraints \\(\\eqref{tsp2-cons1}\\) and \\(\\eqref{tsp2-cons2}\\) serve as the degree constraints requiring that there is only one arc entering and leaving a node. Constraints \\(\\eqref{tsp2-cons3}\\) are the new subtour elimination constraints. To see how constraints \\(\\eqref{tsp2-cons3}\\) effectively forbid subtours, let’s examine the example below in Figure 6.7. In the figure, nodes 5 and 6 form a subtour and constraints \\(\\eqref{tsp2-cons3}\\) become:\n\\[\\begin{align}\nu_5 - u_6 + (7 - 1) * 1 \\leq 7 - 2 \\\\\nu_6 - u_5 + (7 - 1) * 1 \\leq 7 - 2\\\\\n\\end{align}\\]\nwhich translate to:\n\\[\\begin{align}\nu_5 \\leq u_6 - 1 \\\\\nu_6 \\leq u_5 - 1\n\\end{align}\\]\nand thus:\n\\[\\begin{align}\n    u_5 & \\leq u_6 - 1 \\\\\n    & \\leq u_5 - 1 - 1\\\\\n    & \\leq u_5 - 2\n\\end{align}\\]\nfor which, we have \\(0 \\leq -2\\), which is obviously wrong. Therefore, any subtour will violate the constraints defined in \\(\\eqref{tsp2-cons3}\\).\n\n\n\n\n\nflowchart LR\n    1((1)) --&gt; 2((2))\n    2 --&gt; 3((3))\n    3 --&gt; 7((7))\n    7 --&gt; 4((4))\n    4 --&gt; 1\n    5((5)) --&gt; 6((6))\n    6 --&gt; 5\n\n\nFigure 6.7: Subtour with 2 nodes\n\n\n\n\nThe code below gives the complete program of the formulation. The new variable \\(u_i\\) is defined in function _create_variables() and the subtour elimination constraints are updated in function _create_subtour_elimination_constraints().\n\nfrom itertools import product\nfrom ortools.linear_solver import pywraplp\n\nclass TspModelV2(TspModel):\n    \n    def __init__(self, name='Tspmodel_v2'):\n        super().__init__(name)\n        \n        self._solver = pywraplp.Solver.CreateSolver('SCIP')\n        self._var_x = None\n        self._var_u = None\n        self._opt_obj = None\n        self._opt_x = None\n        self._opt_route = None\n    \n    def build_model(self):\n        self._create_variables()\n        self._create_objective()\n        self._create_degree_constraints()\n        self._create_subtour_elimination_constraints()\n    \n    def optimize(self, enable_output: bool):\n        if enable_output: self._solver.EnableOutput()\n        status = self._solver.Solve()\n        if status is pywraplp.Solver.OPTIMAL:\n            self._retrieve_opt_solution()\n            self._retrieve_opt_route()\n    \n    def _create_variables(self):\n        self._var_x = {}\n        for i in self._node_list:\n            self._var_x[i] = {\n                j: self._solver.BoolVar(f'x_{i, j}')\n                for j in self._node_list\n                if j != i\n            }\n        \n        self._var_u = {\n            i: self._solver.NumVar(1, self.num_nodes, f'v_{i}')\n            for i in self._node_list\n            if i != 1\n        }\n    \n    def _create_objective(self):\n        node_list = self._node_list\n        expr = [self._distance[i][j] * self._var_x[i][j]\n                for i, j in product(node_list, node_list)\n                if i != j]\n        self._solver.Minimize(self._solver.Sum(expr))\n        \n    def _create_degree_constraints(self):\n        for i in self._node_list:\n            out_expr = [self._var_x[i][j]\n                    for j in self._node_list\n                    if j != i\n                    ]\n            in_expr = [self._var_x[j][i]\n                        for j in self._node_list\n                        if j != i\n                    ]\n            self._solver.Add(self._solver.Sum(out_expr) == 1)\n            self._solver.Add(self._solver.Sum(in_expr) == 1)\n    \n    def _create_subtour_elimination_constraints(self):\n        num_nodes = self.num_nodes\n        for i, j in product(self._node_list, self._node_list):\n            if i == j: continue\n            if i == 1 or j == 1: continue\n            self._solver.Add(self._var_u[i] - \n                            self._var_u[j] +\n                            (num_nodes - 1) * self._var_x[i][j] &lt;=\n                            num_nodes - 2)\n    \n    def _retrieve_opt_solution(self):\n        self._opt_obj = float(self._solver.Objective().Value())\n        self._opt_x = {}\n        for i in self._node_list:\n            self._opt_x[i] = {\n                j: round(self._var_x[i][j].solution_value())\n                for j in self._node_list\n                if j != i\n            }\n            \n        print(f'optimal value = {self._opt_obj:.2f}')\n    \n    def _retrieve_opt_route(self):\n        self._opt_route = []\n        route_start = list(self._opt_x.keys())[0]\n        edge_start = route_start\n        while True:\n            for n in self._opt_x[edge_start]:\n                if self._opt_x[edge_start][n] == 0: continue\n                \n                edge_end = n\n                self._opt_route.append((edge_start, edge_end))\n                break\n            \n            if edge_end == route_start: break\n            edge_start = edge_end\n            \n    def show_opt_route(self):\n        TspVisualizer.show(self._node_coords, self._opt_route)\n        \n        \n    def show_model_info(self):\n        print(f\"Number of variables: {self._solver.NumVariables()}\")\n        print(f\"Number of constraints: {self._solver.NumConstraints()}\")\n\nWe now use this formulation to solve the burma14 instance and show its optimal solution in Figure 6.8.\n\ninstance = './data/tsp/burma14.tsp'\n\nmodel_v2 = TspModelV2()\nmodel_v2.read_inputs(instance_file=instance)\nmodel_v2.build_model()\nmodel_v2.show_model_info()\nmodel_v2.optimize(False)\nmodel_v2.show_opt_route()\n\nNumber of variables: 195\nNumber of constraints: 184\noptimal value = 3323.00\n\n\n\n\n\nFigure 6.8: Optimal route for the burma14 instance\n\n\n\n\nFigure 6.9 shows the optimal solution found by the formulation for the ulysses22 instance.\n\ninstance = './data/tsp/ulysses22.tsp'\n\nmodel_v2 = TspModelV2()\nmodel_v2.read_inputs(instance_file=instance)\nmodel_v2.build_model()\nmodel_v2.show_model_info()\nmodel_v2.optimize(False)\nmodel_v2.show_opt_route()\n\nNumber of variables: 483\nNumber of constraints: 464\noptimal value = 7013.00\n\n\n\n\n\nFigure 6.9: Optimal route for the ulysses22 instance"
  },
  {
    "objectID": "ip-tsp.html#model-3---single-commodity-flow",
    "href": "ip-tsp.html#model-3---single-commodity-flow",
    "title": "6  Traveling Salesman Problem",
    "section": "6.5 Model 3 - Single Commodity Flow",
    "text": "6.5 Model 3 - Single Commodity Flow\nThe model uses two types of decision variables:\n\n\\(x_{ij}\\): a binary variable that equals 1 if arc \\((i, j) \\in \\mathcal{A}\\) shows up in the optimal solution, 0 otherwise\n\\(y_{ij}\\): a continuous variable representing the flow on arc \\((i, j) \\in \\mathcal{A}\\)\n\nThe complete formulation is given below.\n\\[\\begin{align}\n\\text{min.} &\\quad \\sum_{(i, j) \\in \\mathcal{A}} c_{ij} x_{ij} \\label{tsp3-obj} \\\\\n\\text{s.t.} &\\quad \\sum_{j \\in \\mathcal{V},\\  j \\neq i} x_{ij} = 1, \\ \\forall i \\in \\mathcal{V} \\label{tsp3-cons1} \\\\\n&\\quad \\sum_{i \\in \\mathcal{V}, \\ i \\neq j} x_{ij} = 1, \\ \\forall j \\in \\mathcal{V} \\label{tsp3-cons2}\\\\\n&\\quad y_{ij} \\leq (n - 1) x_{ij}, \\ \\forall (i, j) \\in \\mathcal{A} \\label{tsp3-cons3} \\\\\n&\\quad \\sum_{j \\in \\mathcal{V}\\backslash \\{1\\}} y_{1j} = n - 1, \\label{tsp3-cons4} \\\\\n&\\quad \\sum_{i \\in \\mathcal{V}\\backslash \\{j\\}} y_{ij} - \\sum_{k \\in \\mathcal{V}\\backslash \\{j\\}} y_{jk} = 1, \\ \\forall j \\in \\mathcal{V}\\backslash \\{1\\} \\label{tsp3-cons5}\\\\\n&\\quad x_{ij} \\in \\{0, 1\\}, \\ \\forall (i, j) \\in \\mathcal{A} \\label{tsp3-cons6} \\\\\n&\\quad y_{ij} \\geq 0, \\ \\forall (i, j) \\in \\mathcal{A} \\label{tsp3-cons7}\n\\end{align}\\]\nIn this formulation, the constraints \\(\\eqref{tsp3-cons3}\\) - \\(\\eqref{tsp3-cons5}\\) are the subtour elimination constraints. Specifically, constraints \\(\\eqref{tsp3-cons3}\\) make sure that the amount of flow on any arc \\((i, j)\\) is at most \\(n - 1\\) when the arc is active. Constraints \\(\\eqref{tsp3-cons4}\\) state that there is a total of \\(n - 1\\) flowing out of the source node 1. Constraints \\(\\eqref{tsp3-cons5}\\) require that the incoming flow is 1 unit bigger than the outgoing flow at any node other than the source node 1. To see how this prevents subtours, we’ll use Figure 6.10 as an example.\n\n\n\n\n\nflowchart LR\n    1((1)) -- 5 --&gt; 2((2))\n    2 -- 4 --&gt; 3((3))\n    3 -- 4 --&gt; 4((4))\n    4 -- 2 --&gt; 1\n    5((5)) -- v --&gt; 6((6))\n    6 --w--&gt; 5\n\n\nFigure 6.10: Subtour with 2 nodes\n\n\n\n\nAccording to constraints \\(\\eqref{tsp3-cons4}\\), we have the following relations:\n\\[\\begin{align}\n    v - w = 1 \\\\\n    w - v = 1\n\\end{align}\\]\nSumming them together leads to \\(0 = 2\\), which is clearly false.\nThe code below gives the complete implementation of this formulation.\n\nfrom itertools import product\nfrom ortools.linear_solver import pywraplp\n\nclass TspModelV3(TspModel):\n    \n    def __init__(self, name='Tspmodel_v3'):\n        super().__init__(name)\n        \n        self._solver = pywraplp.Solver.CreateSolver('SCIP')\n        self._var_x = None\n        self._var_y = None\n        self._opt_obj = None\n        self._opt_x = None\n        self._opt_route = None\n    \n    def build_model(self):\n        self._create_variables()\n        self._create_objective()\n        self._create_degree_constraints()\n        self._create_subtour_elimination_constraints()\n    \n    def optimize(self, enable_output: bool):\n        if enable_output: self._solver.EnableOutput()\n        status = self._solver.Solve()\n        if status is pywraplp.Solver.OPTIMAL:\n            self._retrieve_opt_solution()\n            self._retrieve_opt_route()\n    \n    def _create_variables(self):\n        self._var_x = {}\n        for i in self._node_list:\n            self._var_x[i] = {\n                j: self._solver.BoolVar(f'x_{i, j}')\n                for j in self._node_list\n                if j != i\n            }\n        \n        infinity = self._solver.Infinity()\n        self._var_y = {}\n        for i in self._node_list:\n            self._var_y[i] = {\n                j: self._solver.NumVar(0, infinity, f'y_{i, j}')\n                for j in self._node_list\n                if j != i\n            }\n        \n    def _create_objective(self):\n        node_list = self._node_list\n        expr = [self._distance[i][j] * self._var_x[i][j]\n                for i, j in product(node_list, node_list)\n                if i != j]\n        self._solver.Minimize(self._solver.Sum(expr))\n        \n    def _create_degree_constraints(self):\n        for i in self._node_list:\n            out_expr = [self._var_x[i][j]\n                    for j in self._node_list\n                    if j != i\n                    ]\n            in_expr = [self._var_x[j][i]\n                        for j in self._node_list\n                        if j != i\n                    ]\n            self._solver.Add(self._solver.Sum(out_expr) == 1)\n            self._solver.Add(self._solver.Sum(in_expr) == 1)\n    \n    def _create_subtour_elimination_constraints(self):\n        num_nodes = self.num_nodes\n        for i, j in product(self._node_list, self._node_list):\n            if i == j: continue\n            self._solver.Add(\n                self._var_y[i][j] &lt;= \n                (num_nodes - 1) * self._var_x[i][j])\n\n        expr = [self._var_y[1][j] for j in self._node_list if j != 1]\n        self._solver.Add(self._solver.Sum(expr) == num_nodes - 1)\n\n        for j in self._node_list:\n            if j == 1: continue\n            expr1 = [self._var_y[i][j] \n                    for i in self._node_list if i != j]\n            expr2 = [self._var_y[j][k]\n                     for k in self._node_list if k != j]\n            self._solver.Add(\n                self._solver.Sum(expr1) - \n                self._solver.Sum(expr2) == 1)\n        \n    \n    def _retrieve_opt_solution(self):\n        self._opt_obj = float(self._solver.Objective().Value())\n        self._opt_x = {}\n        for i in self._node_list:\n            self._opt_x[i] = {\n                j: round(self._var_x[i][j].solution_value())\n                for j in self._node_list\n                if j != i\n            }\n            \n        print(f'optimal value = {self._opt_obj:.2f}')\n    \n    def _retrieve_opt_route(self):\n        self._opt_route = []\n        route_start = list(self._opt_x.keys())[0]\n        edge_start = route_start\n        while True:\n            for n in self._opt_x[edge_start]:\n                if self._opt_x[edge_start][n] == 0: continue\n                \n                edge_end = n\n                self._opt_route.append((edge_start, edge_end))\n                break\n            \n            if edge_end == route_start: break\n            edge_start = edge_end\n            \n    def show_opt_route(self):\n        TspVisualizer.show(self._node_coords, self._opt_route)\n        \n        \n    def show_model_info(self):\n        print(f\"Number of variables: {self._solver.NumVariables()}\")\n        print(f\"Number of constraints: {self._solver.NumConstraints()}\")\n\nFigure 6.11 shows the optimal soution for instance burma14 found by this formulation.\n\ninstance = './data/tsp/burma14.tsp'\n\nmodel_v3 = TspModelV3()\nmodel_v3.read_inputs(instance_file=instance)\nmodel_v3.build_model()\nmodel_v3.show_model_info()\nmodel_v3.optimize(False)\nmodel_v3.show_opt_route()\n\nNumber of variables: 364\nNumber of constraints: 224\noptimal value = 3323.00\n\n\n\n\n\nFigure 6.11: Optimal route for the burma14 instance\n\n\n\n\nFigure 6.12 shows the optimal route found by the formulation for the instance ulysses22.\n\ninstance = './data/tsp/ulysses22.tsp'\n\nmodel_v3 = TspModelV3()\nmodel_v3.read_inputs(instance_file=instance)\nmodel_v3.build_model()\nmodel_v3.show_model_info()\nmodel_v3.optimize(False)\nmodel_v3.show_opt_route()\n\nNumber of variables: 924\nNumber of constraints: 528\noptimal value = 7013.00\n\n\n\n\n\nFigure 6.12: Optimal route for the ulysses22 instance\n\n\n\n\nFigure 6.13 gives the optimal solution of instance berlin52.\n\ninstance = './data/tsp/berlin52.tsp'\n\nmodel_v3 = TspModelV3()\nmodel_v3.read_inputs(instance_file=instance)\nmodel_v3.build_model()\nmodel_v3.show_model_info()\nmodel_v3.optimize(False)\nmodel_v3.show_opt_route()\n\nNumber of variables: 5304\nNumber of constraints: 2808\noptimal value = 7542.00\n\n\n\n\n\nFigure 6.13: Optimal route for the berlin52 instance\n\n\n\n\nFigure 6.14 shows the optimal solution for instance pr16.\n\ninstance = './data/tsp/pr76.tsp'\n\nmodel_v3 = TspModelV3()\nmodel_v3.read_inputs(instance_file=instance)\nmodel_v3.build_model()\nmodel_v3.show_model_info()\nmodel_v3.optimize(False)\nmodel_v3.show_opt_route()\n\nNumber of variables: 11400\nNumber of constraints: 5928\noptimal value = 108159.00\n\n\n\n\n\nFigure 6.14: Optimal route for the pr76 instance"
  },
  {
    "objectID": "ip-tsp.html#model-4---two-commodity-flow",
    "href": "ip-tsp.html#model-4---two-commodity-flow",
    "title": "6  Traveling Salesman Problem",
    "section": "6.6 Model 4 - Two Commodity Flow",
    "text": "6.6 Model 4 - Two Commodity Flow\nThe model uses three types of decision variables:\n\n\\(x_{ij}\\): a binary variable that equals 1 if arc \\((i, j) \\in \\mathcal{A}\\) shows up in the optimal solution, 0 otherwise\n\\(y_{ij}\\): a continuous variable representing the flow of commodity 1 on arc \\((i, j) \\in \\mathcal{A}\\)\n\\(z_{ij}\\): a continuous variable representing the flow of commodity 2 on arc \\((i, j) \\in \\mathcal{A}\\)\n\nThe complete formulation is given below.\n\\[\\begin{align}\n\\text{min.} &\\quad \\sum_{(i, j) \\in \\mathcal{A}} c_{ij} x_{ij} \\label{tsp4-obj} \\\\\n\\text{s.t.} &\\quad \\sum_{j \\in \\mathcal{V},\\  j \\neq i} x_{ij} = 1, \\ \\forall i \\in \\mathcal{V} \\label{tsp4-cons1} \\\\\n&\\quad \\sum_{i \\in \\mathcal{V}, \\ i \\neq j} x_{ij} = 1, \\ \\forall j \\in \\mathcal{V} \\label{tsp4-cons2}\\\\\n&\\quad \\sum_{j \\in \\mathcal{V}\\backslash\\{1\\}} (y_{1j} - y_{j1}) = n - 1 \\label{tsp4-cons3} \\\\\n&\\quad \\sum_{j \\in \\mathcal{V}, j \\neq i} (y_{ij} - y_{ji}) = -1, \\ \\forall i \\in \\mathcal{V} \\backslash \\{1\\} \\label{tsp4-cons4} \\\\\n&\\quad \\sum_{j \\in \\mathcal{V}\\backslash\\{1\\}} (z_{1j} - z_{j1}) = -(n - 1) \\label{tsp4-cons5} \\\\\n&\\quad \\sum_{j \\in \\mathcal{V}, j \\neq i} (z_{ij} - z_{ji}) = 1, \\ \\forall i \\in \\mathcal{V} \\backslash \\{1\\}  \\label{tsp4-cons6}\\\\\n&\\quad \\sum_{j \\in \\mathcal{V} , j \\neq i} (y_{ij} + z_{ij}) = n - 1, \\ \\forall i \\in \\mathcal{V}  \\label{tsp4-cons7}\\\\\n&\\quad y_{ij} + z_{ij} = (n - 1) x_{ij}, \\ \\forall (i, j) \\in \\mathcal{A} \\label{tsp4-cons8} \\\\\n&\\quad x_{ij} \\in \\{0, 1\\}, \\ \\forall (i, j) \\in \\mathcal{A} \\label{tsp4-cons9} \\\\\n&\\quad y_{ij} \\geq 0, \\ \\forall (i, j) \\in \\mathcal{A} \\label{tsp4-cons10}  \\\\\n&\\quad z_{ij} \\geq 0, \\ \\forall (i, j) \\in \\mathcal{A} \\label{tsp4-cons11}\n\\end{align}\\]\nIn this formulation, constraints \\(\\eqref{tsp4-cons3}\\) - \\(\\eqref{tsp4-cons8}\\) together serve as the subtour elimination constraints. To better understand the two commodity flow formulation, we’ll use Figure 6.15 as an example. At the source node 1, there is \\(n-1\\) units of commodity 1 leaving the node and there is no unit of commodity 2 leaving it. At each subsequent node, the amount of commodity 1 decreases by 1 unit while the amount of commodity 2 increases by 1 unit. On any arc in the tour, the total amount of commodities is always \\(n - 1\\).\n\n\n\n\n\nflowchart LR\n    1((1)) -- c1: 3, c2:0 --&gt; 2((2))\n    2 -- c1: 2, c2:1 --&gt; 3((3))\n    3 -- c1: 1, c2:2 --&gt; 4((4))\n    4 -- c1: 0, c2:3 --&gt; 1\n\n\nFigure 6.15: Two commodities flowing on the tour\n\n\n\n\nThe code below gives the complete implementation of the two commodity flow formulation.\n\nfrom itertools import product\nfrom ortools.linear_solver import pywraplp\n\nclass TspModelV4(TspModel):\n    \n    def __init__(self, name='Tspmodel_v4'):\n        super().__init__(name)\n        \n        self._solver = pywraplp.Solver.CreateSolver('SCIP')\n        self._var_x = None\n        self._var_y = None\n        self._var_z = None\n        self._opt_obj = None\n        self._opt_x = None\n        self._opt_route = None\n    \n    def build_model(self):\n        self._create_variables()\n        self._create_objective()\n        self._create_degree_constraints()\n        self._create_subtour_elimination_constraints()\n    \n    def optimize(self, enable_output: bool):\n        if enable_output: self._solver.EnableOutput()\n        status = self._solver.Solve()\n        if status is pywraplp.Solver.OPTIMAL:\n            self._retrieve_opt_solution()\n            self._retrieve_opt_route()\n    \n    def _create_variables(self):\n        self._var_x = {}\n        for i in self._node_list:\n            self._var_x[i] = {\n                j: self._solver.BoolVar(f'x_{i, j}')\n                for j in self._node_list\n                if j != i\n            }\n        \n        infinity = self._solver.Infinity()\n        self._var_y = {}\n        for i in self._node_list:\n            self._var_y[i] = {\n                j: self._solver.NumVar(0, infinity, f'y_{i, j}')\n                for j in self._node_list\n                if j != i\n            }\n        \n        self._var_z = {}\n        for i in self._node_list:\n            self._var_z[i] = {\n                j: self._solver.NumVar(0, infinity, f'z_{i, j}')\n                for j in self._node_list\n                if j != i\n            }\n        \n    def _create_objective(self):\n        node_list = self._node_list\n        expr = [self._distance[i][j] * self._var_x[i][j]\n                for i, j in product(node_list, node_list)\n                if i != j]\n        self._solver.Minimize(self._solver.Sum(expr))\n        \n    def _create_degree_constraints(self):\n        for i in self._node_list:\n            out_expr = [self._var_x[i][j]\n                    for j in self._node_list\n                    if j != i\n                    ]\n            in_expr = [self._var_x[j][i]\n                        for j in self._node_list\n                        if j != i\n                    ]\n            self._solver.Add(self._solver.Sum(out_expr) == 1)\n            self._solver.Add(self._solver.Sum(in_expr) == 1)\n    \n    def _create_subtour_elimination_constraints(self):\n        num_nodes = self.num_nodes\n        expr1 = [self._var_y[1][j] \n                for j in self._node_list \n                if j != 1]\n        expr2 = [self._var_y[j][1] \n                for j in self._node_list \n                if j != 1]\n        self._solver.Add(\n            self._solver.Sum(expr1) - \n            self._solver.Sum(expr2) == \n            num_nodes - 1)\n\n        for i in self._node_list:\n            if i == 1: continue\n            expr1 = [self._var_y[i][j] \n                    for j in self._node_list \n                    if j != i]\n            expr2 = [self._var_y[j][i] \n                    for j in self._node_list \n                    if j != i]\n            self._solver.Add(\n                self._solver.Sum(expr1) - \n                self._solver.Sum(expr2) == \n                -1)\n            \n        expr1 = [self._var_z[1][j] \n                for j in self._node_list \n                if j != 1]\n        expr2 = [self._var_z[j][1] \n                for j in self._node_list \n                if j != 1]\n        self._solver.Add(\n            self._solver.Sum(expr1) - \n            self._solver.Sum(expr2) == \n            -num_nodes + 1)\n\n        for i in self._node_list:\n            if i == 1: continue\n            expr1 = [self._var_z[i][j] \n                    for j in self._node_list \n                    if j != i]\n            expr2 = [self._var_z[j][i] \n                    for j in self._node_list \n                    if j != i]\n            self._solver.Add(\n                self._solver.Sum(expr1) - \n                self._solver.Sum(expr2) == \n                1)\n        \n        for i in self._node_list:\n            expr1 = [self._var_y[i][j] \n                    for j in self._node_list \n                    if j != i]\n            expr2 = [self._var_z[i][j] \n                    for j in self._node_list \n                    if j != i]\n            self._solver.Add(\n                self._solver.Sum(expr1) + \n                self._solver.Sum(expr2) == \n                num_nodes - 1)\n        \n        for i, j in product(self._node_list, self._node_list):\n            if i == j: continue\n            self._solver.Add(\n                self._var_y[i][j] + \n                self._var_z[i][j] == \n                (num_nodes - 1) * \n                self._var_x[i][j])\n        \n    \n    def _retrieve_opt_solution(self):\n        self._opt_obj = float(self._solver.Objective().Value())\n        self._opt_x = {}\n        for i in self._node_list:\n            self._opt_x[i] = {\n                j: round(self._var_x[i][j].solution_value())\n                for j in self._node_list\n                if j != i\n            }\n            \n        print(f'optimal value = {self._opt_obj:.2f}')\n    \n    def _retrieve_opt_route(self):\n        self._opt_route = []\n        route_start = list(self._opt_x.keys())[0]\n        edge_start = route_start\n        while True:\n            for n in self._opt_x[edge_start]:\n                if self._opt_x[edge_start][n] == 0: continue\n                \n                edge_end = n\n                self._opt_route.append((edge_start, edge_end))\n                break\n            \n            if edge_end == route_start: break\n            edge_start = edge_end\n            \n    def show_opt_route(self):\n        TspVisualizer.show(self._node_coords, self._opt_route)\n        \n        \n    def show_model_info(self):\n        print(f\"Number of variables: {self._solver.NumVariables()}\")\n        print(f\"Number of constraints: {self._solver.NumConstraints()}\")\n\nFigure 6.16 shows the optimals solution identified by the formulation for instance burma14.\n\ninstance = './data/tsp/burma14.tsp'\n\nmodel_v4 = TspModelV4()\nmodel_v4.read_inputs(instance_file=instance)\nmodel_v4.build_model()\nmodel_v4.show_model_info()\nmodel_v4.optimize(False)\nmodel_v4.show_opt_route()\n\nNumber of variables: 546\nNumber of constraints: 252\noptimal value = 3323.00\n\n\n\n\n\nFigure 6.16: Optimal route for the burma14 instance\n\n\n\n\nFigure 6.17 gives the optimal solution of the ulysses22 instance.\n\ninstance = './data/tsp/ulysses22.tsp'\n\nmodel_v4 = TspModelV4()\nmodel_v4.read_inputs(instance_file=instance)\nmodel_v4.build_model()\nmodel_v4.show_model_info()\nmodel_v4.optimize(False)\nmodel_v4.show_opt_route()\n\nNumber of variables: 1386\nNumber of constraints: 572\noptimal value = 7013.00\n\n\n\n\n\nFigure 6.17: Optimal route for the ulysses22 instance\n\n\n\n\nFigure 6.18 shows the optimals solution identified by the formulation for instance berlin52.\n\ninstance = './data/tsp/berlin52.tsp'\n\nmodel_v4 = TspModelV4()\nmodel_v4.read_inputs(instance_file=instance)\nmodel_v4.build_model()\nmodel_v4.show_model_info()\nmodel_v4.optimize(False)\nmodel_v4.show_opt_route()\n\nNumber of variables: 7956\nNumber of constraints: 2912\noptimal value = 7542.00\n\n\n\n\n\nFigure 6.18: Optimal route for the berlin52 instance"
  },
  {
    "objectID": "ip-tsp.html#model-5---multi-commodity-flow",
    "href": "ip-tsp.html#model-5---multi-commodity-flow",
    "title": "6  Traveling Salesman Problem",
    "section": "6.7 Model 5 - Multi-Commodity Flow",
    "text": "6.7 Model 5 - Multi-Commodity Flow\nThe model uses two types of decision variables:\n\n\\(x_{ij}\\): a binary variable that equals 1 if arc \\((i, j) \\in \\mathcal{A}\\) shows up in the optimal solution, 0 otherwise\n\\(y_{ij}^k\\): a continuous variable representing the flow of commodity \\(k\\) on arc \\((i, j) \\in \\mathcal{A}\\), \\(k \\in \\mathcal{V} \\backslash \\{1\\}\\)\n\nThe complete formulation of the problem is presented below. To understand this formulation, let’s imagine that node 1 is the source node in the graph, and each of the remaining nodes demands one unit of different commodities. For instance, node 2 requires one unit of commodity 2, node 3 requires one unit of commodity 3, and so on. The problem can then be expressed as finding the most cost-effective graph that can handle the flow of all \\(n-1\\) commodities. Constraints \\(\\eqref{tsp5-cons1}\\) and \\(\\eqref{tsp5-cons2}\\) are the same as in other formulations. Constraints \\(\\eqref{tsp5-cons3}\\) state that the arc connecting nodes (i,j) must be active to allow any commodity flow, essentially acting as a capacity constraint that limits the flow on the arc. Constraints \\(\\eqref{tsp5-cons4}\\) indicate that exactly one unit of each commodity k flows out of the source node 1. Constraints \\(\\eqref{tsp5-cons5}\\) require that no commodity flows into the source node 1. Constraints \\(\\eqref{tsp5-cons6}\\) ensure that one unit of commodity k flows into node k, and constraints \\(\\eqref{tsp5-cons7}\\) require that there is no flow of commodity k out of node k. Finally, constraints \\(\\eqref{tsp5-cons8}\\) are flow conservation constraints that guarantee that the incoming flow is equal to the outgoing flow at all nodes except the source node for every commodity k.\n\\[\\begin{align}\n\\text{min.} &\\quad \\sum_{(i, j) \\in \\mathcal{A}} c_{ij} x_{ij} \\label{tsp5-obj} \\\\\n\\text{s.t.} &\\quad \\sum_{j \\in \\mathcal{V},\\  j \\neq i} x_{ij} = 1, \\ \\forall i \\in \\mathcal{V} \\label{tsp5-cons1} \\\\\n&\\quad \\sum_{i \\in \\mathcal{V}, \\ i \\neq j} x_{ij} = 1, \\ \\forall j \\in \\mathcal{V} \\label{tsp5-cons2}\\\\\n&\\quad y_{ij}^k \\leq x_{ij}, \\ \\forall (i, j) \\in \\mathcal{A}, k \\in \\mathcal{V} \\backslash \\{1\\} \\label{tsp5-cons3}\\\\\n&\\quad \\sum_{j \\in \\mathcal{V} \\backslash \\{1\\}} y_{1j}^k = 1, \\ \\forall k \\in \\mathcal{V} \\backslash \\{1\\}  \\label{tsp5-cons4} \\\\\n&\\quad \\sum_{j \\in \\mathcal{V} \\backslash \\{1\\}} y_{j1}^k = 0, \\ \\forall k \\in \\mathcal{V} \\backslash \\{1\\} \\label{tsp5-cons5} \\\\\n&\\quad \\sum_{j \\in \\mathcal{V} \\backslash \\{k\\}} y_{jk}^k = 1, \\ \\forall k \\in \\mathcal{V} \\backslash \\{1\\} \\label{tsp5-cons6} \\\\\n&\\quad \\sum_{j \\in \\mathcal{V} \\backslash \\{k\\}} y_{kj}^k = 0, \\ \\forall k \\in \\mathcal{V} \\backslash \\{1\\} \\label{tsp5-cons7} \\\\\n&\\quad \\sum_{i \\in \\mathcal{V} \\backslash \\{j\\}} y_{ij}^k - \\sum_{i \\in \\mathcal{V} \\backslash \\{j\\}} y_{ji}^k = 0, \\ \\forall j, k \\in \\mathcal{V} \\backslash \\{1\\}, j \\neq k \\label{tsp5-cons8} \\\\\n&\\quad x_{ij} = \\{0, 1\\}, \\ \\forall (i, j) \\in \\mathcal{A} \\label{tsp5-cons9}\\\\\n&\\quad y_{ij} \\geq 0, \\ \\forall (i, j) \\in \\mathcal{A}, k \\in \\mathcal{V} \\backslash \\{1\\} \\label{tsp5-cons10}\n\\end{align}\\]\n\nfrom itertools import product\nfrom ortools.linear_solver import pywraplp\n\nclass TspModelV5(TspModel):\n    \n    def __init__(self, name='Tspmodel_v5'):\n        super().__init__(name)\n        \n        self._solver = pywraplp.Solver.CreateSolver('SCIP')\n        self._var_x = None\n        self._var_y = None\n        self._opt_obj = None\n        self._opt_x = None\n        self._opt_route = None\n    \n    def build_model(self):\n        self._create_variables()\n        self._create_objective()\n        self._create_degree_constraints()\n        self._create_subtour_elimination_constraints()\n    \n    def optimize(self, enable_output: bool):\n        if enable_output: self._solver.EnableOutput()\n        status = self._solver.Solve()\n        if status is pywraplp.Solver.OPTIMAL:\n            self._retrieve_opt_solution()\n            self._retrieve_opt_route()\n    \n    def _create_variables(self):\n        self._var_x = {}\n        for i in self._node_list:\n            self._var_x[i] = {\n                j: self._solver.BoolVar(f'x_{i, j}')\n                for j in self._node_list\n                if j != i\n            }\n        \n        infinity = self._solver.Infinity()\n        self._var_y = {}\n        for k in self._node_list[1:]:\n            vars = {}\n            for i in self._node_list:\n                vars[i] = {\n                    j: self._solver.NumVar(0, infinity, f'y_{i, j}')\n                    for j in self._node_list\n                    if j != i\n                }\n            self._var_y[k] = vars\n        \n    def _create_objective(self):\n        node_list = self._node_list\n        expr = [self._distance[i][j] * self._var_x[i][j]\n                for i, j in product(node_list, node_list)\n                if i != j]\n        self._solver.Minimize(self._solver.Sum(expr))\n        \n    def _create_degree_constraints(self):\n        for i in self._node_list:\n            out_expr = [self._var_x[i][j]\n                    for j in self._node_list\n                    if j != i\n                    ]\n            in_expr = [self._var_x[j][i]\n                        for j in self._node_list\n                        if j != i\n                    ]\n            self._solver.Add(self._solver.Sum(out_expr) == 1)\n            self._solver.Add(self._solver.Sum(in_expr) == 1)\n    \n    def _create_subtour_elimination_constraints(self):\n        for k in self._node_list[1:]:\n            for i, j in product(self._node_list, self._node_list):\n                if i == j: continue\n                self._solver.Add(self._var_y[k][i][j] &lt;= self._var_x[i][j])\n        \n        for k in self._node_list[1:]:\n            expr = [self._var_y[k][1][j]\n                    for j in self._node_list\n                    if j != 1]\n            self._solver.Add(self._solver.Sum(expr) == 1)\n            \n            expr = [self._var_y[k][j][1]\n                    for j in self._node_list\n                    if j != 1]\n            self._solver.Add(self._solver.Sum(expr) == 0)\n            \n            expr = [self._var_y[k][j][k]\n                    for j in self._node_list\n                    if j != k]\n            self._solver.Add(self._solver.Sum(expr) == 1)\n\n            expr = [self._var_y[k][k][j]\n                    for j in self._node_list\n                    if j != k]\n            self._solver.Add(self._solver.Sum(expr) == 0)\n\n        for j, k in product(self._node_list[1:], \n                            self._node_list[1:]):\n            if j == k: continue\n            expr1 = [self._var_y[k][i][j]\n                    for i in self._node_list\n                    if i != j]\n            expr2 = [self._var_y[k][j][i]\n                    for i in self._node_list\n                    if i != j]\n            self._solver.Add(self._solver.Sum(expr1) == \n                            self._solver.Sum(expr2))\n        \n    \n    def _retrieve_opt_solution(self):\n        self._opt_obj = float(self._solver.Objective().Value())\n        self._opt_x = {}\n        for i in self._node_list:\n            self._opt_x[i] = {\n                j: round(self._var_x[i][j].solution_value())\n                for j in self._node_list\n                if j != i\n            }\n            \n        print(f'optimal value = {self._opt_obj:.2f}')\n    \n    def _retrieve_opt_route(self):\n        self._opt_route = []\n        route_start = list(self._opt_x.keys())[0]\n        edge_start = route_start\n        while True:\n            for n in self._opt_x[edge_start]:\n                if self._opt_x[edge_start][n] == 0: continue\n                \n                edge_end = n\n                self._opt_route.append((edge_start, edge_end))\n                break\n            \n            if edge_end == route_start: break\n            edge_start = edge_end\n            \n    def show_opt_route(self):\n        TspVisualizer.show(self._node_coords, self._opt_route)\n        \n        \n    def show_model_info(self):\n        print(f\"Number of variables: {self._solver.NumVariables()}\")\n        print(f\"Number of constraints: {self._solver.NumConstraints()}\")\n\n\ninstance = './data/tsp/burma14.tsp'\n\nmodel_v5 = TspModelV5()\nmodel_v5.read_inputs(instance_file=instance)\nmodel_v5.build_model()\nmodel_v5.show_model_info()\nmodel_v5.optimize(False)\nmodel_v5.show_opt_route()\n\nNumber of variables: 2548\nNumber of constraints: 2602\noptimal value = 3323.00\n\n\n\n\n\nFigure 6.19: Optimal route for the burma14 instance\n\n\n\n\n\ninstance = './data/tsp/ulysses22.tsp'\n\nmodel_v5 = TspModelV5()\nmodel_v5.read_inputs(instance_file=instance)\nmodel_v5.build_model()\nmodel_v5.show_model_info()\nmodel_v5.optimize(False)\nmodel_v5.show_opt_route()\n\nNumber of variables: 10164\nNumber of constraints: 10250\noptimal value = 7013.00\n\n\n\n\n\nFigure 6.20: Optimal route for the ulysses22 instance\n\n\n\n\n\ninstance = './data/tsp/berlin52.tsp'\n\nmodel_v5 = TspModelV5()\nmodel_v5.read_inputs(instance_file=instance)\nmodel_v5.build_model()\nmodel_v5.show_model_info()\nmodel_v5.optimize(False)\nmodel_v5.show_opt_route()\n\nNumber of variables: 137904\nNumber of constraints: 138110\noptimal value = 7542.00\n\n\n\n\n\nFigure 6.21: Optimal route for the berlin52 instance"
  },
  {
    "objectID": "ip-tsp.html#performance-comparison",
    "href": "ip-tsp.html#performance-comparison",
    "title": "6  Traveling Salesman Problem",
    "section": "6.8 Performance Comparison",
    "text": "6.8 Performance Comparison\nWe give in Table 6.1 the computational times required to find the optimal solutions for different instances. It is by no means a thorough or comprehensive performance comparison, as it is only based on one run and on a few instances. It can be seen from the table that the single commodity flow formulation seems to perform the best among all the five formulations.\n\n\n\n\nTable 6.1: Computational time comparison of the five formulations\n\n\nInstance\nModel 1\nModel 2\nModel 3\nModel 4\nModel 5\n\n\n\n\nburma14\n2.9s\n0.4s\n0.2s\n0.6s\n0.3s\n\n\nulysses22\n-\n7m25s\n7.2s\n19.8s\n2.8s\n\n\nberlin52\n-\n-\n8.6s\n13.8s\n18m23s\n\n\npr76\n-\n-\n10m51s\n-\n-\n\n\n\n\n\n\n\n\n\n\nDantzig, G., R. Fulkerson, and S. Johnson. 1954. “Solution of a Large-Scale Traveling-Salesman Problem.” Journal of the Operations Research Society of America 2 (4): 393–410. https://doi.org/10.1287/opre.2.4.393.\n\n\nMiller, C. E., A. W. Tucker, and R. A. Zemlin. 1960. “Integer Programming Formulation of Traveling Salesman Problems.” Journal of the ACM 7 (4): 326–29. https://doi.org/10.1145/321043.321046."
  },
  {
    "objectID": "ip-cvrp.html#cvrp-instances",
    "href": "ip-cvrp.html#cvrp-instances",
    "title": "7  Capacitated Vehicle Routing Problem",
    "section": "7.1 CVRP Instances",
    "text": "7.1 CVRP Instances\nWe use the instances taken from CVRPLIB (2014) to illustrate the modeling and solving process with Google OR-Tools. CVRPLIB (2014) contains many benchmarking instances for CVRP and we use the python package vrplib to load the instance P-n16-k8.vrp and its optimal solution P-n16-k8.sol.\n\n# install vrplib with command: pip install vrplib\nimport vrplib\n\n# Read VRPLIB formatted instances (default)\ninstance = vrplib.read_instance(\"./data/cvrp/P-n16-k8.vrp\")\nsolution = vrplib.read_solution(\"./data/cvrp/P-n16-k8.sol\")\n\nLet’s first create a function to visualize vehicle routes, as given below.\n\nimport networkx as nx\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\n\ndef show_vehicle_routes(locations, edges):\n    \"\"\"draw vehicles routings\n    adapted from https://stackoverflow.com/a/50682819\n    \n    examples:\n    locations = {\n        0: (5, 5),\n        1: (4, 9),\n        2: (6, 4),\n        3: (2, 6),\n    }\n\n    edges = [\n        (0, 1, {'vehicle': '0'}),\n        (1, 2, {'vehicle': '0'}),\n        (2, 0, {'vehicle': '0'}),\n        (0, 3, {'vehicle': '1'}),\n        (3, 0, {'vehicle': '1'}),\n    ]\n\n    Args:\n        locations (dict): location id -&gt; (lat, lon)\n        edges (list): list of edges\n    \"\"\"\n    G = nx.DiGraph()\n    G.add_edges_from(edges)\n    plt.figure(figsize=(15,10))\n    \n    vehicles = set([e[2]['vehicle'] for e in edges])\n    num_vehicles = len(vehicles)\n    \n    colors = mpl.colormaps[\"Set1\"].colors\n    for v in range(num_vehicles):\n        temp = [e for e in edges if e[2]['vehicle'] == str(v)]\n        \n        color_idx = v \n        if color_idx &gt;= len(colors):\n            color_idx = color_idx % len(colors)\n        color = np.array([colors[color_idx]])\n        \n        nx.draw_networkx_nodes(G, \n                                locations, \n                                nodelist=[x[0] for x in temp], \n                                node_color=color)\n        nx.draw_networkx_edges(G,\n                                locations, \n                                edgelist=temp,\n                                width=4, \n                                edge_color=color, \n                                style='dashed')\n\n    #let's color the node 0 in black\n    nx.draw_networkx_nodes(G, locations, \n                            nodelist=[0], \n                            node_color='k')\n\n    # labels\n    nx.draw_networkx_labels(G, locations, \n                            font_color='w', \n                            font_size=12, \n                            font_family='sans-serif')\n\n    #print out the graph\n    plt.axis('off')\n    plt.show()\n\nFigure 7.1 shows the optimal vehicle routes for the instance P-n16-k8.vrp.\n\n\nCode\n# visualize the optimal solution\nnode_coords = instance['node_coord']\nlocations = {}\nfor idx, coord in enumerate(node_coords):\n    locations[idx] = (coord[0], coord[1])\n\nroutes = solution['routes']\nvehicle_idx = 0\nedges = []\nfor route in routes:\n    r_temp = route.copy()\n    r_temp.insert(0, 0)\n    r_temp.insert(len(r_temp), 0)\n    for i in range(len(r_temp) - 1):\n        edges.append((r_temp[i], r_temp[i + 1], {'vehicle': str(vehicle_idx)}))\n    \n    vehicle_idx += 1\n\nshow_vehicle_routes(locations, edges)\n\n\n\n\n\nFigure 7.1: Optimal routes for instance P-n16-k8.vrp"
  },
  {
    "objectID": "ip-cvrp.html#two-index-formulation---1",
    "href": "ip-cvrp.html#two-index-formulation---1",
    "title": "7  Capacitated Vehicle Routing Problem",
    "section": "7.2 Two-index Formulation - 1",
    "text": "7.2 Two-index Formulation - 1\nThis formulation was proposed by Laporte, Mercure, and Nobert (1986) and we present the formulation given in Toth and Vigo (2014). In this formulation, we define the variable \\(x_{ij}\\) that equals 1 if the arc \\((i, j)\\) is traversed by a vehicle. The complete model is given below.\n\\[\\begin{align}\n    \\text{min.} &\\quad \\sum_{(i, j) \\in \\mathcal{A}} c_{ij} x_{ij} \\label{cvrp-two-index-obj} \\\\\n    \\text{s.t.} &\\quad \\sum_{j \\in \\delta^+(i)}x_{ij} = 1, \\ \\forall i \\in \\mathcal{N} \\label\n    {cvrp-two-index-cons1}\\\\\n    &\\quad \\sum_{i \\in \\delta^-(j)} x_{ij} = 1, \\ \\forall j \\in \\mathcal{N} \\label{cvrp-two-index-cons2} \\\\\n    &\\quad \\sum_{j \\in \\delta^+(0)} x_{oj} = |\\mathcal{K}| \\label{cvrp-two-index-cons3} \\\\\n    &\\quad \\sum_{(i, j) \\in \\delta^+(S)} x_{ij} \\geq r(S), \\ \\forall S \\subseteq \\mathcal{N}, S \\neq \\emptyset \\label{cvrp-two-index-cons4} \\\\\n    &\\quad x_{ij} \\in \\{0, 1\\}, \\ \\forall (i, j) \\in \\mathcal{A} \\label{cvrp-two-index-cons5}\n\\end{align}\\]\nThe objective function represented by equation \\(\\eqref{cvrp-two-index-obj}\\) is to minimize the overall transportation costs. The constraints expressed in equations \\(\\eqref{cvrp-two-index-cons1}\\) and \\(\\eqref{cvrp-two-index-cons2}\\) work together to guarantee that each customer is visited only once, with one incoming and outgoing arc. Constraints \\(\\eqref{cvrp-two-index-cons3}\\) ensure that all available vehicles are utilized to serve the customers. Constraints \\(\\eqref{cvrp-two-index-cons4}\\) prevent the formation of sub-tours. Finally, the variable types are defined by the last set of constraints, which are presented in equation \\(\\eqref{cvrp-two-index-cons5}\\).\nTo solve the aforementioned instance, we’ll first prepare the data for our following implementation use. Let’s first define two classes, Node and Vehicle, to represent a node in the network and the vechiles, respectively.\n\nclass Node:\n    \"\"\"a node is either a depot (0) or a customer\n    \"\"\"\n    \n    def __init__(self, id, x_coord=0, y_coord=0, demand=0):\n        self._id = id\n        self._x_coord = x_coord\n        self._y_coord = y_coord\n        self._demand = demand\n        \n    @property\n    def id(self): return self._id\n    \n    @property\n    def x_coord(self): return self._x_coord\n    \n    @property\n    def y_coord(self): return self._y_coord\n    \n    @property\n    def demand(self): return self._demand\n    \n    def __str__(self):\n        return f\"id: {self._id},\\\n            x_coord: {self._x_coord},\\\n            y_coord: {self._y_coord},\\\n            demand: {self._demand}\"\n\n\nclass Vehicle:\n    \"\"\"a vehicle\n    \"\"\"\n    \n    def __init__(self, id, capacity):\n        self._id = id\n        self._capacity = capacity\n        \n    @property\n    def id(self): return self._id\n    \n    @property\n    def capacity(self): return self._capacity\n    \n    def __str__(self):\n        return f\"id: {self._id}, capacity: {self._capacity}\"\n\nNow let’s define a class CvrpDataCenter to hold all the information we need later. It also has a helper function to read and parse a CVRP instance.\n\nfrom typing import List\nimport vrplib\nimport re\nfrom itertools import combinations\n\nclass CvrpDataCenter:\n    \"\"\"this class manages all the data for a CVRP instance\n    \"\"\"\n    \n    def __init__(self):\n        self._nodes: List = None\n        self._vehicles: List = None\n        self._distance: List[List] = None\n\n    def read_cvrp_instance(self, instance_file):\n        \"\"\"read a given cvrp instance\n\n        Args:\n            instance_file (str): instance file\n        \"\"\"\n        instance = vrplib.read_instance(instance_file)\n\n        # gather nodes\n        nodes = []\n        idx = 0\n        if 'node_coord' in instance:\n            for node, demand in zip(instance['node_coord'], \n                                    instance['demand']):\n                node = Node(id=idx, \n                            x_coord=node[0], \n                            y_coord=node[1], \n                            demand=demand)\n                idx += 1\n                nodes.append(node)\n        else:\n            for demand in instance['demand']:\n                node = Node(id=idx, \n                            demand=demand)\n                idx += 1\n                nodes.append(node)\n            \n        # gather vehicles\n        comment = instance['comment']\n        num_vehicles = int(re.search(r'\\d', comment).group())\n        vehicles = []\n        for v in range(num_vehicles):\n            vehicle = Vehicle(v, int(instance['capacity']))\n            vehicles.append(vehicle)\n        \n        # gather distance matrix\n        distance = instance['edge_weight']\n        \n        self._nodes = nodes\n        self._vehicles = vehicles\n        self._distance = distance\n    \n    @property\n    def nodes(self): return self._nodes\n    \n    @property\n    def vehicles(self): return self._vehicles\n    \n    @property\n    def num_nodes(self): return len(self._nodes)\n    \n    @property\n    def num_vehicles(self): return len(self._vehicles)\n    \n    @property\n    def vehicle_capacity(self): \n        return self._vehicles[0].capacity\n\n    def distance(self, i, j, integer=False):\n        return round(self._distance[i][j]) \\\n            if integer else self._distance[i][j]\n    \n    def get_all_combinations(self, numbers):\n        combs = []\n        for i in range(1, len(numbers) + 1):\n            combs.extend(list(combinations(numbers, i)))\n        return combs\n\nTo implement this formulation using Google OR-Tools, we first create a CvrpDataCenter object and read in the instance P-n16-k8.vrp. Then we create a solver object with solver option SCIP to solve mixed integer programming problems.\n\nfrom ortools.linear_solver import pywraplp\nimport numpy as np\nfrom itertools import product\nimport math\n\n# prepare instance\ncvrp_data_center = CvrpDataCenter()\ncvrp_data_center.read_cvrp_instance(\"./data/cvrp/P-n16-k8-mini.vrp\")\n\n# instantiate solver\nsolver = pywraplp.Solver.CreateSolver('SCIP')\n\nNow let’s create the decision variable \\(x_{ij}\\). Note that we don’t need to create variables when \\(i = j\\) since there is no arc pointing to itself in the graph \\(\\mathcal{G}\\) we defined earlier.\n\n# create decision variables\nnum_nodes = cvrp_data_center.num_nodes\nnum_vehicles = cvrp_data_center.num_vehicles\nvar_x = np.empty((num_nodes, num_nodes), dtype=object)\nfor i, j in product(range(num_nodes), range(num_nodes)):\n    if i == j: continue\n    var_x[i][j] = solver.BoolVar(name=\"x_{i, j}\")\n\nThen we create the objective function.\n\n# define objective function\nobj_expr = [\n    cvrp_data_center.distance(i, j, integer=True) * var_x[i][j]\n    for i, j in product(range(num_nodes), range(num_nodes))\n    if i != j\n]\nsolver.Minimize(solver.Sum(obj_expr))\n\nAnd we create the constraints \\(\\eqref{cvrp-two-index-cons1}\\) and \\(\\eqref{cvrp-two-index-cons2}\\).\n\n# create incoming and outgoing arc constraints\nfor i in range(1, num_nodes):\n    out_arcs = [var_x[i][j] for j in range(num_nodes) if j != i]\n    in_arcs = [var_x[j][i] for j in range(num_nodes) if j != i]\n    solver.Add(solver.Sum(out_arcs) == 1)\n    solver.Add(solver.Sum(in_arcs) == 1)\n\nConstraints \\(\\eqref{cvrp-two-index-cons3}\\) are created as follows.\n\n# create fleet size constraint\nexpr = [var_x[0][i] for i in range(1, num_nodes)]\nsolver.Add(solver.Sum(expr) == num_vehicles)\n\nTo create the subtour elimination constraints \\(\\eqref{cvrp-two-index-cons4}\\), we first need to enumerate all the non-empty subset of \\(\\mathcal{N}\\), for which we define a helper function named get_all_combinations() in the CvrpDataCenter class. In the code snippet below, we define a separate constraint for every nonempty customer set \\(S\\), and the right-hand side \\(r(S)\\) is defined as \\(\\lceil {q(S) / Q} \\rceil\\).\n\n# create subtour elimination constraint\nnodes = cvrp_data_center.nodes\nvehicle_capacity = cvrp_data_center.vehicle_capacity\ncustomer_ids = [node.id for node in nodes if node.id &gt; 0]\nnode_ids = [node.id for node in nodes]\nnonempty_customer_sets = cvrp_data_center.get_all_combinations(customer_ids)\nfor customer_set in nonempty_customer_sets:\n    others = set(node_ids).difference(customer_set)\n    expr = [var_x[i][j]\n            for i in customer_set\n            for j in others]\n    total_demand = sum([node.demand \n                        for node in nodes \n                        if node.id in set(customer_set)])\n    rhs = math.ceil(total_demand / vehicle_capacity)\n    solver.Add(solver.Sum(expr) &gt;= rhs)\n\nPutting it all together, we have the complete program below. It can be seen from the output that the optimal solution is 450 and there are 8 routes in the identified solution.\n\nfrom ortools.linear_solver import pywraplp\nimport numpy as np\nfrom itertools import product\nimport math\n\n# prepare instance\ncvrp_data_center = CvrpDataCenter()\ncvrp_data_center.read_cvrp_instance(\"./data/cvrp/P-n16-k8-mini.vrp\")\n\n# instantiate solver\nsolver = pywraplp.Solver.CreateSolver('SCIP')\n\n# create decision variables\nnum_nodes = cvrp_data_center.num_nodes\nnum_vehicles = cvrp_data_center.num_vehicles\nvar_x = np.empty((num_nodes, num_nodes), dtype=object)\nfor i, j in product(range(num_nodes), range(num_nodes)):\n    if i == j: continue\n    var_x[i][j] = solver.BoolVar(name=\"x_{i, j}\")\n\n# define objective function\nobj_expr = [\n    cvrp_data_center.distance(i, j, integer=True) * var_x[i][j]\n    for i, j in product(range(num_nodes), range(num_nodes))\n    if i != j\n]\nsolver.Minimize(solver.Sum(obj_expr))\n\n# create incoming and outgoing arc constraints\nfor i in range(1, num_nodes):\n    out_arcs = [var_x[i][j] for j in range(num_nodes) if j != i]\n    in_arcs = [var_x[j][i] for j in range(num_nodes) if j != i]\n    solver.Add(solver.Sum(out_arcs) == 1)\n    solver.Add(solver.Sum(in_arcs) == 1)\n\n# create fleet size constraint\nexpr = [var_x[0][i] for i in range(1, num_nodes)]\nsolver.Add(solver.Sum(expr) == num_vehicles)\n\n# create subtour elimination constraint\nnodes = cvrp_data_center.nodes\nvehicle_capacity = cvrp_data_center.vehicle_capacity\ncustomer_ids = [node.id for node in nodes if node.id &gt; 0]\nnode_ids = [node.id for node in nodes]\nnonempty_customer_sets = cvrp_data_center.get_all_combinations(customer_ids)\nfor customer_set in nonempty_customer_sets:\n    others = set(node_ids).difference(customer_set)\n    expr = [var_x[i][j]\n            for i in customer_set\n            for j in others]\n    total_demand = sum([node.demand \n                        for node in nodes \n                        if node.id in set(customer_set)])\n    rhs = math.ceil(total_demand / vehicle_capacity)\n    solver.Add(solver.Sum(expr) &gt;= rhs)\n    \nstatus = solver.Solve()\nif not status:\n    opt_obj = solver.Objective().Value()\n    \n    opt_x = np.zeros((num_nodes, num_nodes))\n    for i, j in product(range(num_nodes), range(num_nodes)):\n        if i == j: continue\n        opt_x[i][j] = int(var_x[i][j].solution_value())\n\n    routes = []\n    for i in range(1, num_nodes):\n        if opt_x[0][i] == 0: continue\n        # new route found\n        route = []\n        \n        route_length = 0\n        # add the first arc\n        arc_start = 0\n        arc_end = i\n        route.append((arc_start, arc_end))\n        route_length += cvrp_data_center.distance(arc_start, \n                                                arc_end, \n                                                integer=True)\n        \n        # add remaining arcs on the route\n        arc_start = arc_end\n        while True:\n            for j in range(num_nodes):\n                if opt_x[arc_start][j] == 1:\n                    arc_end = j\n                    break\n            route.append((arc_start, arc_end))\n            route_length += cvrp_data_center.distance(arc_start, \n                                                    arc_end, \n                                                    integer=True)\n            if arc_end == 0: break\n            arc_start = arc_end\n\n        routes.append(route)\n\nTo facilitate the model comparison in following steps, we’ll wrap the above program into a dedicated class Cvrp1.\n\nfrom ortools.linear_solver import pywraplp\nfrom itertools import product\nimport numpy as np\nimport math\n\nclass Cvrp1:\n    \"\"\"solve the cvrp model using the two index formulation\n    \"\"\"\n\n    def __init__(self, cvrp_data_center: CvrpDataCenter):\n        self._data_center: CvrpDataCenter = cvrp_data_center\n        self._solver = pywraplp.Solver.CreateSolver('SCIP')\n        self._var_x = None\n        \n        self._opt_obj = None\n        self._opt_x = None\n        self._opt_routes = None\n    \n    def read_instance(self, instance_file):\n        self._data_center.read_cvrp_instance(instance_file)\n\n    def build_model(self):\n        self._create_variables()\n        self._create_objective()\n        self._create_constr_flow()\n        self._create_constr_fleet()\n        self._create_constr_subtour()\n        \n    def optimize(self):\n        status = self._solver.Solve()\n        if not status:\n            self._retrieve_opt_solution()\n            self._retrieve_opt_routes()\n    \n    def _create_variables(self):\n        num_nodes = self._data_center.num_nodes\n        self._var_x = np.empty((num_nodes, num_nodes), dtype=object)\n        for i, j in product(range(num_nodes), range(num_nodes)):\n            if i == j: continue\n            self._var_x[i][j] = self._solver.BoolVar(name=\"x_{i, j}\")\n\n    def _create_objective(self):\n        num_nodes = self._data_center.num_nodes\n        obj_expr = [\n            self._data_center.distance(i, j, integer=True) * \n                self._var_x[i][j]\n                for i, j in product(range(num_nodes), range(num_nodes))\n                if i != j\n        ]\n        self._solver.Minimize(self._solver.Sum(obj_expr))\n            \n    def _create_constr_flow(self):\n        # create incoming and outgoing arc constraints\n        num_nodes = self._data_center.num_nodes\n        for i in range(1, num_nodes):\n            out_arcs = [self._var_x[i][j] for j in range(num_nodes) if j != i]\n            in_arcs = [self._var_x[j][i] for j in range(num_nodes) if j != i]\n            self._solver.Add(self._solver.Sum(out_arcs) == 1)\n            self._solver.Add(self._solver.Sum(in_arcs) == 1)\n            \n    def _create_constr_fleet(self):\n        # create fleet size constraint\n        num_nodes = self._data_center.num_nodes\n        num_vehicles = self._data_center.num_vehicles\n        expr = [self._var_x[0][i] for i in range(1, num_nodes)]\n        self._solver.Add(self._solver.Sum(expr) == num_vehicles)\n    \n    def _create_constr_subtour(self):\n        # create subtour elimination constraint\n        nodes = self._data_center.nodes\n        vehicle_capacity = self._data_center.vehicle_capacity\n        customer_ids = [node.id for node in nodes if node.id &gt; 0]\n        node_ids = [node.id for node in nodes]\n        nonempty_customer_sets = self._data_center.get_all_combinations(customer_ids)\n        for customer_set in nonempty_customer_sets:\n            others = set(node_ids).difference(customer_set)\n            expr = [self._var_x[i][j]\n                    for i in customer_set\n                    for j in others]\n            total_demand = sum([node.demand \n                                for node in nodes \n                                if node.id in set(customer_set)])\n            rhs = math.ceil(total_demand / vehicle_capacity)\n            self._solver.Add(self._solver.Sum(expr) &gt;= rhs)\n        print(f\"No. subtour elimination constraints: {len(nonempty_customer_sets)}\")\n    \n    def show_model_summary(self):\n        print(f\"No. of variables: {self._solver.NumVariables()}\")\n        print(f\"No. of constraints: {self._solver.NumConstraints()}\")\n    \n    def _retrieve_opt_solution(self):\n        self._opt_obj = self._solver.Objective().Value()\n        print(f'Optimal value: {self._opt_obj:.2f}')\n        \n        num_nodes = self._data_center.num_nodes\n        self._opt_x = np.zeros((num_nodes, num_nodes))\n        for i, j in product(range(num_nodes), range(num_nodes)):\n            if i == j: continue\n            self._opt_x[i][j] = int(self._var_x[i][j].solution_value())\n\n    def _retrieve_opt_routes(self):\n        num_nodes = self._data_center.num_nodes\n        self._routes = []\n        for i in range(1, num_nodes):\n            if self._opt_x[0][i] == 0: continue\n            # new route found\n            route = []\n            \n            route_length = 0\n            # add the first arc\n            arc_start = 0\n            arc_end = i\n            route.append((arc_start, arc_end))\n            route_length += self._data_center\\\n                    .distance(arc_start, \n                            arc_end,\n                            integer=True)\n            \n            # add remaining arcs on the route\n            arc_start = arc_end\n            while True:\n                for j in range(num_nodes):\n                    if self._opt_x[arc_start][j] == 1:\n                        arc_end = j\n                        break\n                route.append((arc_start, arc_end))\n                route_length += self._data_center\\\n                    .distance(arc_start,\n                            arc_end,\n                            integer=True)\n                if arc_end == 0: break\n                arc_start = arc_end\n\n            self._routes.append(route)\n            print(f'route: {route}, length: {route_length}')\n    \n    def show_opt_routes(self):\n        nodes = self._data_center.nodes\n        locations = {\n            node.id: (node.x_coord, node.y_coord)\n            for node in nodes\n        }\n\n        edges = []\n        vehicle_idx = 0\n        for route in self._routes:\n            for arc in route:\n                edges.append((arc[0], arc[1], {'vehicle': str(vehicle_idx)}))\n            vehicle_idx += 1\n        edges\n\n        show_vehicle_routes(locations, edges)\n\nThe code below validates that the same optimal solution is obtained using this object-oriented approach. Figure 7.2 shows the routes found by the two-index formulation. Note that the routes are different from the ones in Figure 7.1 but they have the same objective value.\n\n\nCode\ncvrp1 = Cvrp1(CvrpDataCenter())\ncvrp1.read_instance(\"./data/cvrp/P-n16-k8-mini.vrp\")\ncvrp1.build_model()\ncvrp1.show_model_summary()\ncvrp1.optimize()\ncvrp1.show_opt_routes()\n\n\nNo. subtour elimination constraints: 2047\nNo. of variables: 132\nNo. of constraints: 2070\nOptimal value: 347.00\nroute: [(0, 1), (1, 3), (3, 0)], length: 66\nroute: [(0, 2), (2, 0)], length: 42\nroute: [(0, 4), (4, 10), (10, 0)], length: 55\nroute: [(0, 5), (5, 9), (9, 7), (7, 0)], length: 68\nroute: [(0, 6), (6, 0)], length: 24\nroute: [(0, 8), (8, 11), (11, 0)], length: 92\n\n\n\n\n\nFigure 7.2: Optimal routes found by the two-index formulation\n\n\n\n\nIt can be seen from the model output that there are a total of 32798 constraints, out of which 32767 are subtour elimination constraints, even for such a small instance with only 15 customers. In the next section, we will present another two index formulation to handle this exponential number of constraints."
  },
  {
    "objectID": "ip-cvrp.html#two-index-formulation---2",
    "href": "ip-cvrp.html#two-index-formulation---2",
    "title": "7  Capacitated Vehicle Routing Problem",
    "section": "7.3 Two-index Formulation - 2",
    "text": "7.3 Two-index Formulation - 2\nThis formulation is based on the MTZ-model introduced by Miller, Tucker, and Zemlin (1960) for the TSP. To eliminate subtours, a new variable \\(u_i\\) is defined for every node \\(i \\in \\mathcal{N}\\):\n\n\\(u_i\\): the total demands distributed by any vehicle when it arrives at node \\(i\\)\n\n\\[\\begin{align}\n    \\text{min.} &\\quad \\sum_{(i, j) \\in \\mathcal{A}} c_{ij} x_{ij} \\label{cvrp2-obj} \\\\\n    \\text{s.t.} &\\quad \\sum_{j \\in \\delta^+(i)}x_{ij} = 1, \\ \\forall i \\in \\mathcal{N} \\label\n    {cvrp2-cons1}\\\\\n    &\\quad \\sum_{i \\in \\delta^-(j)} x_{ij} = 1, \\ \\forall j \\in \\mathcal{N} \\label{cvrp2-cons2} \\\\\n    &\\quad \\sum_{j \\in \\delta^+(0)} x_{oj} = |\\mathcal{K}| \\label{cvrp2-cons3} \\\\\n    &\\quad u_i \\leq u_j - q_j + Q(1 - x_{ij}), \\ \\forall (i, j) \\in \\mathcal{A}, i, j \\in \\mathcal{N} \\label{cvrp2-cons4}\\\\\n    &\\quad q_i \\leq u_i \\leq Q, \\ \\forall i \\in \\mathcal{N} \\label{cvrp2-cons5} \\\\\n    &\\quad x_{ij} \\in \\{0, 1\\}, \\ \\forall (i, j) \\in \\mathcal{A} \\label{cvrp2-cons6}\n\\end{align}\\]\n\nfrom ortools.linear_solver import pywraplp\nfrom itertools import product\nimport numpy as np\n\nclass Cvrp2:\n    \"\"\"solve the cvrp model using the two index formulation\n    \"\"\"\n\n    def __init__(self, cvrp_data_center: CvrpDataCenter):\n        self._data_center: CvrpDataCenter = cvrp_data_center\n        self._solver = pywraplp.Solver.CreateSolver('SCIP')\n        self._var_x = None\n        self._var_u = None\n        \n        self._opt_obj = None\n        self._opt_x = None\n        self._opt_routes = None\n    \n    def read_instance(self, instance_file):\n        self._data_center.read_cvrp_instance(instance_file)\n\n    def build_model(self):\n        self._create_variables()\n        self._create_objective()\n        self._create_constr_flow()\n        self._create_constr_fleet()\n        self._create_constr_subtour()\n        \n    def optimize(self):\n        status = self._solver.Solve()\n        if not status:\n            self._retrieve_opt_solution()\n            self._retrieve_opt_routes()\n    \n    def _create_variables(self):\n        num_nodes = self._data_center.num_nodes\n        self._var_x = np.empty((num_nodes, num_nodes), dtype=object)\n        for i, j in product(range(num_nodes), range(num_nodes)):\n            if i == j: continue\n            self._var_x[i][j] = self._solver.BoolVar(name=\"x_{i, j}\")\n            \n        self._var_u = np.empty(num_nodes, dtype=object)\n        nodes = self._data_center.nodes\n        vehicle_capacity = float(self._data_center.vehicle_capacity)\n        for node in nodes:\n            if node.id == 0: continue\n            self._var_u[node.id] = self._solver.NumVar(\n                lb=float(node.demand), \n                ub=vehicle_capacity,\n                name='v')\n\n    def _create_objective(self):\n        num_nodes = self._data_center.num_nodes\n        obj_expr = [\n            self._data_center.distance(i, j, integer=True) * \n                self._var_x[i][j]\n                for i, j in product(range(num_nodes), range(num_nodes))\n                if i != j\n        ]\n        self._solver.Minimize(self._solver.Sum(obj_expr))\n            \n    def _create_constr_flow(self):\n        # create incoming and outgoing arc constraints\n        num_nodes = self._data_center.num_nodes\n        for i in range(1, num_nodes):\n            out_arcs = [self._var_x[i][j] for j in range(num_nodes) if j != i]\n            in_arcs = [self._var_x[j][i] for j in range(num_nodes) if j != i]\n            self._solver.Add(self._solver.Sum(out_arcs) == 1)\n            self._solver.Add(self._solver.Sum(in_arcs) == 1)\n            \n    def _create_constr_fleet(self):\n        # create fleet size constraint\n        num_nodes = self._data_center.num_nodes\n        num_vehicles = self._data_center.num_vehicles\n        expr = [self._var_x[0][i] for i in range(1, num_nodes)]\n        self._solver.Add(self._solver.Sum(expr) == num_vehicles)\n    \n    def _create_constr_subtour(self):\n        # create subtour elimination constraint\n        constraints = []\n        nodes = self._data_center.nodes\n        vehicle_capacity = self._data_center.vehicle_capacity\n        for ni, nj in product(nodes, nodes):\n            if ni.id == 0 or nj.id == 0: continue\n            if ni.id == nj.id: continue\n            constr = self._solver.Add(\n                self._var_u[ni.id] &lt;=\n                self._var_u[nj.id] -\n                nj.demand +\n                vehicle_capacity * (\n                    1 - self._var_x[ni.id][nj.id]\n                )\n            )\n            constraints.append(constr)\n\n        print(f\"No. subtour elimination constraints: {len(constraints)}\")\n    \n    def show_model_summary(self):\n        print(f\"No. of variables: {self._solver.NumVariables()}\")\n        print(f\"No. of constraints: {self._solver.NumConstraints()}\")\n    \n    def _retrieve_opt_solution(self):\n        self._opt_obj = self._solver.Objective().Value()\n        print(f'Optimal value: {self._opt_obj:.2f}')\n        \n        num_nodes = self._data_center.num_nodes\n        self._opt_x = np.zeros((num_nodes, num_nodes))\n        for i, j in product(range(num_nodes), range(num_nodes)):\n            if i == j: continue\n            self._opt_x[i][j] = int(self._var_x[i][j].solution_value())\n\n    def _retrieve_opt_routes(self):\n        num_nodes = self._data_center.num_nodes\n        self._routes = []\n        for i in range(1, num_nodes):\n            if self._opt_x[0][i] == 0: continue\n            # new route found\n            route = []\n            \n            route_length = 0\n            # add the first arc\n            arc_start = 0\n            arc_end = i\n            route.append((arc_start, arc_end))\n            route_length += self._data_center\\\n                    .distance(arc_start, \n                            arc_end,\n                            integer=True)\n            \n            # add remaining arcs on the route\n            arc_start = arc_end\n            while True:\n                for j in range(num_nodes):\n                    if self._opt_x[arc_start][j] == 1:\n                        arc_end = j\n                        break\n                route.append((arc_start, arc_end))\n                route_length += self._data_center\\\n                    .distance(arc_start,\n                            arc_end,\n                            integer=True)\n                if arc_end == 0: break\n                arc_start = arc_end\n\n            self._routes.append(route)\n            print(f'route: {route}, length: {route_length}')\n    \n    def show_opt_routes(self):\n        nodes = self._data_center.nodes\n        locations = {\n            node.id: (node.x_coord, node.y_coord)\n            for node in nodes\n        }\n\n        edges = []\n        vehicle_idx = 0\n        for route in self._routes:\n            for arc in route:\n                edges.append((arc[0], arc[1], {'vehicle': str(vehicle_idx)}))\n            vehicle_idx += 1\n        edges\n\n        show_vehicle_routes(locations, edges)\n\n\ncvrp2 = Cvrp2(CvrpDataCenter())\ncvrp2.read_instance(\"./data/cvrp/P-n16-k8-mini.vrp\")\ncvrp2.build_model()\ncvrp2.show_model_summary()\ncvrp2.optimize()\ncvrp2.show_opt_routes()\n\nNo. subtour elimination constraints: 110\nNo. of variables: 143\nNo. of constraints: 133\nOptimal value: 347.00\nroute: [(0, 1), (1, 3), (3, 0)], length: 66\nroute: [(0, 2), (2, 0)], length: 42\nroute: [(0, 5), (5, 9), (9, 7), (7, 0)], length: 68\nroute: [(0, 6), (6, 0)], length: 24\nroute: [(0, 10), (10, 4), (4, 0)], length: 55\nroute: [(0, 11), (11, 8), (8, 0)], length: 92"
  },
  {
    "objectID": "ip-cvrp.html#three-index-formulation",
    "href": "ip-cvrp.html#three-index-formulation",
    "title": "7  Capacitated Vehicle Routing Problem",
    "section": "7.4 Three-index Formulation",
    "text": "7.4 Three-index Formulation\nThis formulation is also known as the MTZ-formulation as a new set of constraints initially proposed for traveling salesman problem (Miller, Tucker, and Zemlin (1960)) is used to eliminate subtours.\nWe define the following variables in this formualation:\n\n\\(x_{ijk}\\): a binary variable that equals 1 when the vehicle \\(k\\) visits arc \\((i, j) \\in \\mathcal{A}\\), 0 otherwise\n\\(y_{ik}\\): a binary variable that equals 1 if node \\(i\\) is visited by vehicle \\(k\\), 0 otherwise\n\\(u_{ik}\\): a continuous variable that represents the demands delivered by vehicle \\(k\\) when arriving at node \\(i\\)\n\n\\[\\begin{align}\n    \\text{min.} &\\quad \\sum_{k \\in \\mathcal{K}} \\sum_{(i, j) \\in \\mathcal{A}} c_{ij} x_{ijk} \\label{cvrp3-obj} \\\\\n    \\text{s.t.} &\\quad x_{iik} = 0, \\ \\forall i \\in \\mathcal{V}, k \\in \\mathcal{K} \\\\\n    &\\quad \\sum_{j \\in \\mathcal{V}}x_{ijk} = \\sum_{j \\in \\mathcal{V}}x_{jik}, \\ \\forall i \\in \\mathcal{V}, k \\in \\mathcal{K} \\label{cvrp3-cons3} \\\\\n    &\\quad \\sum_{k \\in \\mathcal{K}} y_{ik} = 1, \\ \\forall i \\in \\mathcal{N} \\label{cvrp3-cons1} \\\\\n    &\\quad y_{ik} = \\sum_{j \\in \\mathcal{V}} x_{ijk}, \\ \\forall i \\in \\mathcal{V}, k \\in \\mathcal{K} \\label{cvrp3-cons4} \\\\\n    &\\quad y_{0k} = 1, \\ \\forall k \\in \\mathcal{K} \\\\\n    &\\quad u_{i} \\leq u_{j} - q_j + Q(1 - x_{ijk}), \\ \\forall i \\neq j, i, j \\in \\mathcal{N}, k \\in \\mathcal{K} \\label{cvrp3-cons6} \\\\\n    &\\quad q_i \\leq u_{i} \\leq Q, \\ \\forall i \\in \\mathcal{N}\\label{cvrp-cons7}\\\\\n    &\\quad x_{ijk} \\in \\{0, 1\\}, \\ \\forall (i, j) \\in \\mathcal{A}, k \\in \\mathcal{K} \\label{cvrp3-cons8} \\\\\n    &\\quad y_{ik} \\in \\{0, 1\\}, \\ \\forall i \\in \\mathcal{V}, k \\in \\mathcal{K} \\label{cvrp3-cons9} \\\\\n    &\\quad u_{ik} \\geq 0, \\ \\forall i \\in \\mathcal{V}, k \\in \\mathcal{K} \\label{cvrp3-cons10}\n\\end{align}\\]\n\nfrom ortools.linear_solver import pywraplp\nfrom itertools import product\nimport numpy as np\n\nclass Cvrp3:\n    \"\"\"solve the cvrp model using the two index formulation\n    \"\"\"\n\n    def __init__(self, cvrp_data_center: CvrpDataCenter):\n        self._data_center: CvrpDataCenter = cvrp_data_center\n        self._solver = pywraplp.Solver.CreateSolver('SCIP')\n        self._var_x = None\n        self._var_y = None\n        self._var_u = None\n        \n        self._opt_obj = None\n        self._opt_x = None\n        self._opt_routes = None\n    \n    def read_instance(self, instance_file):\n        self._data_center.read_cvrp_instance(instance_file)\n\n    def build_model(self):\n        self._create_variables()\n        self._create_objective()\n        self._create_constr_flow()\n        self._create_constr_customer_must_be_visited()\n        self._create_constr_subtour()\n        \n    def optimize(self):\n        status = self._solver.Solve()\n        print(\"solve complete!\")\n        if not status:\n            self._retrieve_opt_solution()\n            self._retrieve_opt_routes()\n        else:\n            print(f\"status={status}\")\n    \n    def _create_variables(self):\n        num_nodes = self._data_center.num_nodes\n        num_vehicles = self._data_center.num_vehicles\n        self._var_x = np.empty((num_vehicles, num_nodes, num_nodes), \n                            dtype=object)\n        for k, i, j in product(range(num_vehicles), \n                            range(num_nodes),\n                            range(num_nodes)):\n            self._var_x[k][i][j] = self._solver.BoolVar(name=f\"x_{k, i, j}\")\n            \n        self._var_y = np.empty((num_vehicles, num_nodes), dtype=object)\n        for k, i in product(range(num_vehicles),\n                            range(num_nodes)):\n            self._var_y[k][i] = self._solver.BoolVar(name=f'y_{k, i}')\n        \n        vehicle_capacity = self._data_center.vehicle_capacity\n        self._var_u = np.empty(num_nodes, dtype=object)\n        for node in self._data_center.nodes:\n            self._var_u[node.id] = self._solver.NumVar(\n                float(node.demand),\n                vehicle_capacity,\n                name=f'u_{node.id}')\n\n    def _create_objective(self):\n        num_vehicles = self._data_center.num_vehicles\n        num_nodes = self._data_center.num_nodes\n        obj_expr = [\n            self._data_center.distance(i, j, integer=True) * \n                self._var_x[k][i][j]\n                for k, i, j in product(range(num_vehicles), range(num_nodes), range(num_nodes))\n                if i != j\n        ]\n        self._solver.Minimize(self._solver.Sum(obj_expr))\n    \n    def _create_constr_flow(self):\n        # create incoming and outgoing arc constraints\n        num_vehicles = self._data_center.num_vehicles\n        num_nodes = self._data_center.num_nodes\n        for k, i in product(range(num_vehicles),\n                            range(num_nodes)):\n            self._solver.Add(self._var_x[k][i][i] == 0)\n            \n        for k, i in product(range(num_vehicles),\n                            range(num_nodes)):\n            expr1 = [self._var_x[k][i][j] for j in range(num_nodes)]\n            expr2 = [self._var_x[k][j][i] for j in range(num_nodes)]\n            self._solver.Add(self._solver.Sum(expr1) == \n                            self._solver.Sum(expr2))\n    \n    def _create_constr_customer_must_be_visited(self):\n        num_vehicles = self._data_center.num_vehicles\n        num_nodes = self._data_center.num_nodes\n        for i in range(1, num_nodes):\n            expr = [self._var_y[k][i] for k in range(num_vehicles)]\n            self._solver.Add(self._solver.Sum(expr) == 1)\n        \n        for k, i in product(range(num_vehicles),\n                            range(num_nodes)):\n            expr = [self._var_x[k][i][j] for j in range(num_nodes)]\n            self._solver.Add(self._solver.Sum(expr) ==\n                            self._var_y[k][i])\n        \n        for k in range(num_vehicles):\n            self._solver.Add(self._var_y[k][0] == 1)\n\n    def _create_constr_subtour(self):\n        # create subtour elimination constraint\n        constraints = []\n        nodes = self._data_center.nodes\n        vehicle_capacity = self._data_center.vehicle_capacity\n        num_vehicles = self._data_center.num_vehicles\n        for k, ni, nj in product(range(num_vehicles), nodes, nodes):\n            if ni.id == 0 or nj.id == 0: continue\n            if ni.id == nj.id: continue\n            constr = self._solver.Add(self._var_u[ni.id] &lt;=\n                    self._var_u[nj.id] -\n                    float(nj.demand) +\n                    vehicle_capacity * (\n                        1 - self._var_x[k][ni.id][nj.id]\n                    )\n                )\n            constraints.append(constr)\n\n        print(f\"No. subtour elimination constraints: {len(constraints)}\")\n    \n    def show_model_summary(self):\n        print(f\"No. of variables: {self._solver.NumVariables()}\")\n        print(f\"No. of constraints: {self._solver.NumConstraints()}\")\n    \n    def _retrieve_opt_solution(self):\n        self._opt_obj = self._solver.Objective().Value()\n        print(f'Optimal value: {self._opt_obj:.2f}')\n        \n        num_nodes = self._data_center.num_nodes\n        num_vehicles = self._data_center.num_vehicles\n        self._opt_x = np.zeros((num_vehicles, num_nodes, num_nodes))\n        for k, i, j in product(range(num_vehicles), range(num_nodes), range(num_nodes)):\n            self._opt_x[k][i][j] = int(self._var_x[k][i][j].solution_value())\n\n    def _retrieve_opt_routes(self):\n        num_nodes = self._data_center.num_nodes\n        num_vehicles = self._data_center.num_vehicles\n        self._routes = []\n        for k in range(num_vehicles):     \n            route = []   \n            for i in range(1, num_nodes):\n                if self._opt_x[k][0][i] == 0: continue\n\n                # new route found\n                route_length = 0\n                # add the first arc\n                arc_start = 0\n                arc_end = i\n                route.append((arc_start, arc_end))\n                route_length += self._data_center\\\n                        .distance(arc_start, \n                                arc_end,\n                                integer=True)\n                \n                # add remaining arcs on the route\n                arc_start = arc_end\n                while True:\n                    for j in range(num_nodes):\n                        if self._opt_x[k][arc_start][j] == 1:\n                            arc_end = j\n                            break\n                    route.append((arc_start, arc_end))\n                    route_length += self._data_center\\\n                        .distance(arc_start,\n                                arc_end,\n                                integer=True)\n                    if arc_end == 0: break\n                    arc_start = arc_end\n\n                self._routes.append(route)\n                print(f'route: {route}, length: {route_length}')\n                \n                break\n    \n    def show_opt_routes(self):\n        nodes = self._data_center.nodes\n        locations = {\n            node.id: (node.x_coord, node.y_coord)\n            for node in nodes\n        }\n\n        edges = []\n        vehicle_idx = 0\n        for route in self._routes:\n            for arc in route:\n                edges.append((arc[0], arc[1], {'vehicle': str(vehicle_idx)}))\n            vehicle_idx += 1\n        edges\n\n        show_vehicle_routes(locations, edges)\n\n\ncvrp3 = Cvrp3(CvrpDataCenter())\ncvrp3.read_instance(\"./data/cvrp/P-n16-k8-mini.vrp\")\ncvrp3.build_model()\ncvrp3.show_model_summary()\ncvrp3.optimize()\ncvrp3.show_opt_routes()\n\nNo. subtour elimination constraints: 660\nNo. of variables: 948\nNo. of constraints: 893\nsolve complete!\nOptimal value: 347.00\nroute: [(0, 3), (3, 1), (1, 0)], length: 66\nroute: [(0, 2), (2, 0)], length: 42\nroute: [(0, 7), (7, 9), (9, 5), (5, 0)], length: 68\nroute: [(0, 8), (8, 11), (11, 0)], length: 92\nroute: [(0, 4), (4, 10), (10, 0)], length: 55\nroute: [(0, 6), (6, 0)], length: 24"
  },
  {
    "objectID": "ip-cvrp.html#performance-comparison",
    "href": "ip-cvrp.html#performance-comparison",
    "title": "7  Capacitated Vehicle Routing Problem",
    "section": "7.5 Performance Comparison",
    "text": "7.5 Performance Comparison\nTable 7.1 shows the runtime comparison on the same instance.\n\n\n\n\nTable 7.1: Computational time comparison of the three formulations\n\n\nInstance\nModel 1\nModel 2\nModel 3\n\n\n\n\nP-n12-k8-mini.vrp\n0.4s\n0.3s\n1m5s\n\n\n\n\n\n\n\n\n\n\nCVRPLIB. 2014. “CVRPLIB.” http://vrp.galgos.inf.puc-rio.br/index.php/en/.\n\n\nLaporte, Gilbert, Hélène Mercure, and Yves Nobert. 1986. “An Exact Algorithm for the Asymmetrical Capacitated Vehicle Routing Problem.” Networks 16 (1): 33–46. https://doi.org/10.1002/net.3230160104.\n\n\nMiller, C. E., A. W. Tucker, and R. A. Zemlin. 1960. “Integer Programming Formulation of Traveling Salesman Problems.” Journal of the ACM 7 (4): 326–29. https://doi.org/10.1145/321043.321046.\n\n\nToth, Paolo, and Daniele Vigo. 2014. Vehicle Routing: Problems, Methods, and Applications. SIAM."
  },
  {
    "objectID": "ip-knapsack.html#single-dimensional-knapsack-problem",
    "href": "ip-knapsack.html#single-dimensional-knapsack-problem",
    "title": "8  The Knapsack Problem",
    "section": "8.1 Single-dimensional Knapsack Problem",
    "text": "8.1 Single-dimensional Knapsack Problem\nIn the single-dimensional knapsack problem (SDKP), we are given a set of \\(n\\) items, each with a weight \\(w_j\\) and a value \\(v_j\\), and a knapsack with a maximum weight capacity \\(W\\), the goal is to select a subset of items such that the sum of their weights is less than or equal to \\(W\\), and the sum of their values is maximized. The SDKP can be formally formulated as follows (Dudziński and Walukiewicz (1987)).\n\\[\\begin{align}\n    \\text{max.} &\\quad \\sum_{j = 1}^nv_i x_j \\label{knapsack1-obj} \\\\\n    \\text{s.t.} &\\quad \\sum_{j=1}^n w_j x_j \\leq W \\label{knapsack1-cons1} \\\\\n    &\\quad x_j \\in \\{0, 1\\}, \\ j = 1, \\cdots, n \\label{knapsack1-cons2}\n\\end{align}\\]\nIn the model, the \\(n\\) represents the total amount of items that are being considered. The binary decision variable \\(x_i\\) has a value of 1 when item \\(i\\) is chosen, and 0 when it’s not. The value or profit of selecting item \\(i\\) is indicated by \\(v_i\\), and the weight of item \\(i\\) is represented by \\(w_i\\). Finally, \\(W\\) specifies the maximum weight capacity of the knapsack.\nTo represent the list of items in the problem, we first define a class Item that has three attributes:\n\n_index: this is the index of an item and starts from 0\n_profit: this is the profit or value of selecting the item\n_properties: this dictionary saves an item’s properties, including weight\n\n\nclass Item:\n    \"\"\"An item represents an object that can be placed within a knapsack\n    \"\"\"\n    \n    def __init__(self, index, profit):\n        \"\"\"constructor\n\n        Args:\n            index (int): index of the item, starting from 0\n            profit (float): profit of choosing the item\n        \"\"\"\n        self._index = index\n        self._profit = profit\n        self._class = 0\n        self._properties = {}\n    \n    @property\n    def index(self): return self._index\n    \n    @property\n    def profit(self): return self._profit\n    \n    def get_class(self): return self._class\n    \n    def set_class(self, cls): self._class = cls\n    \n    def get_property(self, name):\n        return self._properties[name]\n\n    def set_property(self, name, value):\n        self._properties[name] = value\n        \n    def __str__(self):\n        p_str = \"\"\n        for attr in self._properties:\n            p_str += f'{attr}: {self._properties[attr]}'\n        return f\"index: {self._index}, profit: {self._profit}, \" + \\\n                p_str\n\nNext, we define a class KnapsackDataCenter to hold all the information we need to solve a knapsack problem. The class has two attributes:\n\n_items: this is the full list of items being considered for putting into the knapsack\n_capacities: this saves the maximal capacity of the knapsack corresponding to different properties, including weight.\n\nThe class also defines a method read_data_set_f() that reads and parses some benchmarking instancese available online.\n\nclass KnapsackDataCenter:\n    \n    def __init__(self):\n        self._items = []\n        self._capacities = {}\n                \n    @property\n    def items(self): return self._items\n    \n    @property\n    def capacities(self): return self._capacities\n\n\nclass SDKPDataCenter(KnapsackDataCenter):\n    \n    def __init__(self):\n        super().__init__()\n        \n    def read_sdkp_dataset_f(self, data_file: str):\n        \"\"\"this function reads and parses data presented in \n        http://artemisa.unicauca.edu.co/~johnyortega/instances_01_KP/\n\n        Args:\n            data_file (str): path to the data file\n            num_items (int): number of items in the file\n            capacity (int): knapsack capacity\n        \"\"\"\n        with open(data_file) as f:\n            first_line = f.readline()\n            num_items, capacity = first_line.split()\n            self._capacities['weight'] = float(capacity)\n            \n            item_idx = 0\n            rest_lines = f.readlines()\n            for line in rest_lines:\n                profit, weight = line.split()\n                item = Item(item_idx, float(profit))\n                item.set_property('weight', float(weight))\n                self._items.append(item)\n                item_idx += 1\n                if item_idx == int(num_items): break\n\nThe code snippet below reads the instance f1_l-d_kp_10_269 and shows its key information.\n\ndata_file = \"./data/knapsack/SDKP/instances_01_KP/low-dimensional/f1_l-d_kp_10_269\"\n\ndata_center = SDKPDataCenter()\ndata_center.read_sdkp_dataset_f(data_file)\n\ncapacities = data_center.capacities\nprint(f\"Knapsack info: {capacities}\")\n\nitems = data_center.items\nprint(\"Item info: \")\nfor item in items:\n    print(item)\n\nKnapsack info: {'weight': 269.0}\nItem info: \nindex: 0, profit: 55.0, weight: 95.0\nindex: 1, profit: 10.0, weight: 4.0\nindex: 2, profit: 47.0, weight: 60.0\nindex: 3, profit: 5.0, weight: 32.0\nindex: 4, profit: 4.0, weight: 23.0\nindex: 5, profit: 50.0, weight: 72.0\nindex: 6, profit: 8.0, weight: 80.0\nindex: 7, profit: 61.0, weight: 62.0\nindex: 8, profit: 85.0, weight: 65.0\nindex: 9, profit: 87.0, weight: 46.0\n\n\nNow we are ready to solve the SDKP using OR-Tools. The code below shows the completion definition of the class SDKnapsackSolver which has a number of attributes:\n\n_data_center: this should be an instantiated KnapsackDataCenter object\n_solver: this is the solver object used for modeling and problem solving\n_var_x: this is the object that holds all the decision variables used in the model\n_opt_obj: this is the optimal solution value found by the solver\n_opt_x: this is the optimal solution identified when the solving process completes\n\nThe class has two major methods:\n\nbuild_model(): this is responsible for instantiating the solver object, creating variables, generating constraints and defining the objective function\noptimize(): this is the place where the OR-Tools searches for the optimal solution\n\n\nfrom ortools.linear_solver import pywraplp\n\nclass SDKnapsackSolver:\n    \n    def __init__(self, data_center):\n        self._data_center = data_center\n\n        self._solver = None\n        self._var_x = None\n\n        self._opt_obj = None\n        self._opt_x = None\n        \n    def build_model(self):\n        self._solver = pywraplp.Solver.CreateSolver('SCIP')\n\n        self._create_variables()\n        self._create_objective()\n        self._create_constraints()\n        \n    def optimize(self):\n        status = self._solver.Solve()\n        if status == pywraplp.Solver.OPTIMAL:\n            self._opt_obj = self._solver.Objective().Value()\n            items = self._data_center.items\n            self._opt_x = [\n                    self._var_x[item.index].solution_value()\n                    for item in items\n                ]\n    \n    def _create_variables(self):\n        items = self._data_center.items\n        self._var_x = [self._solver.BoolVar(name=f'x_{i}')\n                    for i, item in enumerate(items)]\n    \n    def _create_objective(self):\n        items = self._data_center.items\n        obj_expr = [\n                self._var_x[item.index] * item.profit\n                for item in items\n                ]\n        self._solver.Maximize(self._solver.Sum(obj_expr))\n        \n    def _create_constraints(self):\n        items = self._data_center.items\n        capacities = self._data_center.capacities\n        expr = [\n            self._var_x[item.index] * \n                item.get_property('weight')\n            for item in items\n            ]\n        self._solver.Add(\n                self._solver.Sum(expr) &lt;= capacities['weight']\n            )\n        \n    @property\n    def opt_obj(self): return self._opt_obj\n    \n    def get_num_chosen_items(self):\n        return sum(self._opt_x)\n\nWe employ the model to tackle 10 benchmark instances that were downloaded from an online source (http://artemisa.unicauca.edu.co/~johnyortega/instances_01_KP/). Table 8.1 displays the computational results.\nMore specifically, the first column of the table lists the names of the instances, while the second and third columns indicate the number of items and the capacity of the knapsack for each instance, respectively. The last two columns report the optimal solution’s objective value and the number of selected items, respectively.\n\n\n\n\nTable 8.1: Computational results of Knapsack problems\n\n\nInstance\nNo. of Items\nCapacity\nOptimal Value\nNo. of Chosen Items\n\n\n\n\nf1_l-d_kp_10_269\n10\n269\n295\n6\n\n\nf2_l-d_kp_20_878\n20\n878\n1024\n17\n\n\nf3_l-d_kp_4_20\n4\n20\n35\n3\n\n\nf4_l-d_kp_4_11\n4\n11\n23\n2\n\n\nf5_l-d_kp_15_375\n15\n375\n481.069\n9\n\n\nf6_l-d_kp_10_60\n10\n60\n52\n7\n\n\nf7_l-d_kp_7_50\n7\n50\n107\n2\n\n\nf8_l-d_kp_23_10000\n23\n10000\n9767\n11\n\n\nf9_l-d_kp_5_80\n5\n80\n130\n4\n\n\nf10_l-d_kp_20_879\n20\n879\n1025\n17"
  },
  {
    "objectID": "ip-knapsack.html#multi-dimensional-knapsack-problem",
    "href": "ip-knapsack.html#multi-dimensional-knapsack-problem",
    "title": "8  The Knapsack Problem",
    "section": "8.2 Multi-Dimensional Knapsack Problem",
    "text": "8.2 Multi-Dimensional Knapsack Problem\nThe multi-dimensional knapsack problem is a variant of the classical knapsack problem where there are multiple candidate items and each item has multiple attributes or dimensions (Petersen (1967)). The goal is to select a subset of items that maximizes the total value or profit subject to the constraint that the sum of the attribute values of the selected items does not exceed certain limits.\nFormally, let there be \\(n\\) items, and for each item \\(j \\ (1 ≤ j ≤ n)\\), let:\n\n\\(v_j\\) be the profit of selecting it\n\\(w_{ij}\\) be the \\(i\\)th attribute value of item \\(j\\)\n\\(m\\) is the number of dimensions or attributes\n\\(W_i\\) is the capacity of the knapsack for dimension \\(i\\)\n\nThe multi-dimensional knapsack problem can then be formulated as the following optimization problem:\n\\[\\begin{align}\n    \\text{max.} &\\quad \\sum_{j = 1}^n v_j x_j \\label{knapsack2-obj} \\\\\n    \\text{s.t.} &\\quad \\sum_{j=1}^n w_{ij} x_j \\leq W_i, \\ \\forall i = 1, \\cdots, m \\label{knapsack2-cons1} \\\\\n    &\\quad x_j \\in \\{0, 1\\}, \\ j = 1, \\cdots, n \\label{knapsack2-cons2}\n\\end{align}\\]\nTo test the model, we take data from online source (http://people.brunel.ac.uk/~mastjjb/jeb/orlib/mknapinfo.html) and define a reading function read_mdkp_dataset_1() in class MDKPDataCenter. Note that the class inherits the KnapsackDataCenter class defined in the previous section, and all the parsed contents of an instance will be saved in the _items and _capacities attributes.\n\nclass MDKPDataCenter(KnapsackDataCenter):\n    \n    def read_mdkp_dataset_1(self, data_file: str):\n        \"\"\"read data from testing instance\n\n        Args:\n            data_file (str): data file\n        \"\"\"\n        with open(data_file) as f:\n            first_line = f.readline()\n            num_items, \\\n            num_constraints, \\\n            opt_val = first_line.split()\n            \n            second_line = f.readline()\n            profits = second_line.split()\n            item_idx = 0\n            for p in profits:\n                item = Item(item_idx, float(p))\n                self._items.append(item)\n                item_idx += 1\n\n            for i in range(int(num_constraints)):\n                line = f.readline()\n                weights = line.split()\n                prop = f'prop_{i}'\n                for idx, val in enumerate(weights):\n                    self._items[idx].set_property(\n                        prop,\n                        float(val)\n                    )\n\n            last_line = f.readline()\n            for idx, val in enumerate(last_line.split()):\n                prop = f'prop_{idx}'\n                self._capacities[prop] = float(val)\n\nNow we define in the code below the class MDKnapsackSolver that performs a couple of things:\n\ncreate variables in lines 31 - 34\ndefine objective in lines 36 - 42\ncreate constraints in line 44 - 58\n\n\nfrom ortools.linear_solver import pywraplp\n\nclass MDKnapsackSolver:\n    \n    def __init__(self, data_center):\n        self._data_center = data_center\n\n        self._solver = None\n        self._var_x = None\n\n        self._opt_obj = None\n        self._opt_x = None\n        \n    def build_model(self):\n        self._solver = pywraplp.Solver.CreateSolver('SCIP')\n\n        self._create_variables()\n        self._create_objective()\n        self._create_constraints()\n        \n    def optimize(self):\n        status = self._solver.Solve()\n        if status == pywraplp.Solver.OPTIMAL:\n            self._opt_obj = self._solver.Objective().Value()\n            items = self._data_center.items\n            self._opt_x = [\n                    self._var_x[item.index].solution_value()\n                    for item in items\n                ]\n    \n    def _create_variables(self):\n        items = self._data_center.items\n        self._var_x = [self._solver.BoolVar(name=f'x_{i}')\n                    for i, item in enumerate(items)]\n    \n    def _create_objective(self):\n        items = self._data_center.items\n        obj_expr = [\n                self._var_x[item.index] * item.profit\n                for item in items\n                ]\n        self._solver.Maximize(self._solver.Sum(obj_expr))\n        \n    def _create_constraints(self):\n        items = self._data_center.items\n        capacities = self._data_center.capacities\n        num_properties = len(capacities)\n        for p_idx in range(num_properties):\n            prop = f'prop_{p_idx}'\n            expr = [\n                self._var_x[item.index] * \n                    item.get_property(prop)\n                for item in items\n                ]\n            self._solver.Add(\n                    self._solver.Sum(expr) &lt;= \n                    capacities[prop], name=f'cons_{p_idx}'\n                )\n        \n    @property\n    def opt_obj(self): return self._opt_obj\n    \n    def get_num_chosen_items(self):\n        return sum(self._opt_x)\n\nTable 8.2 shows the computational results of some testing instances.\n\n\n\n\nTable 8.2: Computational results of multi-dimensional knapsack problems\n\n\nInstance\nNo. of Items\nOptimal Value\nNo. of Chosen Items\n\n\n\n\ninst1.txt\n6\n3800\n3\n\n\ninst2.txt\n10\n8706.1\n5\n\n\ninst3.txt\n15\n4015\n9\n\n\ninst4.txt\n20\n6120\n9\n\n\ninst5.txt\n28\n12400\n18\n\n\ninst6.txt\n39\n10618\n27\n\n\ninst7.txt\n50\n16537\n35"
  },
  {
    "objectID": "ip-knapsack.html#multi-choice-knapsack-problem",
    "href": "ip-knapsack.html#multi-choice-knapsack-problem",
    "title": "8  The Knapsack Problem",
    "section": "8.3 Multi-Choice Knapsack Problem",
    "text": "8.3 Multi-Choice Knapsack Problem\nIn the multi-choice knapsack problem, there are \\(n\\) candidate items to be placed in a knapsack and each item belongs to a specific class \\(k = 1, \\cdots m\\). It is required that only one item can be selected from each class. The problem can be formulated as below (Sinha and Zoltners (1979)).\n\\[\\begin{align}\n    \\text{max.} &\\quad \\sum_{j=1}^n v_j x_j \\label{knapsack3-obj} \\\\\n    \\text{s.t.} &\\quad \\sum_{j=1}^n w_j x_j \\leq W \\label{knapsack3-cons1}\\\\\n    &\\quad \\sum_{j=1}^n c_{jk} x_j = 1, \\ \\forall k = 1, \\cdots m \\label{knapsack3-cons2}\\\\\n    &\\quad x_j = \\{0, 1\\}, \\ \\forall j = 1, \\cdots n \\label{knapsack3-cons3}\n\\end{align}\\]\nThe class MCKPDataCenter defines a reader function to parse the instances available online (https://or-dii.unibs.it/index.php?page=tiks).\n\nclass MCKPDataCenter(KnapsackDataCenter):\n    \n    def __init__(self):\n        super().__init__()\n        \n        self._num_classes = 0\n        self._num_choices = 0\n    \n    def read_mcmdkp_dataset_1(self, data_file: str):\n        with open(data_file) as f:\n            f.readline()\n            num_classes,\\\n            num_choices,\\\n            num_constraints = f.readline().split()\n            self._num_classes = int(num_classes)\n            self._num_choices = int(num_choices)\n            \n            capacities = f.readline().split()\n            for p_idx in range(int(num_constraints)):\n                prop = f'prop_{p_idx}'\n                self._capacities[prop] = float(capacities[p_idx])\n            \n            item_idx = 0\n            for i in range(int(num_classes)):\n                f.readline()\n                for c in range(int(num_choices)):\n                    line = f.readline().split()\n                    item = Item(item_idx, profit=float(line[0]))\n                    for p_idx in range(int(num_constraints)):\n                        prop = f'prop_{p_idx}'\n                        item.set_property(prop, float(line[p_idx + 1]))\n                        item.set_class(i)\n                    item_idx += 1\n                    self._items.append(item)\n                    \n    @property\n    def num_classes(self): return self._num_classes\n    \n    @property\n    def num_choices(self): return self._num_choices\n\nThe complete code to solve the problem is given below.\n\nfrom ortools.linear_solver import pywraplp\n\nclass MCKnapsackSolver:\n    \n    def __init__(self, data_center):\n        self._data_center = data_center\n\n        self._solver = None\n        self._var_x = None\n\n        self._opt_obj = None\n        self._opt_x = None\n        \n    def build_model(self):\n        self._solver = pywraplp.Solver.CreateSolver('SCIP')\n\n        self._create_variables()\n        self._create_objective()\n        self._create_constraints()\n        \n    def optimize(self):\n        status = self._solver.Solve()\n        if status == pywraplp.Solver.OPTIMAL:\n            self._opt_obj = self._solver.Objective().Value()\n            items = self._data_center.items\n            self._opt_x = [\n                    self._var_x[item.index].solution_value()\n                    for item in items\n                ]\n    \n    def _create_variables(self):\n        items = self._data_center.items\n        self._var_x = [self._solver.BoolVar(name=f'x_{i}')\n                    for i, item in enumerate(items)]\n    \n    def _create_objective(self):\n        items = self._data_center.items\n        obj_expr = [\n                self._var_x[item.index] * item.profit\n                for item in items\n                ]\n        self._solver.Maximize(self._solver.Sum(obj_expr))\n        \n    def _create_constraints(self):\n        items = self._data_center.items\n        capacities = self._data_center.capacities\n        p_idx = 0\n        prop = f'prop_{p_idx}'\n        expr = [\n            self._var_x[item.index] * \n                item.get_property(prop)\n            for item in items\n            ]\n        self._solver.Add(\n                self._solver.Sum(expr) &lt;= \n                capacities[prop], name=f'cons_{p_idx}'\n            )\n        \n        num_classes = self._data_center.num_classes\n        for k in range(num_classes):\n            expr = [self._var_x[item.index]\n                for item in items\n                if item.get_class() == k]\n            self._solver.Add(\n                self._solver.Sum(expr) == 1\n            )\n        \n    @property\n    def opt_obj(self): return self._opt_obj\n    \n    def get_num_chosen_items(self):\n        return sum(self._opt_x)\n\nTable 8.3 shows some computational experiments.\n\n\n\n\nTable 8.3: Computational results of multi-choice knapsack problems\n\n\nInstance\nNo. of Items\nOptimal Value\nNo. of Chosen Items\n\n\n\n\nINST01.txt\n500\n13411\n50\n\n\nINST02.txt\n500\n13953\n50\n\n\nINST03.txt\n600\n15727\n60\n\n\nINST04.txt\n700\n18928\n70\n\n\nINST05.txt\n750\n20314\n75\n\n\nINST06.txt\n750\n20277\n75\n\n\nINST07.txt\n800\n21372\n80\n\n\nINST08.txt\n800\n21556\n80\n\n\nINST09.txt\n800\n21581\n80\n\n\nINST10.txt\n900\n24232\n90\n\n\nINST11.txt\n900\n24267\n90\n\n\nINST12.txt\n1000\n26206\n100\n\n\nINST13.txt\n3000\n24382\n100\n\n\nINST14.txt\n4500\n36971\n150\n\n\nINST15.txt\n5400\n44001\n180\n\n\nINST16.txt\n6000\n48833\n200\n\n\nINST17.txt\n7500\n61056\n250\n\n\nINST18.txt\n5600\n68021\n280\n\n\nINST19.txt\n6000\n73054\n300\n\n\nINST20.txt\n7000\n84958\n350"
  },
  {
    "objectID": "ip-knapsack.html#multi-choice-multi-dimensional-knapsack-problem",
    "href": "ip-knapsack.html#multi-choice-multi-dimensional-knapsack-problem",
    "title": "8  The Knapsack Problem",
    "section": "8.4 Multi-Choice Multi-Dimensional Knapsack Problem",
    "text": "8.4 Multi-Choice Multi-Dimensional Knapsack Problem\nIn the multi-choice multi-dimensional knapsack problem (MCMDKP), there are \\(n\\) candidate items and each item belongs to a specific class \\(k = 1, \\cdots, m\\). Each item also has \\(d\\) attributes. The requirement is to select exactly one item from each class such that the total profit is maximized. Note that the knapsack capacity cannot be violated for any item attribute. The MCMDKP can be formulated as follows (Chen and Hao (2014)).\n\\[\\begin{align}\n    \\text{max.} &\\quad \\sum_{j=1}^n v_j x_j \\label{knapsack4-obj} \\\\\n    \\text{s.t.} &\\quad \\sum_{j=1}^n w_{ij} x_j \\leq W_i, \\ \\forall i = 1, \\cdots d \\\\\n    &\\quad \\sum_{j=1}^n c_{jk} x_j = 1, \\ \\forall k = 1, \\cdots m\\\\\n    &\\quad x_j = \\{0, 1\\}, \\ \\forall j = 1, \\cdots n\n\\end{align}\\]\nThe code snippet below gives the complete program to solve this problem.\n\nfrom ortools.linear_solver import pywraplp\n\nclass MCMDKnapsackSolver:\n    \n    def __init__(self, data_center):\n        self._data_center = data_center\n\n        self._solver = None\n        self._var_x = None\n\n        self._opt_obj = None\n        self._opt_x = None\n        \n    def build_model(self):\n        self._solver = pywraplp.Solver.CreateSolver('SCIP')\n\n        self._create_variables()\n        self._create_objective()\n        self._create_constraints()\n        \n    def optimize(self):\n        status = self._solver.Solve()\n        if status == pywraplp.Solver.OPTIMAL:\n            self._opt_obj = self._solver.Objective().Value()\n            items = self._data_center.items\n            self._opt_x = [\n                    self._var_x[item.index].solution_value()\n                    for item in items\n                ]\n    \n    def _create_variables(self):\n        items = self._data_center.items\n        self._var_x = [self._solver.BoolVar(name=f'x_{i}')\n                    for i, item in enumerate(items)]\n    \n    def _create_objective(self):\n        items = self._data_center.items\n        obj_expr = [\n                self._var_x[item.index] * item.profit\n                for item in items\n                ]\n        self._solver.Maximize(self._solver.Sum(obj_expr))\n        \n    def _create_constraints(self):\n        items = self._data_center.items\n        capacities = self._data_center.capacities\n        num_properties = len(capacities)\n        for p_idx in range(num_properties):\n            prop = f'prop_{p_idx}'\n            expr = [\n                self._var_x[item.index] * \n                    item.get_property(prop)\n                for item in items\n                ]\n            self._solver.Add(\n                    self._solver.Sum(expr) &lt;= \n                    capacities[prop], name=f'cons_{p_idx}'\n                )\n        \n        num_classes = self._data_center.num_classes\n        for k in range(num_classes):\n            expr = [self._var_x[item.index]\n                for item in items\n                if item.get_class() == k]\n            self._solver.Add(\n                self._solver.Sum(expr) == 1\n            )\n        \n    @property\n    def opt_obj(self): return self._opt_obj\n    \n    def get_num_chosen_items(self):\n        return sum(self._opt_x)\n\nTable 8.4 shows some empirical computational results.\n\n\n\n\nTable 8.4: Computational results of multi-choice multi-dimensional knapsack problems\n\n\nInstance\nNo. of Items\nOptimal Value\nNo. of Chosen Items\n\n\n\n\nINST01.txt\n250\n7059\n25\n\n\nINST02.txt\n250\n6998\n25\n\n\nINST03.txt\n300\n8418\n30\n\n\nINST04.txt\n300\n8518\n30\n\n\nINST05.txt\n300\n8418\n30\n\n\nINST06.txt\n300\n8418\n30\n\n\nINST07.txt\n300\n8418\n30\n\n\nINST08.txt\n300\n8418\n30\n\n\nINST09.txt\n300\n8418\n30\n\n\nINST10.txt\n300\n8418\n30\n\n\nINST11.txt\n300\n8418\n30\n\n\nINST12.txt\n300\n8418\n30\n\n\nINST13.txt\n900\n8833\n30\n\n\nINST14.txt\n900\n8841\n30\n\n\nINST15.txt\n900\n8833\n30\n\n\nINST16.txt\n900\n8788\n30\n\n\nINST17.txt\n900\n8820\n30\n\n\nINST18.txt\n600\n8664\n30\n\n\nINST19.txt\n600\n8667\n30\n\n\nINST20.txt\n600\n8714\n30\n\n\n\n\n\n\n\n\n\n\nChen, Yuning, and Jin-Kao Hao. 2014. “A ‘Reduce and Solve’ Approach for the Multiple-Choice Multidimensional Knapsack Problem.” European Journal of Operational Research 239 (2): 313–22. https://doi.org/10.1016/j.ejor.2014.05.025.\n\n\nDudziński, Krzysztof, and Stanisław Walukiewicz. 1987. “Exact Methods for the Knapsack Problem and Its Generalizations.” European Journal of Operational Research 28 (1): 3–21. https://doi.org/10.1016/0377-2217(87)90165-2.\n\n\nPetersen, Clifford C. 1967. “Computational Experience with Variants of the Balas Algorithm Applied to the Selection of R&D Projects.” Management Science 13 (9): 736–50. https://doi.org/10.1287/mnsc.13.9.736.\n\n\nSinha, Prabhakant, and Andris A. Zoltners. 1979. “The Multiple-Choice Knapsack Problem.” Operations Research 27 (3): 503–15. https://www.jstor.org/stable/170213."
  },
  {
    "objectID": "ip-nqueens.html",
    "href": "ip-nqueens.html",
    "title": "9  The N-queens Problem",
    "section": "",
    "text": "The n-queens problem is a classic puzzle that involves placing \\(n\\) queens on an \\(n \\times n\\) chessboard in such a way that no two queens threaten each other. In other words, no two queens can be placed on the same row, column, or diagonal. The problem is called the \\(n\\)-queens problem because it can be generalized to any size of \\(n\\).\nFor example, the 8-queens problem involves placing 8 queens on an 8x8 chessboard, and the solution requires that no two queens share the same row, column, or diagonal.\nThe n-queens problem is a well-known problem in computer science and has been studied extensively because it has applications in various fields, such as optimization, artificial intelligence, and computer graphics. There are various algorithms and techniques that can be used to solve the n-queens problem, including brute-force search, backtracking, and genetic algorithms. In this chapter, we’ll model this problem as an integer programming problem and solve it using OR-Tools.\nTo model this problem on an \\(n \\times n\\) chessboard, we define the following decision variable:\n\n\\(x_{ij}\\): a binary variable that equals 1 if a queen is place on position \\((i, j)\\), where \\(i, j = 0, \\cdots, n-1\\); and 0 otherwise\n\nThe complete model given below is based on Letavec and Ruggiero (2002).\n\\[\\begin{align}\n    \\text{max.} &\\quad 0 \\label{nq-obj}\\\\\n    \\text{s.t.} &\\quad \\sum_{i=0}^{n-1} \\sum_{j=0}^{n-1} x_{ij} = n \\label{nq-cons1} \\\\\n    &\\quad \\sum_{j=0}^{n-1} x_{ij} \\leq 1, \\ \\forall i = 0, \\cdots, n-1 \\label{nq-cons2} \\\\\n    &\\quad \\sum_{i=0}^{n-1} x_{ij} \\leq 1, \\ \\forall j = 0, \\cdots, n-1 \\label{nq-cons3}\\\\\n    &\\quad \\sum_{i=0}^{n-1} \\sum_{j=0, i+j=k}^{n-1} x_{ij} \\leq 1, \\ \\forall k = 1, \\cdots, 2(n-1) - 1 \\label{nq-cons4}\\\\\n    &\\quad \\sum_{i=0}^{n-1} \\sum_{j=0, i-j=k}^{n-1} x_{ij} \\leq 1, \\ \\forall k = 2-n, \\cdots, n-2 \\label{nq-cons5}\\\\\n    &\\quad x_{ij} \\in \\{0, 1\\},\\  i, j = 0, \\cdots, n-1\n\\end{align}\\]\nIn the formulation, the objective function \\(\\eqref{nq-obj}\\) serves no practical use as our goal is to find any feasible solution to the puzzle. Constraints \\(\\eqref{nq-cons1}\\) require that there are exactly \\(n\\) queens be placed on a board of size \\(n \\times n\\). Constraints \\(\\eqref{nq-cons2}\\) make sure that there is at most one queen be placed in any row of the board. Similarly, constraints \\(\\eqref{nq-cons3}\\) ensure that there is at most one queen be placed in any column of the board. To understand constraints \\(\\eqref{nq-cons4}\\) and \\(\\eqref{nq-cons5}\\), let’s look at a 8-queens solution in Figure 9.1.\nNote that no two queens can be placed on the same diagonal anywhere on the board. Upon observing the chessboard, we can see that there are two types of diagonals:\n\nDiagonals that start from the upper left corner and move to the bottom right corner\n\nPositions (1, 0), (0, 1) form a diagonal - sum of position coordinates = 1\nPositions (2, 0), (1, 1), (0, 2) form a diagonal - sum of position coordinates = 2\n…\nPositions (7, 6), (6, 7) form a diagonal - sum of position coordinates = 2 * (8 - 1) - 1\n\nDiagonals that start from the upper right corner and move to the bottom left corner\n\nPositions (0, 6), (1, 7) form a diagonal - difference of position coordinates = -6\nPositions (0, 5), (1, 6), (2, 7) form a diagonal - difference of position coordinates = -5\n…\nPositions (6, 0), (7, 1) form a diagonal - difference of position coordinates = 8 - 2\n\n\nThe first type of diagonals can be expressed as constraints \\(\\eqref{nq-cons4}\\) and the second type of diagonals can be expressed as constraints \\(\\eqref{nq-cons5}\\). Both constraints guarantee that there cannot be any two queens showing up in the same diagonal.\n\n\n\n\n\nFigure 9.1: A 8-Queens solution\n\n\n\n\nThe complete code to solve the problem is given below.\n\nfrom ortools.linear_solver import pywraplp\nimport numpy as np\nfrom itertools import product\n\nclass NQueensSolver:\n    \n    def __init__(self, size: int):\n        self._size = size\n        \n        self._solver = None\n        self._var_x = None\n        self._opt_x = None\n        \n    def build_model(self):\n        # instantiate solver\n        self._solver = pywraplp.Solver.CreateSolver('SCIP')\n\n        # create decision variables\n        self._var_x = np.empty((self._size, self._size), \n                            dtype=object)\n        for i, j in product(range(self._size), \n                            range(self._size)):\n            self._var_x[i][j] = \\\n                self._solver.BoolVar(name=f'x_{i,j}')\n\n        # declare objective function\n        self._solver.Maximize(0)\n        \n        # constraint: there must be n queens on the board\n        expr = [self._var_x[i][j]\n                for i in range(self._size)\n                for j in range(self._size)]\n        self._solver.Add(self._solver.Sum(expr) == self._size)\n\n        # constraint: no two queens can be in the same row\n        for row in range(self._size):\n            expr = [self._var_x[row][j]\n                    for j in range(self._size)]\n            self._solver.Add(self._solver.Sum(expr) &lt;= 1)\n            \n        # constraint: no two queens can be in the same column\n        for col in range(self._size):\n            expr = [self._var_x[i][col]\n                    for i in range(self._size)]\n            self._solver.Add(self._solver.Sum(expr) &lt;= 1)\n\n        # constraint: no two queens can be in the same diagonal\n        for k in range(1, 2 * (self._size - 1) - 1):\n            expr = [self._var_x[i][j]\n                    for i in range(self._size)\n                    for j in range(self._size)\n                    if i + j == k]\n            self._solver.Add(self._solver.Sum(expr) &lt;= 1)\n\n        for k in range(2 - self._size, self._size - 2):\n            expr = [self._var_x[i][j]\n                    for i in range(self._size)\n                    for j in range(self._size)\n                    if i - j == k]\n            self._solver.Add(self._solver.Sum(expr) &lt;= 1)\n    \n    def optimize(self):\n        status = self._solver.Solve()\n        if status == pywraplp.Solver.OPTIMAL:\n            self._opt_x = np.zeros((self._size, \n                                    self._size))\n            for i, j in product(range(self._size), \n                                range(self._size)):\n                self._opt_x[i][j] = \\\n                    self._var_x[i][j].solution_value()\n        else:\n            print(\"solve failure!\")\n            print(f\"status={status}\")\n\n    @property\n    def opt_x(self): return self._opt_x\n    \n    def get_queen_coordinates(self):\n        coordinates = [(i, j) \n            for i in range(self._size)\n            for j in range(self._size)\n            if self._opt_x[i][j] == 1]\n        return coordinates\n\nFigure 9.2 shows a 4-Queens puzzle solution.\n\n\n\n\n\nFigure 9.2: A 4-Queens solution\n\n\n\n\nFigure 9.3 shows a 10-Queens puzzle solution.\n\n\n\n\n\nFigure 9.3: A 10-Queens solution\n\n\n\n\nFigure 9.4 shows a 20-Queens puzzle solution.\n\n\n\n\n\nFigure 9.4: A 20-Queens solution\n\n\n\n\n\n\n\n\nLetavec, Craig, and John Ruggiero. 2002. “The n -Queens Problem.” INFORMS Transactions on Education 2 (3): 101–3. https://doi.org/10.1287/ited.2.3.101."
  },
  {
    "objectID": "ip-srflp.html",
    "href": "ip-srflp.html",
    "title": "10  Single Row Facility Layout Problem",
    "section": "",
    "text": "Single Row Facility Layout Problem (SRFLP) is a type of optimization problem in which the objective is to arrange a set of facilities in a single row in such a way as to minimize the total cost of movement between facilities. In other words, the goal is to find the best possible arrangement of facilities in a linear fashion that minimizes the total distance traveled by workers or materials between facilities. The SRFLP has a wide range of applications in various industries:\n\nManufacturing Industry: In manufacturing plants, the SRFLP is used to determine the optimal placement of machines, workstations, and other facilities in a single line to minimize material handling and transportation costs. By arranging the facilities in an optimal sequence, the movement of raw materials, work-in-progress, and finished products can be minimized, reducing production time and costs.\nWarehousing and Distribution: In the warehousing and distribution industry, the SRFLP is used to optimize the layout of storage areas, packing and shipping stations, and other facilities. By minimizing the distance traveled between facilities, the time and cost of moving products within the warehouse or distribution center can be reduced.\nRetail Industry: The SRFLP can be used to optimize the layout of retail stores, such as supermarkets and department stores. By arranging product displays and checkout stations in an optimal sequence, customer flow can be improved, and waiting times can be reduced, resulting in better customer satisfaction and increased sales.\nHealthcare Industry: In hospitals and clinics, the SRFLP can be used to optimize the layout of patient rooms, laboratories, and other medical facilities. By arranging these facilities in an optimal sequence, healthcare professionals can move more efficiently, reducing patient wait times and improving the quality of care.\nOffice Layout: The SRFLP can also be used to optimize the layout of office spaces, including the arrangement of desks, meeting rooms, and common areas. By minimizing the distance between facilities, the productivity and efficiency of workers can be improved.\n\nIn summary, the SRFLP has many applications in different industries, where the optimization of facility layout can result in significant cost savings, improved productivity, and increased customer satisfaction.\nThe SRFLP can be defined as follows: Assume there are \\(n\\) rooms of different lengths \\(h_i\\) that need to be arranged in a single row. The flow of materials between each pair of rooms, denoted by \\(w_{ij}\\), is already known. Let \\(\\mathcal{N}\\) represent the set of rooms to be arranged, which consists of integers from 0 to \\(n-1\\). Let \\(H\\) be the sum of the lengths of all the rooms, and let \\(V\\) be a large number.\nTo formulate the problem mathematically, we introduce the following variables:\n\n\\(x_{ij}\\): a binary variable that takes the value of 1 if room \\(i\\) is placed to the left of room \\(j\\), and 0 otherwise.\n\\(y_i\\): a continuous variable that represents the location of the starting point of room \\(i\\) on the line.\n\\(l_{ij}\\): a continuous variable that represents the distance between the centroid of room \\(i\\) and the centroid of room \\(j\\) if room \\(i\\) is placed to the left of room \\(j\\), and 0 otherwise.\n\\(r_{ij}\\): a continuous variable that represents the distance between the centroid of room \\(i\\) and the centroid of room \\(j\\) if room \\(i\\) is placed to the right of room \\(j\\), and 0 otherwise.\n\nThe SRFLP can then be formulated as follows:\n\\[\\begin{align}\n    \\text{min.} &\\quad \\sum_{i=0}^{n-2} \\sum_{j=i+1}^{n-1} w_{ij} \\cdot (l_{ij} + r_{ij}) \\label{srfl-obj}\\\\\n    \\text{s.t.} &\\quad 0 \\leq y_i \\leq H, \\ \\forall i = 0, \\cdots, n-1 \\label{srfl-cons1} \\\\\n    &\\quad y_i \\geq y_j + h_j - V \\cdot x_{ij}, \\ \\forall i, j \\in \\mathcal{N}, \\ i &lt; j \\label{srfl-cons2}  \\\\\n    &\\quad y_j \\geq y_i + h_i - V \\cdot (1 - x_{ij}), \\ \\forall i, j \\in \\mathcal{N}, \\ i &lt; j \\label{srfl-cons3}  \\\\\n    &\\quad r_{ij} - l_{ij} = y_i - y_j + \\frac{1}{2} (h_i - h_j), \\ \\forall i, j \\in \\mathcal{N}, i \\neq j \\label{srfl-cons4}  \\\\\n    &\\quad x_{ij} \\in \\{0, 1\\}, \\ \\forall i, j \\in \\mathcal{N}, i \\neq j \\label{srfl-cons5} \\\\\n    &\\quad y_i \\geq 0, \\ \\forall i \\in \\mathcal{N} \\label{srfl-cons6} \\\\\n    &\\quad l_{ij} \\geq 0, \\ \\forall i, j \\in \\mathcal{N}, i \\neq j \\label{srfl-cons7}  \\\\\n    &\\quad r_{ij} \\geq 0, \\ \\forall i, j \\in \\mathcal{N}, i \\neq j  \\label{srfl-cons8} \\\\\n\\end{align}\\]\nThe goal of the objective function \\(\\eqref{srfl-obj}\\) is to minimize the total cost of moving all the rooms. The constraints \\(\\eqref{srfl-cons1}\\) ensure that the starting point of each room is within the range of \\([0, H]\\). Constraints \\(\\eqref{srfl-cons2}\\) and \\(\\eqref{srfl-cons3}\\) are complementary disjunctive constraints that ensure that no two rooms overlap with each other. Constraints \\(\\eqref{srfl-cons4}\\) calculate the distance between the centroids of any two rooms placed in a specific order on the line. The remaining constraints specify the type of variables used.\nTo evaluate the effectiveness of the formulated model, we utilize benchmarking instances obtained from an online source (https://grafo.etsii.urjc.es/optsicom/srflp.html). In the following code, we define a class called SRFLPDataCenter. This class is responsible for parsing the instance file and storing the relevant information in its attributes.\n\nimport numpy as np\n\nclass SRFLPDataCenter:\n    \n    def __init__(self):\n        self._num_rooms = None\n        self._room_lengths = None\n        self._distance_matrix = None\n        \n    def read_data(self, data_file):\n        with open(data_file) as f:\n            first_line = f.readline()\n            self._num_rooms = int(first_line)\n\n            second_line = f.readline().split()\n            self._room_lengths = [\n                float(v) for v in second_line\n            ]\n            \n            self._distance_matrix = \\\n                np.zeros((self._num_rooms, self._num_rooms))\n            for row in range(self._num_rooms):\n                line = f.readline().split()\n                for col in range(self._num_rooms):\n                    self._distance_matrix[row][col] = \\\n                        float(line[col])\n                    \n    @property\n    def num_rooms(self): return self._num_rooms\n    \n    def get_room_length(self, room_idx):\n        return self._room_lengths[room_idx]\n\n    def get_distance(self, i, j):\n        return self._distance_matrix[i][j]\n    \n\nThe following code provides a comprehensive program that uses OR-Tools to solve the SRFLP.\n\nfrom ortools.linear_solver import pywraplp\nfrom itertools import product\nimport numpy as np\n\nclass SRFLPSolver:\n    \n    def __init__(self, data_center):\n        self._data_center = data_center\n\n        self._solver = None\n        self._var_x = None\n        self._var_y = None\n        self._var_l = None\n        self._var_r = None\n        \n        self._opt_obj = None\n        self._opt_y = None\n        \n    def build_model(self):\n        self._solver = pywraplp.Solver.CreateSolver('SCIP')\n        \n        self._create_variables()\n        self._create_objective()\n        self._create_constraints()\n        \n    def _create_variables(self):\n        num_rooms = self._data_center.num_rooms\n        self._var_x = np.empty(\n                        (num_rooms, num_rooms), \n                        dtype=object\n                    )\n        for i, j in product(range(num_rooms), \n                            range(num_rooms)):\n            if i == j: continue\n            self._var_x[i][j] = \\\n                self._solver.BoolVar(name=f'x_{i, j}')\n\n        H = sum([self._data_center.get_room_length(r)\n                for r in range(num_rooms)])\n        self._var_y = [\n                    self._solver.NumVar(0, H, name=f\"y_{i}\")\n                    for i in range(num_rooms)\n                ]\n\n        infinity = self._solver.Infinity()\n        self._var_l = np.empty((num_rooms, num_rooms), \n                            dtype=object)\n        self._var_r = np.empty((num_rooms, num_rooms),\n                            dtype=object)\n        for i, j in product(range(num_rooms), \n                            range(num_rooms)):\n            if i == j: continue\n            self._var_l[i][j] = \\\n                self._solver.NumVar(0, \n                                    infinity, \n                                    name=f\"l_{i,j}\")\n            self._var_r[i][j] = \\\n                self._solver.NumVar(0, \n                                    infinity, \n                                    name=f\"r_{i,j}\")\n\n    def _create_objective(self):\n        num_rooms = self._data_center.num_rooms\n        expr = [\n            self._data_center.get_distance(i, j) *\n            (self._var_l[i][j] + self._var_r[i][j])\n            for i in range(0, num_rooms - 1)\n            for j in range(i + 1, num_rooms)\n        ]\n        self._solver.Minimize(self._solver.Sum(expr))\n\n    def _create_constraints(self):\n        num_rooms = self._data_center.num_rooms\n        H = sum([self._data_center.get_room_length(r)\n                for r in range(num_rooms)])\n        for i in range(0, num_rooms):\n            hi = self._data_center.get_room_length(i)\n            for j in range(i + 1, num_rooms):\n                hj = self._data_center.get_room_length(j)\n                self._solver.Add(\n                    self._var_y[i] &gt;=\n                    self._var_y[j] +\n                    hj -\n                    H * self._var_x[i][j]\n                )\n                \n                self._solver.Add(\n                    self._var_y[j] &gt;=\n                    self._var_y[i] +\n                    hi -\n                    H * (1 - self._var_x[i][j])\n                )\n\n        for i, j in product(range(num_rooms), \n                            range(num_rooms)):\n            if i == j: continue\n            hi = self._data_center.get_room_length(i)\n            hj = self._data_center.get_room_length(j)\n            self._solver.Add(\n                self._var_r[i][j] - self._var_l[i][j] ==\n                self._var_y[i] - self._var_y[j] +\n                0.5 * (hi - hj)\n            )\n\n    def optimize(self):\n        status = self._solver.Solve()\n        if status == pywraplp.Solver.OPTIMAL:\n            self._opt_obj = self._solver.Objective().Value()\n            print(f\"obj = {self._opt_obj:.2f}\")\n            \n            num_rooms = self._data_center.num_rooms\n            self._opt_y = [\n                self._var_y[r].solution_value()\n                for r in range(num_rooms)\n            ]\n            for r in range(num_rooms):\n                print(f\"room {r} starting position: \\\n                    {self._opt_y[r]:.2f},\\t\\\n                    length: \\\n                        {self._data_center.get_room_length(r)}\")\n\nTo test the program since the original instance is too large, we use the first 8 rooms from the instance AnKeVa_2005_60dept_set1 and solve it using OR-Tools. The program will output the optimal objective value and the positions of all the rooms.\n\nimport os\n\ndata_dir = \"./data/srflp/Anjos\"\ndata_file = \"AnKeVa_2005_60dept_set1-mini.txt\"\n\ndata_center = SRFLPDataCenter()\ndata_center.read_data(os.path.join(data_dir, data_file))\n\nsolver = SRFLPSolver(data_center)\nsolver.build_model()\nsolver.optimize()\n\nobj = 3715.00\nroom 0 starting position: 217.00,                       length: 53.0\nroom 1 starting position: 138.00,                       length: 7.0\nroom 2 starting position: 53.00,                        length: 47.0\nroom 3 starting position: 147.00,                       length: 15.0\nroom 4 starting position: 100.00,                       length: 38.0\nroom 5 starting position: 189.00,                       length: 28.0\nroom 6 starting position: 162.00,                       length: 27.0\nroom 7 starting position: 145.00,                       length: 2.0"
  },
  {
    "objectID": "ip-wlp.html",
    "href": "ip-wlp.html",
    "title": "11  Warehouse Location Problem",
    "section": "",
    "text": "The warehouse location problem (WLP) is a classic optimization problem in operations research that aims to find the optimal locations for warehouses in order to minimize transportation costs while meeting the demand for goods from a set of customers. The problem is particularly relevant for businesses that need to distribute their products across a large geographic region.\nThe problem can be formulated as follows: Given a set of stores \\(\\mathcal{S} = \\{1, \\cdots, s\\}\\) and a set of potential warehouse locations \\(\\mathcal{W} = \\{1, \\cdots, w\\}\\), the objective is to select a subset of warehouse locations and allocate stores to these locations such that the total transportation cost is minimized. The transportation cost typically depends on the distance between each store and the warehouse they are assigned to, as well as the quantity of goods that need to be transported.\nIn order to simplify our mathematical model, we utilize the following symbols to indicate the input parameters:\n\n\\(f_w\\): the fixed cost required for initiating warehouse \\(w\\)\n\\(c_{ws}\\): the cost of transporting goods from warehouse \\(w\\) to store \\(s\\)\n\\(d_s\\): the quantity of goods demanded by store \\(s\\)\n\\(N_w\\): the storage capacity of warehouse \\(w\\)\n\nWe can then define two variables:\n\n\\(y_s\\): a binary variable that takes on a value of 1 if warehouse \\(s\\) is chosen, and 0 otherwise\n\\(x_{ws}\\): a continuous variable that represents the fraction of store \\(s\\)’s demand that will be met by warehouse \\(w\\)\n\nThe complete model of this problem is given below.\n\\[\\begin{align}\n    \\text{min.} &\\quad \\sum_{w \\in \\mathcal{W}} \\sum_{s \\in \\mathcal{S}} c_{ws} d_s x_{ws} + \\sum_{w \\in \\mathcal{W}} f_w y_w \\label{wlp-obj} \\\\\n    \\text{s.t.} &\\quad \\sum_{w \\in \\mathcal{W}} x_{ws} = 1, \\ \\forall s \\in \\mathcal{S} \\label{wlp-cons1} \\\\\n    &\\quad \\sum_{s \\in \\mathcal{S}} d_s x_{ws} \\leq N_w y_w, \\ \\forall w \\in \\mathcal{W} \\label{wlp-cons2} \\\\\n    &\\quad 0 \\leq x_{ws} \\leq 1, \\ \\forall w \\in \\mathcal{W}, s \\in \\mathcal{S} \\label{wlp-cons3} \\\\\n    &\\quad y_w \\in \\{0, 1\\}, \\ \\forall w \\in \\mathcal{W} \\label{wlp-cons4}\n\\end{align}\\]\nThe objective function \\(\\eqref{wlp-obj}\\) is to minimize the total cost of transportation and the fixed cost of opening warehouses. The first term of the objective function sums up the transportation cost of moving goods from each warehouse \\(w\\) to each store \\(s\\), multiplied by the proportion of store \\(s\\)’s demand met by warehouse \\(w\\), represented by \\(x_{ws}\\). The second term of the objective function sums up the fixed cost of opening each warehouse \\(w\\), represented by \\(f_w\\), multiplied by a binary variable \\(y_w\\) that takes on a value of 1 if warehouse \\(w\\) is selected, and 0 otherwise.\nThe model is subject to four constraints:\n\nConstraint \\(\\eqref{wlp-cons1}\\) ensures that the entire demand of each store \\(s\\) is met. The sum of \\(x_{ws}\\) over all warehouses must be equal to 1 for each store \\(s\\).\nConstraint \\(\\eqref{wlp-cons2}\\) ensures that the total demand of all stores served by warehouse \\(w\\) does not exceed its capacity \\(N_w\\). The sum of \\(d_s x_{ws}\\) over all stores \\(s\\) must be less than or equal to \\(N_w y_w\\) for each warehouse \\(w\\).\nConstraint \\(\\eqref{wlp-cons3}\\) ensures that the fraction of store \\(s\\)’s demand met by warehouse \\(w\\), represented by \\(x_{ws}\\), is between 0 and 1.\nConstraint \\(\\eqref{wlp-cons4}\\) ensures that the binary variable \\(y_w\\) takes on a value of either 0 or 1, indicating whether or not warehouse \\(w\\) is selected.\n\nTo demonstrate the solution process for the Warehouse Location Problem (WLP) using OR-Tools, we will use some sample instances available online from the website https://opthub.uniud.it/problem/facility-location/wlp. Specifically, we will be using an instance file called wlp2, the contents of which are shown below.\nWarehouses = 2;\nStores = 5;\n\nCapacity = [65, 47];\nFixedCost = [80, 184];\nGoods = [4, 15, 17, 6, 6];\nSupplyCost = [|57, 71\n              |30, 59\n              |43, 71\n              |37, 72\n              |30, 68|];\nIn this instance file, there are 2 warehouses and 5 stores. The Capacity array specifies the maximum capacity of each warehouse, where the first warehouse has a capacity of 65 and the second has a capacity of 47. The FixedCost array specifies the fixed cost of opening each warehouse, where the first warehouse has a fixed cost of 80 and the second has a fixed cost of 184. The Goods array specifies the demand for each store, where the first store has a demand of 4, the second store has a demand of 15, the third store has a demand of 17, the fourth store has a demand of 6, and the fifth store has a demand of 6. The SupplyCost matrix specifies the transportation cost of moving goods from each warehouse to each store. The entry in row \\(i\\) and column \\(j\\) of the matrix represents the transportation cost of moving goods from warehouse \\(j\\) to store \\(i\\). For example, the transportation cost of moving goods from the first warehouse to the first store is 57, the transportation cost of moving goods from the second warehouse to the fourth store is 71, etc.\nWe will create a WlpDataCenter class that will be responsible for reading and storing the necessary information required for solving the problem later on.\n\nimport re\n\nclass WlpDataCenter:\n    \n    def __init__(self):\n        self._num_warehouses = None\n        self._num_stores = None\n        self._capacities = None\n        self._fixed_costs = None\n        self._demands = None\n        self._transport_costs = None\n    \n    def read_data(self, data_file):\n        with open(data_file) as f:\n            lines = f.readlines()\n    \n        self._num_warehouses = int(re.findall(r'\\d+', \n                                            lines[0])[0])\n        self._num_stores = int(re.findall(r'\\d+', \n                                        lines[1])[0])\n\n        self._capacities = [\n                    int(num)\n                    for num in re.findall(r'\\d+', lines[3])\n                ]\n        self._fixed_costs = [\n                    int(num)\n                    for num in re.findall(r'\\d+', lines[4])\n                ]\n        self._demands = [\n                    int(num)\n                    for num in re.findall(r'\\d+', lines[5])\n                ]\n        self._transport_costs = []\n        for line in lines[6:]:\n            numbers = [\n                    int(num)\n                    for num in re.findall(r'\\d+', line)\n                ]\n            self._transport_costs.append(numbers)\n    \n    @property\n    def num_warehouses(self): return self._num_warehouses\n    \n    @property\n    def num_stores(self): return self._num_stores\n    \n    @property\n    def capacities(self): return self._capacities\n    \n    @property\n    def demands(self): return self._demands\n    \n    @property\n    def fixed_costs(self): return self._fixed_costs\n    \n    @property\n    def transport_costs(self): return self._transport_costs\n\nNow we are ready to solve the WLP using OR-Tools!\n\nfrom ortools.linear_solver import pywraplp\nfrom itertools import product\nimport numpy as np\n\nclass WlpSolver:\n    \n    def __init__(self, data_center):\n        self._data_center: WlpDataCenter = data_center\n        \n        self._solver = None\n        self._var_x = None\n        self._var_y = None\n        \n        self._opt_obj = None\n        self._opt_x = None\n        self._opt_y = None\n        \n    def build_model(self):\n        self._solver = pywraplp.Solver.CreateSolver('SCIP')\n\n        self._create_variables()\n        self._create_objective()\n        self._create_constraints()\n        \n    def optimize(self):\n        self._solver.SetTimeLimit(20000)\n        status = self._solver.Solve()\n        if status == pywraplp.Solver.OPTIMAL:\n            num_warehouses = self._data_center.num_warehouses\n            num_stores = self._data_center.num_stores\n            self._opt_obj = self._solver.Objective().Value()\n            self._opt_x = np.zeros((num_warehouses,\n                                    num_stores))\n            for w, s in product(range(num_warehouses),\n                                range(num_stores)):\n                self._opt_x[w][s] = \\\n                    self._var_x[w][s].solution_value()\n            \n            self._opt_y = [\n                self._var_y[w] for w in range(num_warehouses)\n            ]\n    \n    def _create_variables(self):\n        num_warehouses = self._data_center.num_warehouses\n        num_stores = self._data_center.num_stores\n        self._var_x = np.empty((num_warehouses, num_stores),\n                            dtype=object)\n        for w, s in product(range(num_warehouses),\n                            range(num_stores)):\n            self._var_x[w][s] = \\\n                self._solver.NumVar(0, 1,\n                                    name=f'x_{w,s}')\n        \n        self._var_y = [\n            self._solver.BoolVar(name=f'y_{w}')\n            for w in range(num_warehouses)\n        ]\n    \n    def _create_objective(self):\n        num_warehouses = self._data_center.num_warehouses\n        num_stores = self._data_center.num_stores\n        demands = self._data_center.demands\n        transport_costs = self._data_center.transport_costs\n        fixed_costs = self._data_center.fixed_costs\n        expr1 = [\n            transport_costs[s][w] *\n            demands[s] *\n            self._var_x[w][s]\n            for w in range(num_warehouses)\n            for s in range(num_stores)\n        ]\n        expr2 = [\n            fixed_costs[w] *\n            self._var_y[w]\n            for w in range(num_warehouses)\n        ]\n        self._solver.Minimize(\n            self._solver.Sum(expr1) +\n            self._solver.Sum(expr2)\n        )\n    \n    def _create_constraints(self):\n        num_warehouses = self._data_center.num_warehouses\n        num_stores = self._data_center.num_stores\n        for s in range(num_stores):\n            expr = [\n                self._var_x[w][s]\n                for w in range(num_warehouses)\n            ]\n            self._solver.Add(\n                self._solver.Sum(expr) == 1\n            )\n        \n        demands = self._data_center.demands\n        capacities = self._data_center.capacities\n        for w in range(num_warehouses):\n            expr = [\n                self._var_x[w][s] *\n                demands[s]\n                for s in range(num_stores)\n            ]\n            self._solver.Add(\n                self._solver.Sum(expr) &lt;= \n                capacities[w] *\n                self._var_y[w]\n            )\n    \n    @property\n    def opt_obj(self): return self._opt_obj\n    \n    @property\n    def opt_x(self): return self._opt_x\n    \n    @property\n    def opt_y(self): return self._opt_y\n\nThe program defines a class named WlpSolver which has methods to build the model, optimize it and retrieve the optimized solution.\nThe WlpSolver class takes an instance of WlpDataCenter as input, which contains the data necessary to solve the problem. The build_model() method creates variables, objectives, and constraints for the problem using the OR-Tools library. The optimize() method solves the problem and saves the optimized objective function value, opt_obj, the matrix opt_x that indicates the optimal assignment of stores to warehouses, and a list opt_y of binary variables that indicate whether or not each warehouse is open.\nThe _create_variables() method creates two types of variables: a matrix of continuous variables that indicates the proportion of a store’s demands that’s served by a warehouse and a list of binary variables that indicate whether or not each warehouse is open. The _create_objective() method creates the objective function of the problem, which is to minimize the total cost of opening warehouses and serving stores. The _create_constraints() method creates constraints that ensure that every store’s demands are fully fulfilled and a warehouse’s capacity is not violated.\nFinally, the opt_obj, opt_x, and opt_y properties allow access to the results of the optimization.\nTable 11.1 reports the best solutions found within the time limits of 10 seconds for some testing instances.\n\n\n\n\nTable 11.1: Computational results of WLP instances\n\n\nInstance\nNo. Warehouses\nNo. Stores\nBest Solution\n\n\n\n\nwlp1\n1\n3\n1931\n\n\nwlp2\n2\n5\n1891\n\n\nwlp3\n3\n7\n4358\n\n\nwlp4\n4\n10\n4246\n\n\nwlp5\n5\n12\n3502\n\n\nwlp6\n6\n15\n4108\n\n\nwlp7\n7\n17\n4276\n\n\nwlp8\n8\n20\n4888\n\n\nwlp9\n9\n22\n7959\n\n\nwlp10\n10\n25\n8893\n\n\nwlp12\n12\n30\n4890\n\n\nwlp15\n15\n37\n14881\n\n\nwlp20\n20\n50\n9727\n\n\nwlp30\n30\n75\n11964\n\n\nwlp50\n50\n120\n15164\n\n\nwlp100\n100\n220\n20848"
  },
  {
    "objectID": "ip-cutting-stock.html",
    "href": "ip-cutting-stock.html",
    "title": "12  The Cutting Stock Problem",
    "section": "",
    "text": "The cutting stock problem is a common problem in the paper industry, where large rolls of paper must be cut into smaller rolls of various widths to meet customer demands. For example, a paper mill may have a large roll of paper that is 60 inches wide and needs to produce smaller rolls of widths 30, 24, 18, and 12 inches. The mill must determine the best way to cut the large roll of paper into the required widths while minimizing waste.\nLet’s say that a paper company produces rolls with a uniform width of 100 inches and receives orders for rolls with widths of 20, 30, 40, and 50 inches. Table 12.1 shows an illustrative example.\n\n\n\n\nTable 12.1: Demands of different paper rolls\n\n\nOrder Width\nOrder Quantity\n\n\n\n\n20\n100\n\n\n30\n120\n\n\n40\n40\n\n\n50\n20\n\n\n\n\n\n\nTo fulfill these orders, a single 100 inch roll can be cut into one or more of the order widths. This process generates scrap, which is the leftover material that cannot be used. The different combinations of cuts are called patterns. In this case, there are 37 different patterns that can be used.\n\n\n\n\nTable 12.2: Available patterns\n\n\nPattern\nWidth (20)\nWdith (30)\nWidth (40)\nWidth (50)\n\n\n\n\nPattern 1\n1\n1\n1\n0\n\n\nPattern 2\n1\n1\n0\n1\n\n\nPattern 3\n0\n0\n1\n1\n\n\nPattern 4\n3\n0\n1\n0\n\n\nPattern 5\n0\n2\n1\n0\n\n\nPattern 6\n0\n0\n0\n2\n\n\nPattern 7\n5\n0\n0\n0\n\n\nPattern 8\n0\n3\n0\n0\n\n\nPattern 9\n0\n0\n2\n0\n\n\nPattern 10\n2\n0\n0\n1"
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "13  Summary",
    "section": "",
    "text": "In summary, this book has no content whatsoever."
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Beasley, John E. 1990. “OR-Library: Distributing Test Problems by\nElectronic Mail.” Journal of the Operational Research\nSociety 41 (11): 1069–72.\n\n\nChen, Yuning, and Jin-Kao Hao. 2014. “A ‘Reduce and\nSolve’ Approach for the Multiple-Choice Multidimensional Knapsack\nProblem.” European Journal of Operational Research 239\n(2): 313–22. https://doi.org/10.1016/j.ejor.2014.05.025.\n\n\nCVRPLIB. 2014. “CVRPLIB.” http://vrp.galgos.inf.puc-rio.br/index.php/en/.\n\n\nDantzig, G., R. Fulkerson, and S. Johnson. 1954. “Solution of a\nLarge-Scale\nTraveling-Salesman\nProblem.” Journal of the Operations Research\nSociety of America 2 (4): 393–410. https://doi.org/10.1287/opre.2.4.393.\n\n\nDudziński, Krzysztof, and Stanisław Walukiewicz. 1987. “Exact\nMethods for the Knapsack Problem and Its Generalizations.”\nEuropean Journal of Operational Research 28 (1): 3–21. https://doi.org/10.1016/0377-2217(87)90165-2.\n\n\nKondili, E, CC Pantelides, and R WH Sargent. 1988. “A\nGeneral Algorithm for Scheduling\nBatch Operations.” In. Barton, ACT. https://search.informit.org/doi/10.3316/informit.394925233030714.\n\n\nKu, Wen-Yang, and J. Christopher Beck. 2016. “Mixed\nInteger Programming Models for Job Shop\nScheduling: A Computational Analysis.” Computers\n& Operations Research 73 (September): 165–73. https://doi.org/10.1016/j.cor.2016.04.006.\n\n\nLaporte, Gilbert, Hélène Mercure, and Yves Nobert. 1986. “An Exact\nAlgorithm for the Asymmetrical Capacitated Vehicle Routing\nProblem.” Networks 16 (1): 33–46. https://doi.org/10.1002/net.3230160104.\n\n\nLetavec, Craig, and John Ruggiero. 2002. “The n\n-Queens Problem.” INFORMS\nTransactions on Education 2 (3): 101–3. https://doi.org/10.1287/ited.2.3.101.\n\n\nManne, Alan S. 1960. “On the Job-Shop\nScheduling Problem.” Operations\nResearch 8 (2): 219–23. https://doi.org/10.1287/opre.8.2.219.\n\n\nMiller, C. E., A. W. Tucker, and R. A. Zemlin. 1960. “Integer\nProgramming Formulation of\nTraveling Salesman\nProblems.” Journal of the ACM 7 (4):\n326–29. https://doi.org/10.1145/321043.321046.\n\n\nPetersen, Clifford C. 1967. “Computational Experience\nwith Variants of the Balas\nAlgorithm Applied to the\nSelection of R&D\nProjects.” Management Science 13 (9):\n736–50. https://doi.org/10.1287/mnsc.13.9.736.\n\n\nSinha, Prabhakant, and Andris A. Zoltners. 1979. “The\nMultiple-Choice Knapsack\nProblem.” Operations Research 27 (3):\n503–15. https://www.jstor.org/stable/170213.\n\n\nToth, Paolo, and Daniele Vigo. 2014. Vehicle Routing: Problems,\nMethods, and Applications. SIAM.\n\n\nWagner, Harvey M. 1959. “An Integer Linear-Programming Model for\nMachine Scheduling.” Naval Research Logistics Quarterly\n6 (2): 131–40. https://doi.org/10.1002/nav.3800060205."
  }
]